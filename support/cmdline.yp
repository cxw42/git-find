# cmdline.yp: Parse::Yapp file for the command-line parser for App::GitFind
# Copyright (c) 2019 Christopher White.
# Copyright (c) 2019 D3 Engineering, LLC.
# Licensed MIT.

#############################################################################
# Header

%{

# Imports {{{1

use Data::Dumper;   # DEBUG

use strict;
use warnings;
use 5.010;

use Carp qw(croak);
use Hash::Merge;
use Math::Cartesian::Product;

use constant true => !!1;
use constant false => !!0;

# }}}1
# Documentation {{{1

=head1 NAME

App::GitFind::cmdline - Command-line parser for git-find

=head1 SYNOPSIS

Generate the .pm file:

    yapp -m App::GitFind::cmdline -o lib/App/GitFind/cmdline.pm support/cmdline.yp

And then:

    use App::GitFind::cmdline;
    App::GitFind::cmdline::Parse(\@ARGV);

=head1 FUNCTIONS

=cut

# }}}1
# Helpers for the parser {{{1

# Merge any number of hashrefs together and return a hashref
sub _merge {
    state $merger = Hash::Merge->new('RETAINMENT_PRECEDENT');
    $merger->set_clone_behavior(false);     # No cloning
    my $retval = {};
    for(@_) {
        next unless ref eq 'HASH';
        $retval = $merger->merge($retval, $_);
    }
    return $retval;
}

# qw(), but permitting comments.  Call as _qwc(<<EOT).  Thanks to ideas at
# https://www.perlmonks.org/?node=qw%20comments .
sub _qwc ($) {
    my @retval;
    for(split "\n", $_[0]//'') {
        chomp;
        s{#.*$}{};                      # Remove comments
        s{(?:^\s+)|(?:\s+$)}{}g;        # Remove leading/trailing ws
        push @retval, grep { length } split /\s+/;
    }
    return @retval;
} #_qwc()

# }}}1

%}

#############################################################################
# Token and precedence definitions

%token SWITCH       # flags controlling the operation of git-find
%token REV          # a git ref or rev

# elements of expressions
%token COMMA
%token OR
%token AND
%token NOT
%token LPAREN
%token RPAREN

%token TEST
%token ACTION

%left COMMA
%left OR
%left AND
%left NOT

%%

#############################################################################
# Rules

cmdline:
                                { +{} }     # empty
        |   expr                { +{ expr => $_[1] } }
        |   switches_and_revs maybeexprplus     { _merge($_[1], $_[2]) }
        ;

# Switches

switches_and_revs:   SWITCH     { +{ switches => {$_[1]=>true} } }
        |   REV                 { +{ revs => [$_[1]] } }
        |   switches_and_revs SWITCH
                                { _merge($_[1], +{ switches => {$_[2]=>true} }) }
        |   switches_and_revs REV
                                { _merge($_[1], +{ revs => [$_[2]] }) }
        ;

# Expressions.  Since "and", "or", and "not" are keywords in Perl, the

maybeexprplus:
                                    { +{} }     # empty
        | expr                      { +{ expr => $_[1] } }
        | expr switches_and_revs    { +{ expr => $_[1], %{$_[2]} } }
                                    # %$_[2]: inline the switches and revs
        ;

# TODO once the parser is solid and the tests are written:
# collapse consecutive elements of the same type into flat lists.
expr:       element
        |   expr COMMA expr         { +{ SEQ => [@_[1,3]] } }
        |   expr OR expr            { +{ OR => [@_[1,3]] } }
                                    # "OR" because "or" is a Perl keyword

            # subsequent_expr is used so the parser will know when to reduce.
            # The rule "expr expr %prec AND" was right-associative
            # even though explicit-AND was left-associative because
            # the parser did not start reducing until after anything that
            # could be an expr.  A subsequent_expr cannot start with
            # a plain expr, so the parser has a reason to reduce the expr.
        |   expr subsequent_expr %prec AND
                                    { +{ AND => [@_[1,2]] } }
        |   expr AND expr           { +{ AND => [@_[1,3]] } }
        |   NOT expr4               { +{ NOT => $_[2] } }
        |   LPAREN expr RPAREN      { $_[2] }
        ;

subsequent_expr:    # Everything higher-precedence than AND
            element
        |   NOT expr4               { +{ NOT => $_[2] } }
        |   LPAREN expr RPAREN      { $_[2] }
        ;


element:    TEST
        |   ACTION
        ;

%%

#############################################################################
# Footer

# Definitions of supported command-line arguments {{{1

# Helpers for defining these
sub _a { ($_[0] => { token => 'ACTION', nparam => ($_[1]||0) }) }
sub _t { ($_[0] => { token => 'TEST', nparam => ($_[1]||0), index => ($_[2]||false) }) }

# A map from argument name to a details hashref.  Valid keys in the hashref are:
#   token:  The token type
#   nparam: - if a regex, the argument ends with an @ARGV element matching
#             that regex.
#           - if an integer, the argument takes that many parameters (>=0).
#   index:  (for tests only) Whether that test can be evaluated using only
#           information from the index

my %ARGS=(
    # TODO find(1) positional options, global options?

    # No-argument tests -- all happen to be index tests
    map( { _t $_, 0, true }
        qw(empty executable false nogroup nouser readable true writeable) ),

    # No-argument actions
    map( { _a $_ } qw(delete ls print print0 prune quit) ),

    # One-argument index tests
    map( { _t $_, 1, true } qw(
        cmin cnewer ctime
        gid group ilname iname inum ipath iregex iwholename level
        mmin mtime name
        path
        regex
        size type uid
        user wholename
    ) ),

    # One-argument detailed tests
    map( { _t $_, 1 } _qwc <<'EOT' ),
        amin anewer atime fstype
        links lname     # Actually index tests?
        newer
        perm            # Actually index test?
        ref rev         # Maybe not detailed tests - TODO investigate this
        samefile        # Actually index test?
        used
EOT

    # -newerXY forms - all are detailed tests
    map( { _t('newer' . join('', @$_), 1) }
        cartesian {1} [qw(a B c m)], [qw(a B c m t)] ),

    # -amin n
    # -anewer file
    # -atime n
    # -cmin n
    # -cnewer file
    # -ctime n
    # -fstype type
    # -gid n
    # -group gname
    # -ilname pattern
    # -iname pattern
    # -inum n
    # -ipath pattern
    # -iregex pattern
    # -iwholename pattern
    # -level n      # not in find(1) - succeed if the item is at level n
    # -links n
    # -lname pattern
    # -mmin n
    # -mtime n
    # -name pattern
    # -newer file
    # -newerXY reference
    # -path pattern
    # -perm [-/+]?mode
    # -ref revspec          # not in find(1) - specify a git ref OR REV
                            # (identical to -rev so you don't have to
                            #  remember which)
    # -regex pattern
    # -rev revspec          # not in find(1) - specify a git rev OR REF
                            # (identical to -ref)
    # -samefile name
    # -size n
    # -type c
    # -uid n
    # -used n
    # -user uname
    # -wholename pattern
    # -xtype c              # Not supported for now
    # -context pattern      # Not supported for now

    # Actions with a fixed number of arguments
    map( { _a $_, 1 } qw(fls fprint fprint0 printf) ),
    map( { _a $_, 2 } qw(fprintf) ),

    # -fls file
    # -fprint file
    # -fprint0 file
    # -fprintf file format
    # -printf format

    # Actions with a delimited argument list
    # -exec command [;+]
    # -execdir command [;+]
    # -ok command ;
    # -okdir command ;
    map( { _a $_, qr/^[;+]$/ } qw(exec execdir) ),
    map( { _a $_, qr/^;$/ } qw(ok okdir) ),
);

my $ARGTEST;
{   # Make a regex that will match any arg, with - or --.
    my $x = join '|', map { quotemeta } keys %ARGS;
    $ARGTEST = qr{^--?($x)$};
}

# }}}1
# Helpers for the tokenizer {{{1

# Flag a ref as invalid without using regexes.
# Implements https://git-scm.com/docs/git-check-ref-format as archived at
# https://web.archive.org/web/20190725153529/https://git-scm.com/docs/git-check-ref-format

sub _is_ref_ok {
    my $arg = @_ ? $_[0] : $_;

    return false unless defined $arg and length($arg)>0;

    #1 - restrictions on slash-separated components
    if(index($arg, '/') != -1) {
        return false if index($arg, '/.') != -1     #internal components
                    || index($arg, '.lock/') != -1
                    || substr($arg, 0, 1) eq '.'    #components at start/end
                    || substr($arg, -5) eq '.lock';
    }

    # Ignore #2 - assume --allow-onelevel

    #3
    return false if index($arg, '..') != -1;

    #4 - require the caller to check that
    #5 - require the caller to check that - assume NOT --refspec-pattern

    #6 - assume NOT --normalize
    return false if substr($arg, 0, 1) eq '/'
                || substr($arg, -1) eq '/'
                || index($arg, '//') != -1;

    # #7.  Also prohibits ".", which is OK for git-find since it is
    # fairly ambiguous between a ref/rev and a path.
    return false if substr($arg, -1) eq '.';

    #8
    return false if index($arg, '@{') != -1;

    #9 ('@') - ignore this one for simplicity in the rev test below.

    #10 - require the caller to check that

    # Extra: Prohibit refs that start with '--' since they are arguably
    # ambiguous with command-line options (and I can't make them work
    # with git anyway).
    return false if substr($arg, 0, 2) eq '--';

    return true;    # It's OK if we got here
} #_is_ref_ok()

#use re 'debug';

# Regex to match a rev or range of revs, i.e., something we should pass to git
my $_rev_regex =
    qr`(?xi)    # backtick delimiter because it doesn't occur in the regex text
        (?&RevRange)

        (?(DEFINE)

            (?<RevRange> ^(?:
                    # :/text, :/!-text, :/!!text
                    (?::/                   #(?{ print "# saw colon slash\n"; })
                        (?:
                                ![!\-](?:.+)    #(?{print "# 4\n";})
                            |   [^!].*          #(?{print "# 5\u";})
                        )
                    )

                    # :[n:]path.  NOTE: we prohibit starting the path with
                    # / if there is no number, in order to disambiguate
                    # the :/ text-search cases.
                |   :\d+:(?:.+)         #(?{print "# 2\n";})
                |   :[^/].*             #(?{print "# 3\n";})

                    # ^<rev>
                |   \^(?&Rev)           #(?{print "# 6\n";})

                    # rev:path
                |   (?&Rev):(?:.+)      #(?{print "# 7\n";})

                    # .. and ... differences, including x.., x..., x..y,
                    # and x...y.  Also handles the fallthrough
                    # of revrange->rev->ref.
                |   (?&Rev)(?:\.{2,3}(?&Rev)?)?
                                            #(?{print "# 8\n";})

                    # ..rev and ...rev
                |   \.{2,3}(?&Rev)

                    # at sign followed by braced item, and possibly
                    # preceded by a REF (not a rev).  E.g.,
                    # HEAD@{1}@{1} doesn't work.
                    # refname - at sign - braced item (date, #, branch, "push")
                |   (?&Ref)?\@\{[^\}]+\}
                                            #(?{print "# 9\n";})

                    # git-rev-parse "Options for Objects" forms
                |   --all
                |   --(?:branches|tags|remotes)(?:=.+)?
                |   --(?:glob|exclude)=.+
                |   --disambiguate=[0-9a-f]{4,40}

                    # git-rev-parse "Other Options" forms
                |   --(since|after|until|before)=.+

            )$) # End of RevRange

            (?<Rev> (?&Ref)(?&RefTrailer)* )
                    # This handles most of the cases.
                    # SHA1s, possibly abbreviated, are refs,
                    # as are git-describe outputs, whence RefTrailer*
                    # instead of RefTrailer+.

            (?<RefTrailer>
                    # For rev^[#] and rev~[#] forms
                    [~\^]\d*

                    # For rev^{} forms (empty braces OK)
                |   \^\{[^\}]*\}

                    # For rev^[@!] and rev^-n
                |   \^(?: \@ | ! | -\d* )
            ) # End of RefTrailer

            (?<Ref>
                (   \@      # '@' from git-rev-parse
                |   (?:[^\000-\037\177\ ~\^:\\?*\[.@/]
                            # git-check-ref-format #4, #5.
                            # [.@/] are handled below
                    | \.(?!\.)  # . ok, but .. prohibited
                    | \@(?!\{)  # @ ok, but @{ prohibited
                    | /(?!/)    # / ok, but // prohibited

                    )+?
                )
                (?(?{ _is_ref_ok($+) })|(?!))
                    # NOTE: $+ used since I couldn't get named capture groups
                    # with either %+ or %- to work
            ) # End of <Ref>

        ) #End of (DEFINE)

    `xi; # End of qr`...` and an extra backtick to unconfuse vim-eyapp: `

sub _is_valid_rev {
    my $arg = @_ ? $_[0] : $_;

    return false unless defined $arg and length($arg)>0;
    return scalar($arg =~ m{$_rev_regex});
} #_is_valid_rev()

# Get an expression element from the array passed in $_[0].
sub _consume_expression_element {
    my $lrArgv = shift;
    my @retval;

    #say STDERR "# Trying >>$lrArgv->[0]<<";
    # TODO find(1) positional options, global options?

    # Regular options
    if($lrArgv->[0] =~ $ARGTEST) {
        #say STDERR "#   - matched";
        my $arg = $1;
        my %opts = %{$ARGS{$arg}};

        # No-argument tests or actions
        unless($opts{nparam}>0) {
            #say STDERR "#   - No parameters";
            shift @$lrArgv;
            return ($opts{token} => $arg)
        }

        # Consume additional arguments
        #say STDERR "#   - $opts{nparam} parameters";
        die "Not enough parameters after --$arg (need $opts{nparam})"
            unless @$lrArgv >= ($opts{nparam}+1);   # +1 for $arg itself

        @retval = ($opts{token} => {
                        name => $arg,
                        params => [ @{$lrArgv}[1..$opts{nparam}] ]
                    });
        splice @$lrArgv, 0, $opts{nparam}+1;
        return @retval;
    }

    # Operators
    my $arg = $lrArgv->[0];

    @retval = (COMMA => ',') if $arg eq ',';
    @retval = (OR => '-o') if $arg =~ /^(?:-o|--o|-or|--or|\|\|)$/;
    @retval = (AND => '-a') if $arg =~ /^(?:-a|--a|-and|--and|&&)$/;
    @retval = (NOT => '!') if $arg =~ /^(?:-not|--not|!|\^)$/;
    @retval = (LPAREN => '(') if $arg =~ /^[([]$/;
    @retval = (RPAREN => ')') if $arg =~ /^[])]$/;

    if(@retval) {
        shift @$lrArgv;
        return @retval;
    }

    return ();  # Not an expression element
} #_consume_expression_element

# Get a switch from the array passed in $_[0], if any.
# Removes the switch from the array if successful.
# Returns the token on success, and () on failure.
# TODO un-bundle switches; handle switches with args.
sub _consume_switch {
    my $lrArgv = shift;
    if($lrArgv->[0] =~ /^-([a-zA-z0-9\?])$/) {    # non-bundled switch
        shift @$lrArgv;
        return (SWITCH => $1)
    } elsif($lrArgv->[0] =~ /^--?(help|man|usage|version)$/) {  # long switch
        shift @$lrArgv;
        return (SWITCH => $1);
    }

    return ();
} #_consume_switch()

# Consume a rev from the array in $_[0]
sub _consume_rev {
    my $lrArgv = shift;
    my $arg = $lrArgv->[0];
    if(_is_valid_rev($arg)) {
        shift @$lrArgv;
        return (REV => $arg);
    }

    return ();
} #_consume_rev()

# }}}1
# Tokenizer and error-reporting routine for Parse::Yapp {{{1

# The lexer
sub _next_token {
    my $parser = shift;
    my $lrArgv = $parser->YYData->{ARGV};
    return ('', undef) unless @$lrArgv;     # EOF
    my @retval;     # The eventual token we will return

    # TODO? in the expression, split trailing commas into their
    # own arguments

    # Check for '--'
    if($lrArgv->[0] eq '--') {
        $parser->YYData->{ONLY_EXPRESSIONS} = true;
        return ('', undef) unless @$lrArgv > 1;
            # We are about to shift, so return EOF if this was the last arg.
        shift(@$lrArgv);
    }

    if($parser->YYData->{HAS_DASH_DASH}) {
        # Split-arg mode: don't look for expressions before '--', or
        # for switches or refs after '--'.
        if(!$parser->YYData->{ONLY_EXPRESSIONS}) {  # Look for switches/refs

            @retval = _consume_switch($lrArgv);
            return @retval if @retval;

            @retval = _consume_rev($lrArgv);
            return @retval if @retval;

            die "I don't understand argument '$lrArgv->[0]' before --";

        } else {                                    # Look for expressions
            @retval = _consume_expression_element($lrArgv);
            return @retval if @retval;
            die "I don't understand argument '$lrArgv->[0]' after --";
        }

    } else {
        # Merged-arg mode: any arg could be anything

        # Check for expressions.  Look for these before checking for refs so
        # that an expression that happens to look like a ref will be considered
        # an expression instead of a ref.
        my @retval = _consume_expression_element($lrArgv);
        return @retval if @retval;

        # Next, look for switches.  These are after expression elements
        # so that -a and -o will not be parsed as switches.
        @retval = _consume_switch($lrArgv);
        return @retval if @retval;

        # Last of all, revs.
        @retval = _consume_rev($lrArgv);
        return @retval if @retval;

        die "I don't understand argument $lrArgv->[0]";
    }

    die "Unexpected error while processing argument $lrArgv->[0]";   # Shouldn't happen
} #_next_token()

# Report an error
sub _report_error {
    my $parser = shift;
    my $got = $parser->YYCurtok || '<end of input>';
    my $val='';
    $val = ' (' . $parser->YYCurval . ')' if $parser->YYCurval;
    print 'Syntax error: could not understand ', $got, $val, "\n";
    if(ref($parser->YYExpect) eq 'ARRAY') {
        print 'Expected one of: ', join(',', @{$parser->YYExpect}), "\n";
    }
    return;
} #_report_error()

# }}}1
# Top-level parse function {{{1

=head2 Parse

Parse arguments.  Usage:

    my $hrArgs = App::GitFind::cmdline::Parse(\@ARGV);

=cut

sub Parse {
    my $lrArgv = shift or croak 'Parse: Need an argument list';

    my $parser = __PACKAGE__->new;
    my $hrData = $parser->YYData;

    $hrData->{HAS_DASH_DASH} = !!(scalar grep { $_ eq '--' } @$lrArgv);
    $hrData->{ONLY_EXPRESSIONS} = false;    # true once we hit '--'
    $hrData->{ARGV} = $lrArgv;

    return $parser->YYParse(yylex => \&_next_token,
        yyerror => \&_report_error,
        (@_ ? (yydebug => $_[0]) : ()),
    );

} #Parse()

# }}}1
# Rest of the docs {{{1

=head1 AUTHOR

Christopher White C<< <cxw@cpan.org> >>

=head1 COPYRIGHT

MIT

=cut

# }}}1

# vi: set fdm=marker: #

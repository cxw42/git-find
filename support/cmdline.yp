# cmdline.yp: Parse::Yapp file for the command-line parser for App::GitFind
# Copyright (c) 2019 Christopher White.
# Copyright (c) 2019 D3 Engineering, LLC.
# Licensed MIT.

#############################################################################
# Header

%left COMMA
%left OR
%left AND
%left NOT

%{
    use Data::Dumper;
    use constant true => !!1;
    use constant false => !!0;
%}

%%

#############################################################################
# Rules

cmdline:    # empty
        |   contents
        ;

contents:   expr1 COMMA expr1
        ;

expr1:      expr2 OR expr2
        ;

expr2:      expr3 AND expr3
        |   expr3 expr3         # No operator => AND
        ;

expr3:      expr4
        |   NOT expr4
        ;

expr4:      element
        |   LPAREN expr RPAREN
        ;

element:    SWITCH
        |   REF
        |   option
        |   test
        ;

%%

#############################################################################
# Footer

# Flag a ref as invalid without using regexes.
# Implements https://git-scm.com/docs/git-check-ref-format as archived at
# https://web.archive.org/web/20190725153529/https://git-scm.com/docs/git-check-ref-format

sub _is_ref_ok {
    my $arg = @_ ? $_[0] : $_;
    #print STDERR "# _is_ref_ok($arg)\n";

    return false unless defined $arg and length($arg)>0;

    #1 - restrictions on slash-separated components
    if(index($arg, '/') != -1) {
        return false if index($arg, '/.') != -1     #internal components
                    || index($arg, '.lock/') != -1
                    || substr($arg, 0, 1) eq '.'    #components at start/end
                    || substr($arg, -5) eq '.lock';
    }

    # Ignore #2 - assume --allow-onelevel

    #3
    return false if index($arg, '..') != -1;

    #4 - require the caller to check that
    #5 - require the caller to check that - assume NOT --refspec-pattern

    #6 - assume NOT --normalize
    return false if substr($arg, 0, 1) eq '/'
                || substr($arg, -1) eq '/'
                || index($arg, '//') != -1;

    # #7.  Also prohibits ".", which is OK for git-find since it is
    # fairly ambiguous between a ref/rev and a path.
    return false if substr($arg, -1) eq '.';

    #8
    return false if index($arg, '@{') != -1;

    #9 ('@') - ignore this one for simplicity in the rev test below.

    #10 - require the caller to check that

    return true;    # It's OK if we got here
} #_is_ref_ok()

#use re 'debug';

# Regex to match a rev or range of revs, i.e., something we should pass to git
my $_rev_regex =
    qr=(?xi)
        (?&RevRange)

        (?(DEFINE)

            (?<RevRange> ^(?:
                    # :/text, :/!-text, :/!!text
                    :/                      #(?{ print "# saw colon slash\n"; })
                    (?:
                            ![!\-](?>.+)    #(?{print "# 4\n";})
                        |   (?>[^!].*)      #(?{print "# 5\u";})
                    )

                    # :[n:]path.  NOTE: we prohibit starting the path with
                    # / if there is no number, in order to disambiguate
                    # the :/ text-search cases.
                |   :(?>\d+:)(?>.+)         #(?{print "# 2\n";})
                |   :(?>[^/].*)             #(?{print "# 3\n";})

                    # ^<rev>
                |   \^(?>(?&Rev))           #(?{print "# 6\n";})

                    # rev:path
                |   (?>(?&Rev)):(?>.+)      #(?{print "# 7\n";})

                    # .. and ... differences.  Also handles the fallthrough
                    # of revrange->rev->ref.
                |   (?&Rev)(?>\.{2,3}(?>(?&Rev)))?
                                            #(?{print "# 8\n";})

                    # ..rev and ...rev
                |   (?>\.{2,3}(?>(?&Rev)))

                    # at sign followed by braced item, and possibly
                    # preceded by a REF (not a rev).  E.g.,
                    # HEAD@{1}@{1} doesn't work.
                    # refname - at sign - braced item (date, #, branch, "push")
                |   (?&Ref)?(?>\@\{[^\}]+\})
                                            #(?{print "# 9\n";})

            )$) # End of RevRange

            (?<Rev> (?&Ref)(?&RefTrailer)* )
                    # This handles most of the cases.
                    # SHA1s, possibly abbreviated, are refs,
                    # as are git-describe outputs, whence RefTrailer*
                    # instead of RefTrailer+.

            (?<RefTrailer>
                    # For rev^[#] and rev~[#] forms
                    (?>[~\^]\d*)

                    # For rev^{} forms (empty braces OK)
                |   (?>\^\{[^\}]*\})

                    # For rev^[@!] and rev^-n
                |   (?>\^(?: \@ | ! | -\d* ))
            ) # End of RefTrailer

            (?<Ref> # NOTE: do not use (?>...) around a (?&Ref).  Since
                    # @ is ok in a ref but @{ is not, (?>) can leave the @
                    # stuck in the Ref and prevent a match.
                (\@ | [^\000-\037\177\ ~\^:\\?*\[]+)
                    # git-check-ref-format #4, #5, plus '@' from git-rev-parse
                (?(?{ _is_ref_ok($+) })|(?!))
                    # NOTE: $+ used since I couldn't get named capture groups
                    # with either %+ or %- to work
            ) # End of <Ref>

        ) #End of (DEFINE)

    =xi;

sub _is_valid_rev {
    my $arg = @_ ? $_[0] : $_;
    #print STDERR "# _is_valid_rev($arg)\n";

    return false unless defined $arg and length($arg)>0;

    my $ok = $arg =~ m{$_rev_regex};

    #print STDERR "# Tried rev -$arg- which was @{[$ok ? 'ok' : 'not ok']}\n";
    return $ok;
} #_is_valid_rev()

sub _next_token {
    my $parser = shift;
    my $lrArgv = $parser->YYData->{ARGV};
    my $arg = @$lrArgv ? shift(@$lrArgv) : undef;

    # TODO? in the expression, split trailing commas into their
    # own arguments

    # Check for '--'
    if($arg eq '--') {
        $parser->YYData->{ONLY_EXPRESSIONS} = true;
        $arg = @$lrArgv ? shift(@$lrArgv) : undef;
    }

    my $only_expressions = !!$parser->YYData->{ONLY_EXPRESSIONS};   # after -- ?

    # Check for expressions.  Look for these before checking for refs so that
    # an expression that happens to look like a ref will be considered an
    # expression instead of a ref.
    #   => TODO before parsing, see if we have a '--'.  If so, don't look
    #       for expressions before the -- , and don't look for refs after
    #       the -- .  If not, look for expressions before refs.

    # Check for switches
    unless($only_expressions) {
        return (SWITCH => $1) if /^-([a-zA-z0-9])$/;  # non-bundled switch

        # TODO un-bundle switches
    }


    # Check for refs
    unless($only_expressions) {
        return (REF => $arg) if _is_valid_rev($arg);

        # Check for possible refs at the end, since many strings might be refs.
        return (REF => $arg) if !$only_expressions && _is_valid_ref($arg);
    }

    die "I can't understand argument $arg";     # TODO any better way to handle this?
} #_next_token()


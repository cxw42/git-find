# cmdline.yp: Parse::Yapp file for the command-line parser for App::GitFind
# Copyright (c) 2019 Christopher White.
# Copyright (c) 2019 D3 Engineering, LLC.
# Licensed MIT.

#############################################################################
# Header

%token SWITCH       # flags controlling the operation of git-find
%token REV          # a git ref or rev

# elements of expressions
%token COMMA
%token OR
%token AND
%token NOT
%token LPAREN
%token RPAREN

%token TEST
%token ACTION

%left COMMA
%left OR
%left AND
%left NOT

%{
#use Data::Dumper;   # DEBUG

use strict;
use warnings;
use 5.010;

use Carp qw(croak);
use Hash::Merge;

use constant true => !!1;
use constant false => !!0;

# Documentation {{{1

=head1 NAME

App::GitFind::cmdline - Command-line parser for git-find

=head1 SYNOPSIS

Generate the .pm file:

    yapp -m App::GitFind::cmdline -o lib/App/GitFind/cmdline.pm support/cmdline.yp

And then:

    use App::GitFind::cmdline;
    App::GitFind::cmdline::Parse(\@ARGV);

=head1 FUNCTIONS

=cut

# }}}1
# Helpers for the parser {{{1

# Merge any number of hashrefs together and return a hashref
sub _merge {
    state $merger = Hash::Merge->new('RETAINMENT_PRECEDENT');
    $merger->set_clone_behavior(false);     # No cloning
    my $retval = {};
    for(@_) {
        next unless ref eq 'HASH';
        $retval = $merger->merge($retval, $_);
    }
    return $retval;
}

# }}}1

%}

%%

#############################################################################
# Rules

cmdline:    # empty             { +{} }
        |   expr                { +{ expr => $_[1] } }
        |   switches_and_revs maybeexprplus
                                { _merge($_[1], +{expr => $_[2]}, $_[3]) }
        ;

# Switches

switches_and_revs:   SWITCH     { +{ switches => {$_[1]=>true} } }
        |   REV                 { +{ revs => [$_[1]] } }
        |   switches_and_revs SWITCH
                                { _merge($_[1], +{ switches => {$_[2]=>true} }) }
        |   switches_and_revs REV
                                { _merge($_[1], +{ revs => [$_[2]] }) }
        ;

# Expressions

maybeexprplus:  # empty
        | expr
        | expr switches_and_revs
        ;

expr:       element
        |   expr COMMA expr         { +{ seq => [@_[1,3]] } }
        |   expr OR expr            { +{ disjunction => [@_[1,3]] } }
        |   expr expr %prec AND     { +{ conjunction => [@_[1,2]] } }
        |   expr AND expr           { +{ conjunction => [@_[1,3]] } }
        |   NOT expr4               { +{ negation => $_[2] } }
        |   LPAREN expr RPAREN      { $_[2] }
        ;

element:    TEST
        |   ACTION
#        |   REV
#        |   option
#        |   test
        ;

%%

#############################################################################
# Footer

# Definitions of supported command-line arguments {{{1

# Helpers for defining these
sub _a ($) { ($_[0] => {}) }
sub _an ($$) { ($_[0] => { nargs => ($_[1]||0) }) }

my %args=(
    # TODO find(1) positional options, global options?

    # No-argument tests
    map( { _a $_ }
        qw(empty executable false nogroup nouser readable true writeable) ),

    # No-argument actions
    map( { _a $_ } qw(delete ls print print0 prune quit) ),

    # Tests with arguments.
    # -amin n
    # -anewer file
    # -atime n
    # -cmin n
    # -cnewer file
    # -ctime n
    # -fstype type
    # -gid n
    # -group gname
    # -ilname pattern
    # -iname pattern
    # -inum n
    # -ipath pattern
    # -iregex pattern
    # -iwholename pattern
    # -links n
    # -lname pattern
    # -mmin n
    # -mtime n
    # -name pattern
    # -newer file
    # -newerXY reference
    # -path pattern
    # -perm [-/+]?mode
    # -ref revspec          # not in find(1) - specify a git ref OR REV
                            # (identical to -rev so you don't have to
                            #  remember which)
    # -regex pattern
    # -rev revspec          # not in find(1) - specify a git rev OR REF
                            # (identical to -ref)
    # -samefile name
    # -size n
    # -type c
    # -uid n
    # -used n
    # -user uname
    # -wholename pattern
    # -xtype c
    # -context pattern

    # Actions with arguments
    # -exec command [;+]
    # -execdir command [;+]
    # -fls file
    # -fprint file
    # -fprint0 file
    # -fprintf file format
    # -ok command ;
    # -okdir command ;
    # -printf format
);

# }}}1
# Helpers for the tokenizer {{{1

# Flag a ref as invalid without using regexes.
# Implements https://git-scm.com/docs/git-check-ref-format as archived at
# https://web.archive.org/web/20190725153529/https://git-scm.com/docs/git-check-ref-format

sub _is_ref_ok {
    my $arg = @_ ? $_[0] : $_;
    #print STDERR "# _is_ref_ok($arg)\n";

    return false unless defined $arg and length($arg)>0;

    #1 - restrictions on slash-separated components
    if(index($arg, '/') != -1) {
        return false if index($arg, '/.') != -1     #internal components
                    || index($arg, '.lock/') != -1
                    || substr($arg, 0, 1) eq '.'    #components at start/end
                    || substr($arg, -5) eq '.lock';
    }

    # Ignore #2 - assume --allow-onelevel

    #3
    return false if index($arg, '..') != -1;

    #4 - require the caller to check that
    #5 - require the caller to check that - assume NOT --refspec-pattern

    #6 - assume NOT --normalize
    return false if substr($arg, 0, 1) eq '/'
                || substr($arg, -1) eq '/'
                || index($arg, '//') != -1;

    # #7.  Also prohibits ".", which is OK for git-find since it is
    # fairly ambiguous between a ref/rev and a path.
    return false if substr($arg, -1) eq '.';

    #8
    return false if index($arg, '@{') != -1;

    #9 ('@') - ignore this one for simplicity in the rev test below.

    #10 - require the caller to check that

    # Extra: Prohibit refs that start with '--' since they are arguably
    # ambiguous with command-line options (and I can't make them work
    # with git anyway).
    return false if substr($arg, 0, 2) eq '--';

    return true;    # It's OK if we got here
} #_is_ref_ok()

#use re 'debug';

# Regex to match a rev or range of revs, i.e., something we should pass to git
my $_rev_regex =
    qr`(?xi)    # backtick delimiter because it doesn't occur in the regex text
        (?&RevRange)

        (?(DEFINE)

            (?<RevRange> ^(?:
                    # :/text, :/!-text, :/!!text
                    (?::/                   #(?{ print "# saw colon slash\n"; })
                        (?:
                                ![!\-](?:.+)    #(?{print "# 4\n";})
                            |   [^!].*          #(?{print "# 5\u";})
                        )
                    )

                    # :[n:]path.  NOTE: we prohibit starting the path with
                    # / if there is no number, in order to disambiguate
                    # the :/ text-search cases.
                |   :\d+:(?:.+)         #(?{print "# 2\n";})
                |   :[^/].*             #(?{print "# 3\n";})

                    # ^<rev>
                |   \^(?&Rev)           #(?{print "# 6\n";})

                    # rev:path
                |   (?&Rev):(?:.+)      #(?{print "# 7\n";})

                    # .. and ... differences, including x.., x..., x..y,
                    # and x...y.  Also handles the fallthrough
                    # of revrange->rev->ref.
                |   (?&Rev)(?:\.{2,3}(?&Rev)?)?
                                            #(?{print "# 8\n";})

                    # ..rev and ...rev
                |   \.{2,3}(?&Rev)

                    # at sign followed by braced item, and possibly
                    # preceded by a REF (not a rev).  E.g.,
                    # HEAD@{1}@{1} doesn't work.
                    # refname - at sign - braced item (date, #, branch, "push")
                |   (?&Ref)?\@\{[^\}]+\}
                                            #(?{print "# 9\n";})

                    # git-rev-parse "Options for Objects" forms
                |   --all
                |   --(?:branches|tags|remotes)(?:=.+)?
                |   --(?:glob|exclude)=.+
                |   --disambiguate=[0-9a-f]{4,40}

                    # git-rev-parse "Other Options" forms
                |   --(since|after|until|before)=.+

            )$) # End of RevRange

            (?<Rev> (?&Ref)(?&RefTrailer)* )
                    # This handles most of the cases.
                    # SHA1s, possibly abbreviated, are refs,
                    # as are git-describe outputs, whence RefTrailer*
                    # instead of RefTrailer+.

            (?<RefTrailer>
                    # For rev^[#] and rev~[#] forms
                    [~\^]\d*

                    # For rev^{} forms (empty braces OK)
                |   \^\{[^\}]*\}

                    # For rev^[@!] and rev^-n
                |   \^(?: \@ | ! | -\d* )
            ) # End of RefTrailer

            (?<Ref>
                (   \@      # '@' from git-rev-parse
                |   (?:[^\000-\037\177\ ~\^:\\?*\[.@/]
                            # git-check-ref-format #4, #5.
                            # [.@/] are handled below
                    | \.(?!\.)  # . ok, but .. prohibited
                    | \@(?!\{)  # @ ok, but @{ prohibited
                    | /(?!/)    # / ok, but // prohibited

                    )+?
                )
                (?(?{ _is_ref_ok($+) })|(?!))
                    # NOTE: $+ used since I couldn't get named capture groups
                    # with either %+ or %- to work
            ) # End of <Ref>

        ) #End of (DEFINE)

    `xi; # End of qr`...` and an extra backtick to unconfuse vim-eyapp: `

sub _is_valid_rev {
    my $arg = @_ ? $_[0] : $_;
    #print STDERR "# _is_valid_rev($arg)\n";

    return false unless defined $arg and length($arg)>0;

    my $ok = $arg =~ m{$_rev_regex};

    #print STDERR "# Tried rev -$arg- which was @{[$ok ? 'ok' : 'not ok']}\n";
    return $ok;
} #_is_valid_rev()

# Helper to check for expression elements
sub _get_expression_element {
    croak "_get_expression_element: need list context" unless wantarray;
    my $arg = shift or croak '_get_expression_element: Need an arg';

    # TODO find(1) positional options, global options?

    # No-argument tests
    return (TEST => $1) if $arg =~ m{(?x)^--?(
        empty|executable|false|nogroup|nouser|readable|true|writeable)$};

    # No-argument actions
    return (ACTION => $1) if $arg =~ m{(?x)^--?(
        delete|ls|print|print0|prune|quit)$};

    # TODO Return one-element list to request another arg.

    # TODO things with args

    # Operators
    return (COMMA => ',') if $arg eq ',';
    return (OR => '-o') if $arg =~ /^(?:-o|--o|-or|--or|\|\|)$/;
    return (AND => '-a') if $arg =~ /^(?:-a|--a|-and|--and|&&)$/;
    return (NOT => '!') if $arg =~ /^(?:-not|--not|!|\^)$/;
    return (LPAREN => '(') if $arg =~ /^[([]$/;
    return (RPAREN => ')') if $arg =~ /^[])]$/;

    return ();  # Not an expression element
} #_get_expression_element

# }}}1
# Functions that Parse::Yapp requires us to provide {{{1

# The lexer
sub _next_token {
    my $parser = shift;
    my $lrArgv = $parser->YYData->{ARGV};
    return ('', undef) unless @$lrArgv;     # EOF
    my $arg = shift(@$lrArgv);

    # TODO? in the expression, split trailing commas into their
    # own arguments

    # Check for '--'
    if($arg eq '--') {
        $parser->YYData->{ONLY_EXPRESSIONS} = true;
        return ('', undef) unless @$lrArgv;
            # We are about to shift, so return EOF if this was the last arg.
        $arg = shift(@$lrArgv);
    }

    if($parser->YYData->{HAS_DASH_DASH}) {
        # Split-arg mode: don't look for expressions before '--' or refs after.
        if(!$parser->YYData->{ONLY_EXPRESSIONS}) {  # Look for switches/refs

            return (SWITCH => $1) if $arg =~ /^-([a-zA-z0-9])$/;
                    # non-bundled switch
            # TODO un-bundle switches; handle switches with args

            # Long switches
            return (SWITCH => $1) if $arg =~ /^--?(help|version|man)$/;

            return (REV => $arg) if _is_valid_rev($arg);

            die "I don't understand argument $arg before --";

        } else {                                    # Look for expressions
            my @expr = _get_expression_element($arg);
            return @expr if @expr;
            die "I don't understand argument $arg after --";
        }

    } else {
        # Merged-arg mode: any arg could be anything

        # TODO update per the above
        return (SWITCH => $1) if $arg =~ /^-([a-zA-z0-9])$/;
        # Long switches
        return (SWITCH => $1) if $arg =~ /^--?(help|version|man)$/;

        # Check for expressions.  Look for these before checking for refs so
        # that an expression that happens to look like a ref will be considered
        # an expression instead of a ref.
        my @expr = _get_expression_element($arg);
        return @expr if @expr==2;   # We found a standalone element

        return (REV => $arg) if _is_valid_rev($arg);

        die "I don't understand argument $arg";
    }

    die "Unexpected error while processing argument $arg";   # Shouldn't happen
} #_next_token()

# Report an error
sub _report_error {
    # Default, copied from Parse-Yapp/Calc.yp
        exists $_[0]->YYData->{ERRMSG}
    and do {
        print $_[0]->YYData->{ERRMSG};
        delete $_[0]->YYData->{ERRMSG};
        return;
    };
    print "Syntax error.\n";
} #_report_error()

# }}}1
# Top-level parse function {{{1

=head2 Parse

Parse arguments.  Usage:

    my $hrArgs = App::GitFind::cmdline::Parse(\@ARGV);

=cut

sub Parse {
    my $lrArgv = shift or croak 'Parse: Need an argument list';

    my $parser = __PACKAGE__->new;
    my $hrData = $parser->YYData;

    $hrData->{HAS_DASH_DASH} = !!(scalar grep { $_ eq '--' } @$lrArgv);
    $hrData->{ONLY_EXPRESSIONS} = false;    # true once we hit '--'
    $hrData->{ARGV} = $lrArgv;

    return $parser->YYParse(yylex => \&_next_token,
        yyerror => \&_report_error,
        (@_ ? (yydebug => $_[0]) : ()),
    );

} #Parse()

# }}}1
# Rest of the docs {{{1

=head1 AUTHOR

Christopher White C<< <cxw@cpan.org> >>

=head1 COPYRIGHT

MIT

=cut

# }}}1

# vi: set fdm=marker: #

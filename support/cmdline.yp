# cmdline.yp: Parse::Yapp file for the command-line parser for App::GitFind
# Copyright (c) 2019 D3 Engineering, LLC.  Licensed MIT.

# Header
%left COMMA
%left OR
%left AND
%left NOT

%{
    use Data::Dumper;
    use constant true => !!1;
    use constant false => !!0;
%}

%%

# Rules

cmdline:    # empty
        |   contents
        ;

contents:   expr1 COMMA expr1
        ;

expr1:      expr2 OR expr2
        ;

expr2:      expr3 AND expr3
        |   expr3 expr3         # No operator => AND
        ;

expr3:      expr4
        |   NOT expr4
        ;

expr4:      element
        |   LPAREN expr RPAREN
        ;

element:    SWITCH
        |   REF
        |   option
        |   test
        ;

%%

# Footer

# Flag a ref as invalid without using regexes.
# Implements https://git-scm.com/docs/git-check-ref-format as archived at
# https://web.archive.org/web/20190725153529/https://git-scm.com/docs/git-check-ref-format

sub _is_ref_ok {
    my $arg = @_ ? $_[0] : $_;
    #print STDERR "# _is_ref_ok($arg)\n";

    return false unless defined $arg and length($arg)>0;

    #1 - restrictions on slash-separated components
    if(index($arg, '/') != -1) {
        return false if index($arg, '/.') != -1     #internal components
                    || index($arg, '.lock/') != -1
                    || substr($arg, 0, 1) eq '.'    #components at start/end
                    || substr($arg, -5) eq '.lock';
    }

    # Ignore #2 - assume --allow-onelevel

    #3
    return false if index($arg, '..') != -1;

    #4 - require the caller to check that
    #5 - require the caller to check that - assume NOT --refspec-pattern

    #6 - assume NOT --normalize
    return false if substr($arg, 0, 1) eq '/'
                || substr($arg, -1) eq '/'
                || index($arg, '//') != -1;

    #7
    return false if substr($arg, -1) eq '.';

    #8
    return false if index($arg, '@{') != -1;

    #9
    return false if $arg eq '@';

    #10 - require the caller to check that

    return true;    # It's OK if we got here
} #_is_ref_ok()

#our @_to_check;     # list of [coderef, parameter(s)]

use re 'debug';

# Regex to match a rev that is not itself a ref.
my $_rev_regex =
    qr{(?xi)
        (?:(?&Rev))

        (?(DEFINE)

            (?<Rev> ^(?:    # If any of these match, it's valid

                    # SHA1s, possibly abbreviated, are refs,
                    # as are git-describe outputs.
                    (?&Ref)

                    # HEAD
                |   \@

                    # refname - at sign - braced item (date, #, branch, "push")
                |   ((?&Ref))\@\{[^\}]+\}

                    # at sign followed by braced item
                |   \@\{[^\}]+\}

                    # rev^[#] and rev~[#] forms
                |   ((?&Rev))(?:[~\^]\d*)+

                    # rev^{} forms (empty braces OK)
                |   ((?&Rev))\^\{[^\}]*\}

                    # :/text, :/!-text, :/!!text
                |   :/(?:![!-].+|[^!].*)

                    # rev:path
                |   ((?&Rev)):.+

                    # :[n:]path
                |   :(?:\d+:)?.+

                    # ^<rev>
                |   \^((?&Rev))

                    # .. and ... differences
                |   ((?&Rev))\.{2,3}((?&Rev))

                    # rev^[@!] and rev^-n
                |   ((?&Rev))\^(?:\@|!|-\d*)

                )$) #End of <Rev>

            (?<Ref>
                ([^\000-\037\177 ~\^:\\?*\[]+)   # git-check-ref-format #4, #5
                (?(?{ _is_ref_ok($+) })|(?!))
                    # NOTE: $+ used since I couldn't get named capture groups
                    # with either %+ or %- to work
            ) #End of <Ref>

        ) #End of (DEFINE)

    }xi;

sub _is_valid_rev {

    #local @_to_check;

    my $arg = @_ ? $_[0] : $_;
    #print STDERR "# _is_valid_rev($arg)\n";

    return false unless defined $arg and length($arg)>0;

#    local $+;   # Since we are re-entrant and use this in code blocks
#                # in the regex.

    #my $private_re = qr{$_rev_regex};
    my $ok = $arg =~ m{$_rev_regex};    #m{$private_re};
    return false unless $ok;

#    # TODO figure this out
#    # See if we have any recursive checks to do.  This is to prevent the
#    # regex engine from being re-entered.
#    for(@_to_check) {
#        my ($coderef, @args) = @$_;
#        return false unless $coderef->(@args);
#    }

    #print STDERR "# Tried rev -$arg- which was @{[$ok ? 'ok' : 'not ok']}\n";
    return true;
} #_is_valid_rev()

sub _next_token {
    my $parser = shift;
    my $lrArgv = $parser->YYData->{ARGV};
    my $arg = @$lrArgv ? shift(@$lrArgv) : undef;

    # Check for '--'
    if($arg eq '--') {
        $parser->YYData->{ONLY_EXPRESSIONS} = true;
        $arg = @$lrArgv ? shift(@$lrArgv) : undef;
    }

    my $only_expressions = !!$parser->YYData->{ONLY_EXPRESSIONS};   # after -- ?

    # Check for expressions.  Look for these before checking for refs so that
    # an expression that happens to look like a ref will be considered an
    # expression instead of a ref.
    #   => TODO before parsing, see if we have a '--'.  If so, don't look
    #       for expressions before the -- , and don't look for refs after
    #       the -- .  If not, look for expressions before refs.

    # Check for switches
    unless($only_expressions) {
        return (SWITCH => $1) if /^-([a-zA-z0-9])$/;  # non-bundled switch

        # TODO un-bundle switches
    }


    # Check for refs
    unless($only_expressions) {
        return (REF => $arg) if _is_valid_rev($arg);

        # Check for possible refs at the end, since many strings might be refs.
        return (REF => $arg) if !$only_expressions && _is_valid_ref($arg);
    }

    die "I can't understand argument $arg";     # TODO any better way to handle this?
} #tokenize()


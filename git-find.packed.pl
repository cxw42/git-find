#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/GitFind.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_GITFIND';
  package App::GitFind;
  
  use 5.010;
  use strict;
  use warnings;
  
  use Getopt::Long 2.34 qw(GetOptionsFromArray :config),
      qw(auto_help auto_version),     # handle -?, --help, --version
      qw(passthrough require_order),  # stop at the first unrecognized.  TODO
      qw(no_getopt_compat gnu_compat bundling);   # --foo, -x, no +x
  
  use Git;
  
  our $VERSION = '0.000001';
  
  # === Documentation === {{{1
  
  =head1 NAME
  
  App::GitFind - Find files anywhere in a Git repository
  
  =head1 SYNOPSIS
  
  Quick summary of what the module does.
  
  Perhaps a little code snippet.
  
      use App::GitFind;
      exit App::GitFind->new(\@ARGV)->run;
  
  See L<git-find> for more usage information.
  
  =head1 SUBROUTINES/METHODS
  
  =cut
  
  # }}}1
  
  =head2 new
  
  The constructor.  Takes an arrayref of arguments, e.g., C<\@ARGV>.  May
  C<exit()>, e.g., on C<--help>.
  
  =cut
  
  sub new {
      my ($package, $lrArgv) = @_;
      my $self = _process_options($lrArgv);
      bless $self, $package;
  } #new()
  
  =head2 run
  
  Does the work.
  
  =cut
  
  sub run {
      my $repo = Git->repository('.');
      use Data::Dumper;
      say "Repo: ", Dumper $repo;
  } #new()
  
  =head1 INTERNALS
  
  =head2 _process_options
  
  Process the options and return a hashref.  Any remaining arguments are
  stored under key C<_>.
  
  =cut
  
  sub _process_options {
      my $lrArgv = shift // [];
      my %opts;
  
      # uncoverable branch true
      GetOptionsFromArray($lrArgv, \%opts, qw(h man v))
          or die 'Error while processing global options';
          # At present, this always succeeds, because it is configured to simply
          # stop at the first unrecognized option, and because none of the
          # options have coderefs or validation.
      $opts{_} = $lrArgv if @$lrArgv;
  
      Getopt::Long::HelpMessage(-exitval => 0, -verbose => 2) if $opts{man};
      Getopt::Long::HelpMessage(-exitval => 0) if $opts{h};
      Getopt::Long::VersionMessage(-exitval => 0) if $opts{v};
  
      #Getopt::Long::HelpMessage(-exitval => 2) unless @$lrArgv;
  
      return \%opts;
  } #_process_options
  
  1; # End of App::GitFind
  __END__
  
  # === Rest of the docs === {{{1
  
  =head1 AUTHOR
  
  Christopher White, C<< <cxw at cpan.org> >>
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2019 Christopher White.
  
  This program is distributed under the MIT (X11) License:
  L<http://www.opensource.org/licenses/mit-license.php>
  
  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation
  files (the "Software"), to deal in the Software without
  restriction, including without limitation the rights to use,
  copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following
  conditions:
  
  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.
  
  =cut
  
  # }}}1
  # vi: set fdm=marker fdl=0: #
APP_GITFIND

$fatpacked{"Getopt/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG';
  #! perl
  
  # Getopt::Long.pm -- Universal options parsing
  # Author          : Johan Vromans
  # Created On      : Tue Sep 11 15:00:12 1990
  # Last Modified By: Johan Vromans
  # Last Modified On: Sat May 27 12:11:39 2017
  # Update Count    : 1715
  # Status          : Released
  
  ################ Module Preamble ################
  
  use 5.004;
  
  use strict;
  use warnings;
  
  package Getopt::Long;
  
  use vars qw($VERSION);
  $VERSION        =  2.50;
  # For testing versions only.
  use vars qw($VERSION_STRING);
  $VERSION_STRING = "2.50";
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  # Exported subroutines.
  sub GetOptions(@);		# always
  sub GetOptionsFromArray(@);	# on demand
  sub GetOptionsFromString(@);	# on demand
  sub Configure(@);		# on demand
  sub HelpMessage(@);		# on demand
  sub VersionMessage(@);		# in demand
  
  BEGIN {
      # Init immediately so their contents can be used in the 'use vars' below.
      @EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
      @EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
  		    &GetOptionsFromArray &GetOptionsFromString);
  }
  
  # User visible variables.
  use vars @EXPORT, @EXPORT_OK;
  use vars qw($error $debug $major_version $minor_version);
  # Deprecated visible variables.
  use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
  	    $passthrough);
  # Official invisible variables.
  use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  
  # Really invisible variables.
  my $bundling_values;
  
  # Public subroutines.
  sub config(@);			# deprecated name
  
  # Private subroutines.
  sub ConfigDefaults();
  sub ParseOptionSpec($$);
  sub OptCtl($);
  sub FindOption($$$$$);
  sub ValidValue ($$$$$);
  
  ################ Local Variables ################
  
  # $requested_version holds the version that was mentioned in the 'use'
  # or 'require', if any. It can be used to enable or disable specific
  # features.
  my $requested_version = 0;
  
  ################ Resident subroutines ################
  
  sub ConfigDefaults() {
      # Handle POSIX compliancy.
      if ( defined $ENV{"POSIXLY_CORRECT"} ) {
  	$genprefix = "(--|-)";
  	$autoabbrev = 0;		# no automatic abbrev of options
  	$bundling = 0;			# no bundling of single letter switches
  	$getopt_compat = 0;		# disallow '+' to start options
  	$order = $REQUIRE_ORDER;
      }
      else {
  	$genprefix = "(--|-|\\+)";
  	$autoabbrev = 1;		# automatic abbrev of options
  	$bundling = 0;			# bundling off by default
  	$getopt_compat = 1;		# allow '+' to start options
  	$order = $PERMUTE;
      }
      # Other configurable settings.
      $debug = 0;			# for debugging
      $error = 0;			# error tally
      $ignorecase = 1;		# ignore case when matching options
      $passthrough = 0;		# leave unrecognized options alone
      $gnu_compat = 0;		# require --opt=val if value is optional
      $longprefix = "(--)";       # what does a long prefix look like
      $bundling_values = 0;	# no bundling of values
  }
  
  # Override import.
  sub import {
      my $pkg = shift;		# package
      my @syms = ();		# symbols to import
      my @config = ();		# configuration
      my $dest = \@syms;		# symbols first
      for ( @_ ) {
  	if ( $_ eq ':config' ) {
  	    $dest = \@config;	# config next
  	    next;
  	}
  	push(@$dest, $_);	# push
      }
      # Hide one level and call super.
      local $Exporter::ExportLevel = 1;
      push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
      $requested_version = 0;
      $pkg->SUPER::import(@syms);
      # And configure.
      Configure(@config) if @config;
  }
  
  ################ Initialization ################
  
  # Values for $order. See GNU getopt.c for details.
  ($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
  # Version major/minor numbers.
  ($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
  
  ConfigDefaults();
  
  ################ OO Interface ################
  
  package Getopt::Long::Parser;
  
  # Store a copy of the default configuration. Since ConfigDefaults has
  # just been called, what we get from Configure is the default.
  my $default_config = do {
      Getopt::Long::Configure ()
  };
  
  sub new {
      my $that = shift;
      my $class = ref($that) || $that;
      my %atts = @_;
  
      # Register the callers package.
      my $self = { caller_pkg => (caller)[0] };
  
      bless ($self, $class);
  
      # Process config attributes.
      if ( defined $atts{config} ) {
  	my $save = Getopt::Long::Configure ($default_config, @{$atts{config}});
  	$self->{settings} = Getopt::Long::Configure ($save);
  	delete ($atts{config});
      }
      # Else use default config.
      else {
  	$self->{settings} = $default_config;
      }
  
      if ( %atts ) {		# Oops
  	die(__PACKAGE__.": unhandled attributes: ".
  	    join(" ", sort(keys(%atts)))."\n");
      }
  
      $self;
  }
  
  sub configure {
      my ($self) = shift;
  
      # Restore settings, merge new settings in.
      my $save = Getopt::Long::Configure ($self->{settings}, @_);
  
      # Restore orig config and save the new config.
      $self->{settings} = Getopt::Long::Configure ($save);
  }
  
  sub getoptions {
      my ($self) = shift;
  
      return $self->getoptionsfromarray(\@ARGV, @_);
  }
  
  sub getoptionsfromarray {
      my ($self) = shift;
  
      # Restore config settings.
      my $save = Getopt::Long::Configure ($self->{settings});
  
      # Call main routine.
      my $ret = 0;
      $Getopt::Long::caller = $self->{caller_pkg};
  
      eval {
  	# Locally set exception handler to default, otherwise it will
  	# be called implicitly here, and again explicitly when we try
  	# to deliver the messages.
  	local ($SIG{__DIE__}) = 'DEFAULT';
  	$ret = Getopt::Long::GetOptionsFromArray (@_);
      };
  
      # Restore saved settings.
      Getopt::Long::Configure ($save);
  
      # Handle errors and return value.
      die ($@) if $@;
      return $ret;
  }
  
  package Getopt::Long;
  
  ################ Back to Normal ################
  
  # Indices in option control info.
  # Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
  use constant CTL_TYPE    => 0;
  #use constant   CTL_TYPE_FLAG   => '';
  #use constant   CTL_TYPE_NEG    => '!';
  #use constant   CTL_TYPE_INCR   => '+';
  #use constant   CTL_TYPE_INT    => 'i';
  #use constant   CTL_TYPE_INTINC => 'I';
  #use constant   CTL_TYPE_XINT   => 'o';
  #use constant   CTL_TYPE_FLOAT  => 'f';
  #use constant   CTL_TYPE_STRING => 's';
  
  use constant CTL_CNAME   => 1;
  
  use constant CTL_DEFAULT => 2;
  
  use constant CTL_DEST    => 3;
   use constant   CTL_DEST_SCALAR => 0;
   use constant   CTL_DEST_ARRAY  => 1;
   use constant   CTL_DEST_HASH   => 2;
   use constant   CTL_DEST_CODE   => 3;
  
  use constant CTL_AMIN    => 4;
  use constant CTL_AMAX    => 5;
  
  # FFU.
  #use constant CTL_RANGE   => ;
  #use constant CTL_REPEAT  => ;
  
  # Rather liberal patterns to match numbers.
  use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
  use constant PAT_XINT  =>
    "(?:".
  	  "[-+]?_*[1-9][0-9_]*".
    "|".
  	  "0x_*[0-9a-f][0-9a-f_]*".
    "|".
  	  "0b_*[01][01_]*".
    "|".
  	  "0[0-7_]*".
    ")";
  use constant PAT_FLOAT =>
    "[-+]?".			# optional sign
    "(?=[0-9.])".			# must start with digit or dec.point
    "[0-9_]*".			# digits before the dec.point
    "(\.[0-9_]+)?".		# optional fraction
    "([eE][-+]?[0-9_]+)?";	# optional exponent
  
  sub GetOptions(@) {
      # Shift in default array.
      unshift(@_, \@ARGV);
      # Try to keep caller() and Carp consistent.
      goto &GetOptionsFromArray;
  }
  
  sub GetOptionsFromString(@) {
      my ($string) = shift;
      require Text::ParseWords;
      my $args = [ Text::ParseWords::shellwords($string) ];
      $caller ||= (caller)[0];	# current context
      my $ret = GetOptionsFromArray($args, @_);
      return ( $ret, $args ) if wantarray;
      if ( @$args ) {
  	$ret = 0;
  	warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n");
      }
      $ret;
  }
  
  sub GetOptionsFromArray(@) {
  
      my ($argv, @optionlist) = @_;	# local copy of the option descriptions
      my $argend = '--';		# option list terminator
      my %opctl = ();		# table of option specs
      my $pkg = $caller || (caller)[0];	# current context
  				# Needed if linkage is omitted.
      my @ret = ();		# accum for non-options
      my %linkage;		# linkage
      my $userlinkage;		# user supplied HASH
      my $opt;			# current option
      my $prefix = $genprefix;	# current prefix
  
      $error = '';
  
      if ( $debug ) {
  	# Avoid some warnings if debugging.
  	local ($^W) = 0;
  	print STDERR
  	  ("Getopt::Long $Getopt::Long::VERSION ",
  	   "called from package \"$pkg\".",
  	   "\n  ",
  	   "argv: ",
  	   defined($argv)
  	   ? UNIVERSAL::isa( $argv, 'ARRAY' ) ? "(@$argv)" : $argv
  	   : "<undef>",
  	   "\n  ",
  	   "autoabbrev=$autoabbrev,".
  	   "bundling=$bundling,",
  	   "bundling_values=$bundling_values,",
  	   "getopt_compat=$getopt_compat,",
  	   "gnu_compat=$gnu_compat,",
  	   "order=$order,",
  	   "\n  ",
  	   "ignorecase=$ignorecase,",
  	   "requested_version=$requested_version,",
  	   "passthrough=$passthrough,",
  	   "genprefix=\"$genprefix\",",
  	   "longprefix=\"$longprefix\".",
  	   "\n");
      }
  
      # Check for ref HASH as first argument.
      # First argument may be an object. It's OK to use this as long
      # as it is really a hash underneath.
      $userlinkage = undef;
      if ( @optionlist && ref($optionlist[0]) and
  	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
  	$userlinkage = shift (@optionlist);
  	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
      }
  
      # See if the first element of the optionlist contains option
      # starter characters.
      # Be careful not to interpret '<>' as option starters.
      if ( @optionlist && $optionlist[0] =~ /^\W+$/
  	 && !($optionlist[0] eq '<>'
  	      && @optionlist > 0
  	      && ref($optionlist[1])) ) {
  	$prefix = shift (@optionlist);
  	# Turn into regexp. Needs to be parenthesized!
  	$prefix =~ s/(\W)/\\$1/g;
  	$prefix = "([" . $prefix . "])";
  	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
      }
  
      # Verify correctness of optionlist.
      %opctl = ();
      while ( @optionlist ) {
  	my $opt = shift (@optionlist);
  
  	unless ( defined($opt) ) {
  	    $error .= "Undefined argument in option spec\n";
  	    next;
  	}
  
  	# Strip leading prefix so people can specify "--foo=i" if they like.
  	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  
  	if ( $opt eq '<>' ) {
  	    if ( (defined $userlinkage)
  		&& !(@optionlist > 0 && ref($optionlist[0]))
  		&& (exists $userlinkage->{$opt})
  		&& ref($userlinkage->{$opt}) ) {
  		unshift (@optionlist, $userlinkage->{$opt});
  	    }
  	    unless ( @optionlist > 0
  		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
  		$error .= "Option spec <> requires a reference to a subroutine\n";
  		# Kill the linkage (to avoid another error).
  		shift (@optionlist)
  		  if @optionlist && ref($optionlist[0]);
  		next;
  	    }
  	    $linkage{'<>'} = shift (@optionlist);
  	    next;
  	}
  
  	# Parse option spec.
  	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  	unless ( defined $name ) {
  	    # Failed. $orig contains the error message. Sorry for the abuse.
  	    $error .= $orig;
  	    # Kill the linkage (to avoid another error).
  	    shift (@optionlist)
  	      if @optionlist && ref($optionlist[0]);
  	    next;
  	}
  
  	# If no linkage is supplied in the @optionlist, copy it from
  	# the userlinkage if available.
  	if ( defined $userlinkage ) {
  	    unless ( @optionlist > 0 && ref($optionlist[0]) ) {
  		if ( exists $userlinkage->{$orig} &&
  		     ref($userlinkage->{$orig}) ) {
  		    print STDERR ("=> found userlinkage for \"$orig\": ",
  				  "$userlinkage->{$orig}\n")
  			if $debug;
  		    unshift (@optionlist, $userlinkage->{$orig});
  		}
  		else {
  		    # Do nothing. Being undefined will be handled later.
  		    next;
  		}
  	    }
  	}
  
  	# Copy the linkage. If omitted, link to global variable.
  	if ( @optionlist > 0 && ref($optionlist[0]) ) {
  	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  		if $debug;
  	    my $rl = ref($linkage{$orig} = shift (@optionlist));
  
  	    if ( $rl eq "ARRAY" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  	    }
  	    elsif ( $rl eq "HASH" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
  	    }
  	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
  #		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  #		    my $t = $linkage{$orig};
  #		    $$t = $linkage{$orig} = [];
  #		}
  #		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  #		}
  #		else {
  		    # Ok.
  #		}
  	    }
  	    elsif ( $rl eq "CODE" ) {
  		# Ok.
  	    }
  	    else {
  		$error .= "Invalid option linkage for \"$opt\"\n";
  	    }
  	}
  	else {
  	    # Link to global $opt_XXX variable.
  	    # Make sure a valid perl identifier results.
  	    my $ov = $orig;
  	    $ov =~ s/\W/_/g;
  	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  		print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;");
  	    }
  	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
  	    }
  	    else {
  		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
  	    }
  	}
  
  	if ( $opctl{$name}[CTL_TYPE] eq 'I'
  	     && ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
  		  || $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
  	   ) {
  	    $error .= "Invalid option linkage for \"$opt\"\n";
  	}
  
      }
  
      $error .= "GetOptionsFromArray: 1st parameter is not an array reference\n"
        unless $argv && UNIVERSAL::isa( $argv, 'ARRAY' );
  
      # Bail out if errors found.
      die ($error) if $error;
      $error = 0;
  
      # Supply --version and --help support, if needed and allowed.
      if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{version}) ) {
  	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
  	    $linkage{version} = \&VersionMessage;
  	}
  	$auto_version = 1;
      }
      if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
  	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
  	    $linkage{help} = \&HelpMessage;
  	}
  	$auto_help = 1;
      }
  
      # Show the options tables if debugging.
      if ( $debug ) {
  	my ($arrow, $k, $v);
  	$arrow = "=> ";
  	while ( ($k,$v) = each(%opctl) ) {
  	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
  	    $arrow = "   ";
  	}
      }
  
      # Process argument list
      my $goon = 1;
      while ( $goon && @$argv > 0 ) {
  
  	# Get next argument.
  	$opt = shift (@$argv);
  	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  
  	# Double dash is option list terminator.
  	if ( defined($opt) && $opt eq $argend ) {
  	  push (@ret, $argend) if $passthrough;
  	  last;
  	}
  
  	# Look it up.
  	my $tryopt = $opt;
  	my $found;		# success status
  	my $key;		# key (if hash type)
  	my $arg;		# option argument
  	my $ctl;		# the opctl entry
  
  	($found, $opt, $ctl, $arg, $key) =
  	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);
  
  	if ( $found ) {
  
  	    # FindOption undefines $opt in case of errors.
  	    next unless defined $opt;
  
  	    my $argcnt = 0;
  	    while ( defined $arg ) {
  
  		# Get the canonical name.
  		print STDERR ("=> cname for \"$opt\" is ") if $debug;
  		$opt = $ctl->[CTL_CNAME];
  		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  
  		if ( defined $linkage{$opt} ) {
  		    print STDERR ("=> ref(\$L{$opt}) -> ",
  				  ref($linkage{$opt}), "\n") if $debug;
  
  		    if ( ref($linkage{$opt}) eq 'SCALAR'
  			 || ref($linkage{$opt}) eq 'REF' ) {
  			if ( $ctl->[CTL_TYPE] eq '+' ) {
  			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
  			      if $debug;
  			    if ( defined ${$linkage{$opt}} ) {
  			        ${$linkage{$opt}} += $arg;
  			    }
  		            else {
  			        ${$linkage{$opt}} = $arg;
  			    }
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to ARRAY\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = [];
  			    print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			      if $debug;
  			    push (@{$linkage{$opt}}, $arg);
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to HASH\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = {};
  			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			      if $debug;
  			    $linkage{$opt}->{$key} = $arg;
  			}
  			else {
  			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  			      if $debug;
  			    ${$linkage{$opt}} = $arg;
  		        }
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
  			print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			    if $debug;
  			push (@{$linkage{$opt}}, $arg);
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
  			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$linkage{$opt}->{$key} = $arg;
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
  			print STDERR ("=> &L{$opt}(\"$opt\"",
  				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
  				      ", \"$arg\")\n")
  			    if $debug;
  			my $eval_error = do {
  			    local $@;
  			    local $SIG{__DIE__}  = 'DEFAULT';
  			    eval {
  				&{$linkage{$opt}}
  				  (Getopt::Long::CallBack->new
  				   (name    => $opt,
  				    ctl     => $ctl,
  				    opctl   => \%opctl,
  				    linkage => \%linkage,
  				    prefix  => $prefix,
  				   ),
  				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
  				   $arg);
  			    };
  			    $@;
  			};
  			print STDERR ("=> die($eval_error)\n")
  			  if $debug && $eval_error ne '';
  			if ( $eval_error =~ /^!/ ) {
  			    if ( $eval_error =~ /^!FINISH\b/ ) {
  				$goon = 0;
  			    }
  			}
  			elsif ( $eval_error ne '' ) {
  			    warn ($eval_error);
  			    $error++;
  			}
  		    }
  		    else {
  			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
  				      "\" in linkage\n");
  			die("Getopt::Long -- internal error!\n");
  		    }
  		}
  		# No entry in linkage means entry in userlinkage.
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")
  			    if $debug;
  			push (@{$userlinkage->{$opt}}, $arg);
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
  			    if $debug;
  			$userlinkage->{$opt} = [$arg];
  		    }
  		}
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$userlinkage->{$opt}->{$key} = $arg;
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
  			    if $debug;
  			$userlinkage->{$opt} = {$key => $arg};
  		    }
  		}
  		else {
  		    if ( $ctl->[CTL_TYPE] eq '+' ) {
  			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
  			  if $debug;
  			if ( defined $userlinkage->{$opt} ) {
  			    $userlinkage->{$opt} += $arg;
  			}
  			else {
  			    $userlinkage->{$opt} = $arg;
  			}
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
  			$userlinkage->{$opt} = $arg;
  		    }
  		}
  
  		$argcnt++;
  		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  		undef($arg);
  
  		# Need more args?
  		if ( $argcnt < $ctl->[CTL_AMIN] ) {
  		    if ( @$argv ) {
  			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
  			    $arg = shift(@$argv);
  			    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  				$arg =~ tr/_//d;
  				$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  				  ? oct($arg)
  				  : 0+$arg
  			    }
  			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  			    next;
  			}
  			warn("Value \"$$argv[0]\" invalid for option $opt\n");
  			$error++;
  		    }
  		    else {
  			warn("Insufficient arguments for option $opt\n");
  			$error++;
  		    }
  		}
  
  		# Any more args?
  		if ( @$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
  		    $arg = shift(@$argv);
  		    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  			$arg =~ tr/_//d;
  			$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  			  ? oct($arg)
  			  : 0+$arg
  		    }
  		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  		    next;
  		}
  	    }
  	}
  
  	# Not an option. Save it if we $PERMUTE and don't have a <>.
  	elsif ( $order == $PERMUTE ) {
  	    # Try non-options call-back.
  	    my $cb;
  	    if ( defined ($cb = $linkage{'<>'}) ) {
  		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
  		  if $debug;
  		my $eval_error = do {
  		    local $@;
  		    local $SIG{__DIE__}  = 'DEFAULT';
  		    eval {
  			# The arg to <> cannot be the CallBack object
  			# since it may be passed to other modules that
  			# get confused (e.g., Archive::Tar). Well,
  			# it's not relevant for this callback anyway.
  			&$cb($tryopt);
  		    };
  		    $@;
  		};
  		print STDERR ("=> die($eval_error)\n")
  		  if $debug && $eval_error ne '';
  		if ( $eval_error =~ /^!/ ) {
  		    if ( $eval_error =~ /^!FINISH\b/ ) {
  			$goon = 0;
  		    }
  		}
  		elsif ( $eval_error ne '' ) {
  		    warn ($eval_error);
  		    $error++;
  		}
  	    }
  	    else {
  		print STDERR ("=> saving \"$tryopt\" ",
  			      "(not an option, may permute)\n") if $debug;
  		push (@ret, $tryopt);
  	    }
  	    next;
  	}
  
  	# ...otherwise, terminate.
  	else {
  	    # Push this one back and exit.
  	    unshift (@$argv, $tryopt);
  	    return ($error == 0);
  	}
  
      }
  
      # Finish.
      if ( @ret && $order == $PERMUTE ) {
  	#  Push back accumulated arguments
  	print STDERR ("=> restoring \"", join('" "', @ret), "\"\n")
  	    if $debug;
  	unshift (@$argv, @ret);
      }
  
      return ($error == 0);
  }
  
  # A readable representation of what's in an optbl.
  sub OptCtl ($) {
      my ($v) = @_;
      my @v = map { defined($_) ? ($_) : ("<undef>") } @$v;
      "[".
        join(",",
  	   "\"$v[CTL_TYPE]\"",
  	   "\"$v[CTL_CNAME]\"",
  	   "\"$v[CTL_DEFAULT]\"",
  	   ("\$","\@","\%","\&")[$v[CTL_DEST] || 0],
  	   $v[CTL_AMIN] || '',
  	   $v[CTL_AMAX] || '',
  #	   $v[CTL_RANGE] || '',
  #	   $v[CTL_REPEAT] || '',
  	  ). "]";
  }
  
  # Parse an option specification and fill the tables.
  sub ParseOptionSpec ($$) {
      my ($opt, $opctl) = @_;
  
      # Match option spec.
      if ( $opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		     # Aliases
  		     (?: \| (?: [^-|!+=:][^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x ) {
  	return (undef, "Error in option spec: \"$opt\"\n");
      }
  
      my ($names, $spec) = ($1, $2);
      $spec = '' unless defined $spec;
  
      # $orig keeps track of the primary name the user specified.
      # This name will be used for the internal or external linkage.
      # In other words, if the user specifies "FoO|BaR", it will
      # match any case combinations of 'foo' and 'bar', but if a global
      # variable needs to be set, it will be $opt_FoO in the exact case
      # as specified.
      my $orig;
  
      my @names;
      if ( defined $names ) {
  	@names =  split (/\|/, $names);
  	$orig = $names[0];
      }
      else {
  	@names = ('');
  	$orig = '';
      }
  
      # Construct the opctl entries.
      my $entry;
      if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
  	# Fields are hard-wired here.
  	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
      }
      elsif ( $spec =~ /^:(-?\d+|\+)([@%])?$/ ) {
  	my $def = $1;
  	my $dest = $2;
  	my $type = $def eq '+' ? 'I' : 'i';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,$def eq '+' ? undef : $def,
  		  $dest,0,1];
      }
      else {
  	my ($mand, $type, $dest) =
  	  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
  	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
  	  if $bundling && defined($4);
  	my ($mi, $cm, $ma) = ($5, $6, $7);
  	return (undef, "{0} is useless in option spec: \"$opt\"\n")
  	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
  
  	$type = 'i' if $type eq 'n';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Default minargs to 1/0 depending on mand status.
  	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
  	# Adjust mand status according to minargs.
  	$mand = $mi ? '=' : ':';
  	# Adjust maxargs.
  	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
  	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
  	  if defined($ma) && !$ma;
  	return (undef, "Max less than min in option spec: \"$opt\"\n")
  	  if defined($ma) && $ma < $mi;
  
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
      }
  
      # Process all names. First is canonical, the rest are aliases.
      my $dups = '';
      foreach ( @names ) {
  
  	$_ = lc ($_)
  	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
  
  	if ( exists $opctl->{$_} ) {
  	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
  	}
  
  	if ( $spec eq '!' ) {
  	    $opctl->{"no$_"} = $entry;
  	    $opctl->{"no-$_"} = $entry;
  	    $opctl->{$_} = [@$entry];
  	    $opctl->{$_}->[CTL_TYPE] = '';
  	}
  	else {
  	    $opctl->{$_} = $entry;
  	}
      }
  
      if ( $dups && $^W ) {
  	foreach ( split(/\n+/, $dups) ) {
  	    warn($_."\n");
  	}
      }
      ($names[0], $orig);
  }
  
  # Option lookup.
  sub FindOption ($$$$$) {
  
      # returns (1, $opt, $ctl, $arg, $key) if okay,
      # returns (1, undef) if option in error,
      # returns (0) otherwise.
  
      my ($argv, $prefix, $argend, $opt, $opctl) = @_;
  
      print STDERR ("=> find \"$opt\"\n") if $debug;
  
      return (0) unless defined($opt);
      return (0) unless $opt =~ /^($prefix)(.*)$/s;
      return (0) if $opt eq "-" && !defined $opctl->{''};
  
      $opt = substr( $opt, length($1) ); # retain taintedness
      my $starter = $1;
  
      print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
  
      my $optarg;			# value supplied with --opt=value
      my $rest;			# remainder from unbundling
  
      # If it is a long option, it may include the value.
      # With getopt_compat, only if not bundling.
      if ( ($starter=~/^$longprefix$/
  	  || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
  	 && (my $oppos = index($opt, '=', 1)) > 0) {
  	my $optorg = $opt;
  	$opt = substr($optorg, 0, $oppos);
  	$optarg = substr($optorg, $oppos + 1); # retain tainedness
  	print STDERR ("=> option \"", $opt,
  		      "\", optarg = \"$optarg\"\n") if $debug;
      }
  
      #### Look it up ###
  
      my $tryopt = $opt;		# option to try
  
      if ( ( $bundling || $bundling_values ) && $starter eq '-' ) {
  
  	# To try overrides, obey case ignore.
  	$tryopt = $ignorecase ? lc($opt) : $opt;
  
  	# If bundling == 2, long options can override bundles.
  	if ( $bundling == 2 && length($tryopt) > 1
  	     && defined ($opctl->{$tryopt}) ) {
  	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
  	      if $debug;
  	}
  
  	# If bundling_values, option may be followed by the value.
  	elsif ( $bundling_values ) {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    # Whatever remains may not be considered an option.
  	    $optarg = $rest eq '' ? undef : $rest;
  	    $rest = undef;
  	}
  
  	# Split off a single letter and leave the rest for
  	# further processing.
  	else {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    $rest = undef unless $rest ne '';
  	}
      }
  
      # Try auto-abbreviation.
      elsif ( $autoabbrev && $opt ne "" ) {
  	# Sort the possible long option names.
  	my @names = sort(keys (%$opctl));
  	# Downcase if allowed.
  	$opt = lc ($opt) if $ignorecase;
  	$tryopt = $opt;
  	# Turn option name into pattern.
  	my $pat = quotemeta ($opt);
  	# Look up in option names.
  	my @hits = grep (/^$pat/, @names);
  	print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
  		      "out of ", scalar(@names), "\n") if $debug;
  
  	# Check for ambiguous results.
  	unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
  	    # See if all matches are for the same option.
  	    my %hit;
  	    foreach ( @hits ) {
  		my $hit = $opctl->{$_}->[CTL_CNAME]
  		  if defined $opctl->{$_}->[CTL_CNAME];
  		$hit = "no" . $hit if $opctl->{$_}->[CTL_TYPE] eq '!';
  		$hit{$hit} = 1;
  	    }
  	    # Remove auto-supplied options (version, help).
  	    if ( keys(%hit) == 2 ) {
  		if ( $auto_version && exists($hit{version}) ) {
  		    delete $hit{version};
  		}
  		elsif ( $auto_help && exists($hit{help}) ) {
  		    delete $hit{help};
  		}
  	    }
  	    # Now see if it really is ambiguous.
  	    unless ( keys(%hit) == 1 ) {
  		return (0) if $passthrough;
  		warn ("Option ", $opt, " is ambiguous (",
  		      join(", ", @hits), ")\n");
  		$error++;
  		return (1, undef);
  	    }
  	    @hits = keys(%hit);
  	}
  
  	# Complete the option name, if appropriate.
  	if ( @hits == 1 && $hits[0] ne $opt ) {
  	    $tryopt = $hits[0];
  	    $tryopt = lc ($tryopt)
  	      if $ignorecase > (($bundling && length($tryopt) == 1) ? 1 : 0);
  	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
  		if $debug;
  	}
      }
  
      # Map to all lowercase if ignoring case.
      elsif ( $ignorecase ) {
  	$tryopt = lc ($opt);
      }
  
      # Check validity by fetching the info.
      my $ctl = $opctl->{$tryopt};
      unless  ( defined $ctl ) {
  	return (0) if $passthrough;
  	# Pretend one char when bundling.
  	if ( $bundling == 1 && length($starter) == 1 ) {
  	    $opt = substr($opt,0,1);
              unshift (@$argv, $starter.$rest) if defined $rest;
  	}
  	if ( $opt eq "" ) {
  	    warn ("Missing option after ", $starter, "\n");
  	}
  	else {
  	    warn ("Unknown option: ", $opt, "\n");
  	}
  	$error++;
  	return (1, undef);
      }
      # Apparently valid.
      $opt = $tryopt;
      print STDERR ("=> found ", OptCtl($ctl),
  		  " for \"", $opt, "\"\n") if $debug;
  
      #### Determine argument status ####
  
      # If it is an option w/o argument, we're almost finished with it.
      my $type = $ctl->[CTL_TYPE];
      my $arg;
  
      if ( $type eq '' || $type eq '!' || $type eq '+' ) {
  	if ( defined $optarg ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " does not take an argument\n");
  	    $error++;
  	    undef $opt;
  	    undef $optarg if $bundling_values;
  	}
  	elsif ( $type eq '' || $type eq '+' ) {
  	    # Supply explicit value.
  	    $arg = 1;
  	}
  	else {
  	    $opt =~ s/^no-?//i;	# strip NO prefix
  	    $arg = 0;		# supply explicit value
  	}
  	unshift (@$argv, $starter.$rest) if defined $rest;
  	return (1, $opt, $ctl, $arg);
      }
  
      # Get mandatory status and type info.
      my $mand = $ctl->[CTL_AMIN];
  
      # Check if there is an option argument available.
      if ( $gnu_compat ) {
  	my $optargtype = 0; # none, 1 = empty, 2 = nonempty, 3 = aux
  	if ( defined($optarg) ) {
  	    $optargtype = (length($optarg) == 0) ? 1 : 2;
  	}
  	elsif ( defined $rest || @$argv > 0 ) {
  	    # GNU getopt_long() does not accept the (optional)
  	    # argument to be passed to the option without = sign.
  	    # We do, since not doing so breaks existing scripts.
  	    $optargtype = 3;
  	}
  	if(($optargtype == 0) && !$mand) {
  	    my $val
  	      = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT]
  	      : $type eq 's'                 ? ''
  	      :                                0;
  	    return (1, $opt, $ctl, $val);
  	}
  	return (1, $opt, $ctl, $type eq 's' ? '' : 0)
  	  if $optargtype == 1;  # --foo=  -> return nothing
      }
  
      # Check if there is an option argument available.
      if ( defined $optarg
  	 ? ($optarg eq '')
  	 : !(defined $rest || @$argv > 0) ) {
  	# Complain if this option needs an argument.
  #	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
  	if ( $mand ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " requires an argument\n");
  	    $error++;
  	    return (1, undef);
  	}
  	if ( $type eq 'I' ) {
  	    # Fake incremental type.
  	    my @c = @$ctl;
  	    $c[CTL_TYPE] = '+';
  	    return (1, $opt, \@c, 1);
  	}
  	return (1, $opt, $ctl,
  		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  		$type eq 's' ? '' : 0);
      }
  
      # Get (possibly optional) argument.
      $arg = (defined $rest ? $rest
  	    : (defined $optarg ? $optarg : shift (@$argv)));
  
      # Get key if this is a "name=value" pair for a hash option.
      my $key;
      if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
  	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
  	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  	     ($mand ? undef : ($type eq 's' ? "" : 1)));
  	if (! defined $arg) {
  	    warn ("Option $opt, key \"$key\", requires a value\n");
  	    $error++;
  	    # Push back.
  	    unshift (@$argv, $starter.$rest) if defined $rest;
  	    return (1, undef);
  	}
      }
  
      #### Check if the argument is valid for this option ####
  
      my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1, $opt, $ctl, $arg, $key) if $mand;
  
  	# Same for optional string as a hash value
  	return (1, $opt, $ctl, $arg, $key)
  	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  
  	# An optional string takes almost anything.
  	return (1, $opt, $ctl, $arg, $key)
  	  if defined $optarg || defined $rest;
  	return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??
  
  	# Check for option or option list terminator.
  	if ($arg eq $argend ||
  	    $arg =~ /^$prefix.+/) {
  	    # Push back.
  	    unshift (@$argv, $arg);
  	    # Supply empty value.
  	    $arg = '';
  	}
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  
  	if ( $bundling && defined $rest
  	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/si ) {
  	    $arg =~ tr/_//d;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (",
  		      $type eq 'o' ? "extended " : '',
  		      "number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		if ( $type eq 'I' ) {
  		    # Fake incremental type.
  		    my @c = @$ctl;
  		    $c[CTL_TYPE] = '+';
  		    return (1, $opt, \@c, 1);
  		}
  		# Supply default value.
  		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
  	    }
  	}
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	if ( $bundling && defined $rest &&
  	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
  	    $arg =~ tr/_//d;
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/ ) {
  	    $arg =~ tr/_//d;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (real number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		# Supply default value.
  		$arg = 0.0;
  	    }
  	}
      }
      else {
  	die("Getopt::Long internal error (Can't happen)\n");
      }
      return (1, $opt, $ctl, $arg, $key);
  }
  
  sub ValidValue ($$$$$) {
      my ($ctl, $arg, $mand, $argend, $prefix) = @_;
  
      if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  	return 0 unless $arg =~ /[^=]+=(.*)/;
  	$arg = $1;
      }
  
      my $type = $ctl->[CTL_TYPE];
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1) if $mand;
  
  	return (1) if $arg eq "-";
  
  	# Check for option or option list terminator.
  	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
  	return 1;
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  	return $arg =~ /^$o_valid$/si;
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	return $arg =~ /^$o_valid$/;
      }
      die("ValidValue: Cannot happen\n");
  }
  
  # Getopt::Long Configuration.
  sub Configure (@) {
      my (@options) = @_;
  
      my $prevconfig =
        [ $error, $debug, $major_version, $minor_version, $caller,
  	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	$longprefix, $bundling_values ];
  
      if ( ref($options[0]) eq 'ARRAY' ) {
  	( $error, $debug, $major_version, $minor_version, $caller,
  	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	  $longprefix, $bundling_values ) = @{shift(@options)};
      }
  
      my $opt;
      foreach $opt ( @options ) {
  	my $try = lc ($opt);
  	my $action = 1;
  	if ( $try =~ /^no_?(.*)$/s ) {
  	    $action = 0;
  	    $try = $+;
  	}
  	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
  	    ConfigDefaults ();
  	}
  	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
  	    local $ENV{POSIXLY_CORRECT};
  	    $ENV{POSIXLY_CORRECT} = 1 if $action;
  	    ConfigDefaults ();
  	}
  	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
  	    $autoabbrev = $action;
  	}
  	elsif ( $try eq 'getopt_compat' ) {
  	    $getopt_compat = $action;
              $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
  	}
  	elsif ( $try eq 'gnu_getopt' ) {
  	    if ( $action ) {
  		$gnu_compat = 1;
  		$bundling = 1;
  		$getopt_compat = 0;
                  $genprefix = "(--|-)";
  		$order = $PERMUTE;
  		$bundling_values = 0;
  	    }
  	}
  	elsif ( $try eq 'gnu_compat' ) {
  	    $gnu_compat = $action;
  	    $bundling = 0;
  	    $bundling_values = 1;
  	}
  	elsif ( $try =~ /^(auto_?)?version$/ ) {
  	    $auto_version = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?help$/ ) {
  	    $auto_help = $action;
  	}
  	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
  	    $ignorecase = $action;
  	}
  	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
  	    $ignorecase = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'bundling' ) {
  	    $bundling = $action;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_override' ) {
  	    $bundling = $action ? 2 : 0;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_values' ) {
  	    $bundling_values = $action;
  	    $bundling = 0 if $action;
  	}
  	elsif ( $try eq 'require_order' ) {
  	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
  	}
  	elsif ( $try eq 'permute' ) {
  	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
  	}
  	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
  	    $passthrough = $action;
  	}
  	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Turn into regexp. Needs to be parenthesized!
  	    $genprefix = "(" . quotemeta($genprefix) . ")";
  	    eval { '' =~ /$genprefix/; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Parenthesize if needed.
  	    $genprefix = "(" . $genprefix . ")"
  	      unless $genprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$genprefix"; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
  	    $longprefix = $1;
  	    # Parenthesize if needed.
  	    $longprefix = "(" . $longprefix . ")"
  	      unless $longprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$longprefix"; };
  	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n") if $@;
  	}
  	elsif ( $try eq 'debug' ) {
  	    $debug = $action;
  	}
  	else {
  	    die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")
  	}
      }
      $prevconfig;
  }
  
  # Deprecated name.
  sub config (@) {
      Configure (@_);
  }
  
  # Issue a standard message for --version.
  #
  # The arguments are mostly the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub VersionMessage(@) {
      # Massage args.
      my $pa = setup_pa_args("version", @_);
  
      my $v = $main::VERSION;
      my $fh = $pa->{-output} ||
        ( ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR );
  
      print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
  	       $0, defined $v ? " version $v" : (),
  	       "\n",
  	       "(", __PACKAGE__, "::", "GetOptions",
  	       " version ",
  	       defined($Getopt::Long::VERSION_STRING)
  	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
  	       " Perl version ",
  	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
  	       ")\n");
      exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
  }
  
  # Issue a standard message for --help.
  #
  # The arguments are the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub HelpMessage(@) {
      eval {
  	require Pod::Usage;
  	import Pod::Usage;
  	1;
      } || die("Cannot provide help: cannot load Pod::Usage\n");
  
      # Note that pod2usage will issue a warning if -exitval => NOEXIT.
      pod2usage(setup_pa_args("help", @_));
  
  }
  
  # Helper routine to set up a normalized hash ref to be used as
  # argument to pod2usage.
  sub setup_pa_args($@) {
      my $tag = shift;		# who's calling
  
      # If called by direct binding to an option, it will get the option
      # name and value as arguments. Remove these, if so.
      @_ = () if @_ == 2 && $_[0] eq $tag;
  
      my $pa;
      if ( @_ > 1 ) {
  	$pa = { @_ };
      }
      else {
  	$pa = shift || {};
      }
  
      # At this point, $pa can be a number (exit value), string
      # (message) or hash with options.
  
      if ( UNIVERSAL::isa($pa, 'HASH') ) {
  	# Get rid of -msg vs. -message ambiguity.
  	$pa->{-message} = $pa->{-msg};
  	delete($pa->{-msg});
      }
      elsif ( $pa =~ /^-?\d+$/ ) {
  	$pa = { -exitval => $pa };
      }
      else {
  	$pa = { -message => $pa };
      }
  
      # These are _our_ defaults.
      $pa->{-verbose} = 0 unless exists($pa->{-verbose});
      $pa->{-exitval} = 0 unless exists($pa->{-exitval});
      $pa;
  }
  
  # Sneak way to know what version the user requested.
  sub VERSION {
      $requested_version = $_[1];
      shift->SUPER::VERSION(@_);
  }
  
  package Getopt::Long::CallBack;
  
  sub new {
      my ($pkg, %atts) = @_;
      bless { %atts }, $pkg;
  }
  
  sub name {
      my $self = shift;
      ''.$self->{name};
  }
  
  use overload
    # Treat this object as an ordinary string for legacy API.
    '""'	   => \&name,
    fallback => 1;
  
  1;
  
  ################ Documentation ################
  
  =head1 NAME
  
  Getopt::Long - Extended processing of command line options
  
  =head1 SYNOPSIS
  
    use Getopt::Long;
    my $data   = "file.dat";
    my $length = 24;
    my $verbose;
    GetOptions ("length=i" => \$length,    # numeric
                "file=s"   => \$data,      # string
                "verbose"  => \$verbose)   # flag
    or die("Error in command line arguments\n");
  
  =head1 DESCRIPTION
  
  The Getopt::Long module implements an extended getopt function called
  GetOptions(). It parses the command line from C<@ARGV>, recognizing
  and removing specified options and their possible values.
  
  This function adheres to the POSIX syntax for command
  line options, with GNU extensions. In general, this means that options
  have long names instead of single letters, and are introduced with a
  double dash "--". Support for bundling of command line options, as was
  the case with the more traditional single-letter approach, is provided
  but not enabled by default.
  
  =head1 Command Line Options, an Introduction
  
  Command line operated programs traditionally take their arguments from
  the command line, for example filenames or other information that the
  program needs to know. Besides arguments, these programs often take
  command line I<options> as well. Options are not necessary for the
  program to work, hence the name 'option', but are used to modify its
  default behaviour. For example, a program could do its job quietly,
  but with a suitable option it could provide verbose information about
  what it did.
  
  Command line options come in several flavours. Historically, they are
  preceded by a single dash C<->, and consist of a single letter.
  
      -l -a -c
  
  Usually, these single-character options can be bundled:
  
      -lac
  
  Options can have values, the value is placed after the option
  character. Sometimes with whitespace in between, sometimes not:
  
      -s 24 -s24
  
  Due to the very cryptic nature of these options, another style was
  developed that used long names. So instead of a cryptic C<-l> one
  could use the more descriptive C<--long>. To distinguish between a
  bundle of single-character options and a long one, two dashes are used
  to precede the option name. Early implementations of long options used
  a plus C<+> instead. Also, option values could be specified either
  like
  
      --size=24
  
  or
  
      --size 24
  
  The C<+> form is now obsolete and strongly deprecated.
  
  =head1 Getting Started with Getopt::Long
  
  Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
  first Perl module that provided support for handling the new style of
  command line options, in particular long option names, hence the Perl5
  name Getopt::Long. This module also supports single-character options
  and bundling.
  
  To use Getopt::Long from a Perl program, you must include the
  following line in your Perl program:
  
      use Getopt::Long;
  
  This will load the core of the Getopt::Long module and prepare your
  program for using it. Most of the actual Getopt::Long code is not
  loaded until you really call one of its functions.
  
  In the default configuration, options names may be abbreviated to
  uniqueness, case does not matter, and a single dash is sufficient,
  even for long option names. Also, options may be placed between
  non-option arguments. See L<Configuring Getopt::Long> for more
  details on how to configure Getopt::Long.
  
  =head2 Simple options
  
  The most simple options are the ones that take no values. Their mere
  presence on the command line enables the option. Popular examples are:
  
      --all --verbose --quiet --debug
  
  Handling simple options is straightforward:
  
      my $verbose = '';	# option variable with default value (false)
      my $all = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose, 'all' => \$all);
  
  The call to GetOptions() parses the command line arguments that are
  present in C<@ARGV> and sets the option variable to the value C<1> if
  the option did occur on the command line. Otherwise, the option
  variable is not touched. Setting the option value to true is often
  called I<enabling> the option.
  
  The option name as specified to the GetOptions() function is called
  the option I<specification>. Later we'll see that this specification
  can contain more than just the option name. The reference to the
  variable is called the option I<destination>.
  
  GetOptions() will return a true value if the command line could be
  processed successfully. Otherwise, it will write error messages using
  die() and warn(), and return a false result.
  
  =head2 A little bit less simple options
  
  Getopt::Long supports two useful variants of simple options:
  I<negatable> options and I<incremental> options.
  
  A negatable option is specified with an exclamation mark C<!> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose!' => \$verbose);
  
  Now, using C<--verbose> on the command line will enable C<$verbose>,
  as expected. But it is also allowed to use C<--noverbose>, which will
  disable C<$verbose> by setting its value to C<0>. Using a suitable
  default value, the program can find out whether C<$verbose> is false
  by default, or disabled by using C<--noverbose>.
  
  An incremental option is specified with a plus C<+> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose+' => \$verbose);
  
  Using C<--verbose> on the command line will increment the value of
  C<$verbose>. This way the program can keep track of how many times the
  option occurred on the command line. For example, each occurrence of
  C<--verbose> could increase the verbosity level of the program.
  
  =head2 Mixing command line option with other arguments
  
  Usually programs take command line options as well as other arguments,
  for example, file names. It is good practice to always specify the
  options first, and the other arguments last. Getopt::Long will,
  however, allow the options and arguments to be mixed and 'filter out'
  all the options before passing the rest of the arguments to the
  program. To stop Getopt::Long from processing further arguments,
  insert a double dash C<--> on the command line:
  
      --size 24 -- --all
  
  In this example, C<--all> will I<not> be treated as an option, but
  passed to the program unharmed, in C<@ARGV>.
  
  =head2 Options with values
  
  For options that take values it must be specified whether the option
  value is required or not, and what kind of value the option expects.
  
  Three kinds of values are supported: integer numbers, floating point
  numbers, and strings.
  
  If the option value is required, Getopt::Long will take the
  command line argument that follows the option and assign this to the
  option variable. If, however, the option value is specified as
  optional, this will only be done if that value does not look like a
  valid command line option itself.
  
      my $tag = '';	# option variable with default value
      GetOptions ('tag=s' => \$tag);
  
  In the option specification, the option name is followed by an equals
  sign C<=> and the letter C<s>. The equals sign indicates that this
  option requires a value. The letter C<s> indicates that this value is
  an arbitrary string. Other possible value types are C<i> for integer
  values, and C<f> for floating point values. Using a colon C<:> instead
  of the equals sign indicates that the option value is optional. In
  this case, if no suitable value is supplied, string valued options get
  an empty string C<''> assigned, while numeric options are set to C<0>.
  
  =head2 Options with multiple values
  
  Options sometimes take several values. For example, a program could
  use multiple directories to search for library files:
  
      --library lib/stdlib --library lib/extlib
  
  To accomplish this behaviour, simply specify an array reference as the
  destination for the option:
  
      GetOptions ("library=s" => \@libfiles);
  
  Alternatively, you can specify that the option can have multiple
  values by adding a "@", and pass a reference to a scalar as the
  destination:
  
      GetOptions ("library=s@" => \$libfiles);
  
  Used with the example above, C<@libfiles> c.q. C<@$libfiles> would
  contain two strings upon completion: C<"lib/stdlib"> and
  C<"lib/extlib">, in that order. It is also possible to specify that
  only integer or floating point numbers are acceptable values.
  
  Often it is useful to allow comma-separated lists of values as well as
  multiple occurrences of the options. This is easy using Perl's split()
  and join() operators:
  
      GetOptions ("library=s" => \@libfiles);
      @libfiles = split(/,/,join(',',@libfiles));
  
  Of course, it is important to choose the right separator string for
  each purpose.
  
  Warning: What follows is an experimental feature.
  
  Options can take multiple values at once, for example
  
      --coordinates 52.2 16.4 --rgbcolor 255 255 149
  
  This can be accomplished by adding a repeat specifier to the option
  specification. Repeat specifiers are very similar to the C<{...}>
  repeat specifiers that can be used with regular expression patterns.
  For example, the above command line would be handled as follows:
  
      GetOptions('coordinates=f{2}' => \@coor, 'rgbcolor=i{3}' => \@color);
  
  The destination for the option must be an array or array reference.
  
  It is also possible to specify the minimal and maximal number of
  arguments an option takes. C<foo=s{2,4}> indicates an option that
  takes at least two and at most 4 arguments. C<foo=s{1,}> indicates one
  or more values; C<foo:s{,}> indicates zero or more option values.
  
  =head2 Options with hash values
  
  If the option destination is a reference to a hash, the option will
  take, as value, strings of the form I<key>C<=>I<value>. The value will
  be stored with the specified key in the hash.
  
      GetOptions ("define=s" => \%defines);
  
  Alternatively you can use:
  
      GetOptions ("define=s%" => \$defines);
  
  When used with command line options:
  
      --define os=linux --define vendor=redhat
  
  the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
  with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
  also possible to specify that only integer or floating point numbers
  are acceptable values. The keys are always taken to be strings.
  
  =head2 User-defined subroutines to handle options
  
  Ultimate control over what should be done when (actually: each time)
  an option is encountered on the command line can be achieved by
  designating a reference to a subroutine (or an anonymous subroutine)
  as the option destination. When GetOptions() encounters the option, it
  will call the subroutine with two or three arguments. The first
  argument is the name of the option. (Actually, it is an object that
  stringifies to the name of the option.) For a scalar or array destination,
  the second argument is the value to be stored. For a hash destination,
  the second argument is the key to the hash, and the third argument
  the value to be stored. It is up to the subroutine to store the value,
  or do whatever it thinks is appropriate.
  
  A trivial application of this mechanism is to implement options that
  are related to each other. For example:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose,
  	        'quiet'   => sub { $verbose = 0 });
  
  Here C<--verbose> and C<--quiet> control the same variable
  C<$verbose>, but with opposite values.
  
  If the subroutine needs to signal an error, it should call die() with
  the desired error message as its argument. GetOptions() will catch the
  die(), issue the error message, and record that an error result must
  be returned upon completion.
  
  If the text of the error message starts with an exclamation mark C<!>
  it is interpreted specially by GetOptions(). There is currently one
  special command implemented: C<die("!FINISH")> will cause GetOptions()
  to stop processing options, as if it encountered a double dash C<-->.
  
  In version 2.37 the first argument to the callback function was
  changed from string to object. This was done to make room for
  extensions and more detailed control. The object stringifies to the
  option name so this change should not introduce compatibility
  problems.
  
  Here is an example of how to access the option name and value from within
  a subroutine:
  
      GetOptions ('opt=i' => \&handler);
      sub handler {
          my ($opt_name, $opt_value) = @_;
          print("Option name is $opt_name and value is $opt_value\n");
      }
  
  =head2 Options with multiple names
  
  Often it is user friendly to supply alternate mnemonic names for
  options. For example C<--height> could be an alternate name for
  C<--length>. Alternate names can be included in the option
  specification, separated by vertical bar C<|> characters. To implement
  the above example:
  
      GetOptions ('length|height=f' => \$length);
  
  The first name is called the I<primary> name, the other names are
  called I<aliases>. When using a hash to store options, the key will
  always be the primary name.
  
  Multiple alternate names are possible.
  
  =head2 Case and abbreviations
  
  Without additional configuration, GetOptions() will ignore the case of
  option names, and allow the options to be abbreviated to uniqueness.
  
      GetOptions ('length|height=f' => \$length, "head" => \$head);
  
  This call will allow C<--l> and C<--L> for the length option, but
  requires a least C<--hea> and C<--hei> for the head and height options.
  
  =head2 Summary of Option Specifications
  
  Each option specifier consists of two parts: the name specification
  and the argument specification.
  
  The name specification contains the name of the option, optionally
  followed by a list of alternative names separated by vertical bar
  characters.
  
      length	      option name is "length"
      length|size|l     name is "length", aliases are "size" and "l"
  
  The argument specification is optional. If omitted, the option is
  considered boolean, a value of 1 will be assigned when the option is
  used on the command line.
  
  The argument specification can be
  
  =over 4
  
  =item !
  
  The option does not take an argument and may be negated by prefixing
  it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
  1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
  0 will be assigned). If the option has aliases, this applies to the
  aliases as well.
  
  Using negation on a single letter option when bundling is in effect is
  pointless and will result in a warning.
  
  =item +
  
  The option does not take an argument and will be incremented by 1
  every time it appears on the command line. E.g. C<"more+">, when used
  with C<--more --more --more>, will increment the value three times,
  resulting in a value of 3 (provided it was 0 or undefined at first).
  
  The C<+> specifier is ignored if the option destination is not a scalar.
  
  =item = I<type> [ I<desttype> ] [ I<repeat> ]
  
  The option requires an argument of the given type. Supported types
  are:
  
  =over 4
  
  =item s
  
  String. An arbitrary sequence of characters. It is valid for the
  argument to start with C<-> or C<-->.
  
  =item i
  
  Integer. An optional leading plus or minus sign, followed by a
  sequence of digits.
  
  =item o
  
  Extended integer, Perl style. This can be either an optional leading
  plus or minus sign, followed by a sequence of digits, or an octal
  string (a zero, optionally followed by '0', '1', .. '7'), or a
  hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
  insensitive), or a binary string (C<0b> followed by a series of '0'
  and '1').
  
  =item f
  
  Real number. For example C<3.14>, C<-6.23E24> and so on.
  
  =back
  
  The I<desttype> can be C<@> or C<%> to specify that the option is
  list or a hash valued. This is only needed when the destination for
  the option value is not otherwise specified. It should be omitted when
  not needed.
  
  The I<repeat> specifies the number of values this option takes per
  occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.
  
  I<min> denotes the minimal number of arguments. It defaults to 1 for
  options with C<=> and to 0 for options with C<:>, see below. Note that
  I<min> overrules the C<=> / C<:> semantics.
  
  I<max> denotes the maximum number of arguments. It must be at least
  I<min>. If I<max> is omitted, I<but the comma is not>, there is no
  upper bound to the number of argument values taken.
  
  =item : I<type> [ I<desttype> ]
  
  Like C<=>, but designates the argument as optional.
  If omitted, an empty string will be assigned to string values options,
  and the value zero to numeric options.
  
  Note that if a string argument starts with C<-> or C<-->, it will be
  considered an option on itself.
  
  =item : I<number> [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the I<number> will be assigned.
  
  =item : + [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the current value for the
  option will be incremented.
  
  =back
  
  =head1 Advanced Possibilities
  
  =head2 Object oriented interface
  
  Getopt::Long can be used in an object oriented way as well:
  
      use Getopt::Long;
      $p = Getopt::Long::Parser->new;
      $p->configure(...configuration options...);
      if ($p->getoptions(...options descriptions...)) ...
      if ($p->getoptionsfromarray( \@array, ...options descriptions...)) ...
  
  Configuration options can be passed to the constructor:
  
      $p = new Getopt::Long::Parser
               config => [...configuration options...];
  
  =head2 Thread Safety
  
  Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
  I<not> thread safe when using the older (experimental and now
  obsolete) threads implementation that was added to Perl 5.005.
  
  =head2 Documentation and help texts
  
  Getopt::Long encourages the use of Pod::Usage to produce help
  messages. For example:
  
      use Getopt::Long;
      use Pod::Usage;
  
      my $man = 0;
      my $help = 0;
  
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-exitval => 0, -verbose => 2) if $man;
  
      __END__
  
      =head1 NAME
  
      sample - Using Getopt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 8
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  See L<Pod::Usage> for details.
  
  =head2 Parsing options from an arbitrary array
  
  By default, GetOptions parses the options that are present in the
  global array C<@ARGV>. A special entry C<GetOptionsFromArray> can be
  used to parse options from an arbitrary array.
  
      use Getopt::Long qw(GetOptionsFromArray);
      $ret = GetOptionsFromArray(\@myopts, ...);
  
  When used like this, options and their possible values are removed
  from C<@myopts>, the global C<@ARGV> is not touched at all.
  
  The following two calls behave identically:
  
      $ret = GetOptions( ... );
      $ret = GetOptionsFromArray(\@ARGV, ... );
  
  This also means that a first argument hash reference now becomes the
  second argument:
  
      $ret = GetOptions(\%opts, ... );
      $ret = GetOptionsFromArray(\@ARGV, \%opts, ... );
  
  =head2 Parsing options from an arbitrary string
  
  A special entry C<GetOptionsFromString> can be used to parse options
  from an arbitrary string.
  
      use Getopt::Long qw(GetOptionsFromString);
      $ret = GetOptionsFromString($string, ...);
  
  The contents of the string are split into arguments using a call to
  C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
  global C<@ARGV> is not touched.
  
  It is possible that, upon completion, not all arguments in the string
  have been processed. C<GetOptionsFromString> will, when called in list
  context, return both the return status and an array reference to any
  remaining arguments:
  
      ($ret, $args) = GetOptionsFromString($string, ... );
  
  If any arguments remain, and C<GetOptionsFromString> was not called in
  list context, a message will be given and C<GetOptionsFromString> will
  return failure.
  
  As with GetOptionsFromArray, a first argument hash reference now
  becomes the second argument.
  
  =head2 Storing options values in a hash
  
  Sometimes, for example when there are a lot of options, having a
  separate variable for each of them can be cumbersome. GetOptions()
  supports, as an alternative mechanism, storing options values in a
  hash.
  
  To obtain this, a reference to a hash must be passed I<as the first
  argument> to GetOptions(). For each option that is specified on the
  command line, the option value will be stored in the hash with the
  option name as key. Options that are not actually used on the command
  line will not be put in the hash, on other words,
  C<exists($h{option})> (or defined()) can be used to test if an option
  was used. The drawback is that warnings will be issued if the program
  runs under C<use strict> and uses C<$h{option}> without testing with
  exists() or defined() first.
  
      my %h = ();
      GetOptions (\%h, 'length=i');	# will store in $h{length}
  
  For options that take list or hash values, it is necessary to indicate
  this by appending an C<@> or C<%> sign after the type:
  
      GetOptions (\%h, 'colours=s@');	# will push to @{$h{colours}}
  
  To make things more complicated, the hash may contain references to
  the actual destinations, for example:
  
      my $len = 0;
      my %h = ('length' => \$len);
      GetOptions (\%h, 'length=i');	# will store in $len
  
  This example is fully equivalent with:
  
      my $len = 0;
      GetOptions ('length=i' => \$len);	# will store in $len
  
  Any mixture is possible. For example, the most frequently used options
  could be stored in variables while all other options get stored in the
  hash:
  
      my $verbose = 0;			# frequently referred
      my $debug = 0;			# frequently referred
      my %h = ('verbose' => \$verbose, 'debug' => \$debug);
      GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
      if ( $verbose ) { ... }
      if ( exists $h{filter} ) { ... option 'filter' was specified ... }
  
  =head2 Bundling
  
  With bundling it is possible to set several single-character options
  at once. For example if C<a>, C<v> and C<x> are all valid options,
  
      -vax
  
  will set all three.
  
  Getopt::Long supports three styles of bundling. To enable bundling, a
  call to Getopt::Long::Configure is required.
  
  The simplest style of bundling can be enabled with:
  
      Getopt::Long::Configure ("bundling");
  
  Configured this way, single-character options can be bundled but long
  options B<must> always start with a double dash C<--> to avoid
  ambiguity. For example, when C<vax>, C<a>, C<v> and C<x> are all valid
  options,
  
      -vax
  
  will set C<a>, C<v> and C<x>, but
  
      --vax
  
  will set C<vax>.
  
  The second style of bundling lifts this restriction. It can be enabled
  with:
  
      Getopt::Long::Configure ("bundling_override");
  
  Now, C<-vax> will set the option C<vax>.
  
  In all of the above cases, option values may be inserted in the
  bundle. For example:
  
      -h24w80
  
  is equivalent to
  
      -h 24 -w 80
  
  A third style of bundling allows only values to be bundled with
  options. It can be enabled with:
  
      Getopt::Long::Configure ("bundling_values");
  
  Now, C<-h24> will set the option C<h> to C<24>, but option bundles
  like C<-vxa> and C<-h24w80> are flagged as errors.
  
  Enabling C<bundling_values> will disable the other two styles of
  bundling.
  
  When configured for bundling, single-character options are matched
  case sensitive while long options are matched case insensitive. To
  have the single-character options matched case insensitive as well,
  use:
  
      Getopt::Long::Configure ("bundling", "ignorecase_always");
  
  It goes without saying that bundling can be quite confusing.
  
  =head2 The lonesome dash
  
  Normally, a lone dash C<-> on the command line will not be considered
  an option. Option processing will terminate (unless "permute" is
  configured) and the dash will be left in C<@ARGV>.
  
  It is possible to get special treatment for a lone dash. This can be
  achieved by adding an option specification with an empty name, for
  example:
  
      GetOptions ('' => \$stdio);
  
  A lone dash on the command line will now be a legal option, and using
  it will set variable C<$stdio>.
  
  =head2 Argument callback
  
  A special option 'name' C<< <> >> can be used to designate a subroutine
  to handle non-option arguments. When GetOptions() encounters an
  argument that does not look like an option, it will immediately call this
  subroutine and passes it one parameter: the argument name. Well, actually
  it is an object that stringifies to the argument name.
  
  For example:
  
      my $width = 80;
      sub process { ... }
      GetOptions ('width=i' => \$width, '<>' => \&process);
  
  When applied to the following command line:
  
      arg1 --width=72 arg2 --width=60 arg3
  
  This will call
  C<process("arg1")> while C<$width> is C<80>,
  C<process("arg2")> while C<$width> is C<72>, and
  C<process("arg3")> while C<$width> is C<60>.
  
  This feature requires configuration option B<permute>, see section
  L<Configuring Getopt::Long>.
  
  =head1 Configuring Getopt::Long
  
  Getopt::Long can be configured by calling subroutine
  Getopt::Long::Configure(). This subroutine takes a list of quoted
  strings, each specifying a configuration option to be enabled, e.g.
  C<ignore_case>, or disabled, e.g. C<no_ignore_case>. Case does not
  matter. Multiple calls to Configure() are possible.
  
  Alternatively, as of version 2.24, the configuration options may be
  passed together with the C<use> statement:
  
      use Getopt::Long qw(:config no_ignore_case bundling);
  
  The following options are available:
  
  =over 12
  
  =item default
  
  This option causes all configuration options to be reset to their
  default values.
  
  =item posix_default
  
  This option causes all configuration options to be reset to their
  default values as if the environment variable POSIXLY_CORRECT had
  been set.
  
  =item auto_abbrev
  
  Allow option names to be abbreviated to uniqueness.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.
  
  =item getopt_compat
  
  Allow C<+> to start options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.
  
  =item gnu_compat
  
  C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
  do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
  C<--opt=> will give option C<opt> and empty value.
  This is the way GNU getopt_long() does it.
  
  Note that C<--opt value> is still accepted, even though GNU
  getopt_long() doesn't.
  
  =item gnu_getopt
  
  This is a short way of setting C<gnu_compat> C<bundling> C<permute>
  C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
  reasonably compatible with GNU getopt_long().
  
  =item require_order
  
  Whether command line arguments are allowed to be mixed with options.
  Default is disabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.
  
  See also C<permute>, which is the opposite of C<require_order>.
  
  =item permute
  
  Whether command line arguments are allowed to be mixed with options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
  Note that C<permute> is the opposite of C<require_order>.
  
  If C<permute> is enabled, this means that
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo --bar arg1 arg2 arg3
  
  If an argument callback routine is specified, C<@ARGV> will always be
  empty upon successful return of GetOptions() since all options have been
  processed. The only exception is when C<--> is used:
  
      --foo arg1 --bar arg2 -- arg3
  
  This will call the callback routine for arg1 and arg2, and then
  terminate GetOptions() leaving C<"arg3"> in C<@ARGV>.
  
  If C<require_order> is enabled, options processing
  terminates when the first non-option is encountered.
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo -- arg1 --bar arg2 arg3
  
  If C<pass_through> is also enabled, options processing will terminate
  at the first unrecognized option, or non-option, whichever comes
  first.
  
  =item bundling (default: disabled)
  
  Enabling this option will allow single-character options to be
  bundled. To distinguish bundles from long option names, long options
  I<must> be introduced with C<--> and bundles with C<->.
  
  Note that, if you have options C<a>, C<l> and C<all>, and
  auto_abbrev enabled, possible arguments and option settings are:
  
      using argument               sets option(s)
      ------------------------------------------
      -a, --a                      a
      -l, --l                      l
      -al, -la, -ala, -all,...     a, l
      --al, --all                  all
  
  The surprising part is that C<--a> sets option C<a> (due to auto
  completion), not C<all>.
  
  Note: disabling C<bundling> also disables C<bundling_override>.
  
  =item bundling_override (default: disabled)
  
  If C<bundling_override> is enabled, bundling is enabled as with
  C<bundling> but now long option names override option bundles.
  
  Note: disabling C<bundling_override> also disables C<bundling>.
  
  B<Note:> Using option bundling can easily lead to unexpected results,
  especially when mixing long options and bundles. Caveat emptor.
  
  =item ignore_case  (default: enabled)
  
  If enabled, case is ignored when matching option names. If, however,
  bundling is enabled as well, single character options will be treated
  case-sensitive.
  
  With C<ignore_case>, option specifications for options that only
  differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
  duplicates.
  
  Note: disabling C<ignore_case> also disables C<ignore_case_always>.
  
  =item ignore_case_always (default: disabled)
  
  When bundling is in effect, case is ignored on single-character
  options also.
  
  Note: disabling C<ignore_case_always> also disables C<ignore_case>.
  
  =item auto_version (default:disabled)
  
  Automatically provide support for the B<--version> option if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a standard version message that includes the
  program name, its version (if $main::VERSION is defined), and the
  versions of Getopt::Long and Perl. The message will be written to
  standard output and processing will terminate.
  
  C<auto_version> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item auto_help (default:disabled)
  
  Automatically provide support for the B<--help> and B<-?> options if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a help message using module L<Pod::Usage>. The
  message, derived from the SYNOPSIS POD section, will be written to
  standard output and processing will terminate.
  
  C<auto_help> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item pass_through (default: disabled)
  
  With C<pass_through> anything that is unknown, ambiguous or supplied with
  an invalid option will not be flagged as an error. Instead the unknown
  option(s) will be passed to the catchall C<< <> >> if present, otherwise
  through to C<@ARGV>. This makes it possible to write wrapper scripts that
  process only part of the user supplied command line arguments, and pass the
  remaining options to some other program.
  
  If C<require_order> is enabled, options processing will terminate at the
  first unrecognized option, or non-option, whichever comes first and all
  remaining arguments are passed to C<@ARGV> instead of the catchall
  C<< <> >> if present.  However, if C<permute> is enabled instead, results
  can become confusing.
  
  Note that the options terminator (default C<-->), if present, will
  also be passed through in C<@ARGV>.
  
  =item prefix
  
  The string that starts options. If a constant string is not
  sufficient, see C<prefix_pattern>.
  
  =item prefix_pattern
  
  A Perl pattern that identifies the strings that introduce options.
  Default is C<--|-|\+> unless environment variable
  POSIXLY_CORRECT has been set, in which case it is C<--|->.
  
  =item long_prefix_pattern
  
  A Perl pattern that allows the disambiguation of long and short
  prefixes. Default is C<-->.
  
  Typically you only need to set this if you are using nonstandard
  prefixes and want some or all of them to have the same semantics as
  '--' does under normal circumstances.
  
  For example, setting prefix_pattern to C<--|-|\+|\/> and
  long_prefix_pattern to C<--|\/> would add Win32 style argument
  handling.
  
  =item debug (default: disabled)
  
  Enable debugging output.
  
  =back
  
  =head1 Exportable Methods
  
  =over
  
  =item VersionMessage
  
  This subroutine provides a standard version message. Its argument can be:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the standard message.
  
  =item *
  
  A numeric value corresponding to the desired exit status.
  
  =item *
  
  A reference to a hash.
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message>
  
  =item C<-msg>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string "NOEXIT" to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-output>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =back
  
  You cannot tie this routine directly to an option, e.g.:
  
      GetOptions("version" => \&VersionMessage);
  
  Use this instead:
  
      GetOptions("version" => sub { VersionMessage() });
  
  =item HelpMessage
  
  This subroutine produces a standard help message, derived from the
  program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
  arguments as VersionMessage(). In particular, you cannot tie it
  directly to an option, e.g.:
  
      GetOptions("help" => \&HelpMessage);
  
  Use this instead:
  
      GetOptions("help" => sub { HelpMessage() });
  
  =back
  
  =head1 Return values and Errors
  
  Configuration errors and errors in the option definitions are
  signalled using die() and will terminate the calling program unless
  the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
  }>, or die() was trapped using C<$SIG{__DIE__}>.
  
  GetOptions returns true to indicate success.
  It returns false when the function detected one or more errors during
  option parsing. These errors are signalled using warn() and can be
  trapped with C<$SIG{__WARN__}>.
  
  =head1 Legacy
  
  The earliest development of C<newgetopt.pl> started in 1990, with Perl
  version 4. As a result, its development, and the development of
  Getopt::Long, has gone through several stages. Since backward
  compatibility has always been extremely important, the current version
  of Getopt::Long still supports a lot of constructs that nowadays are
  no longer necessary or otherwise unwanted. This section describes
  briefly some of these 'features'.
  
  =head2 Default destinations
  
  When no destination is specified for an option, GetOptions will store
  the resultant value in a global variable named C<opt_>I<XXX>, where
  I<XXX> is the primary name of this option. When a program executes
  under C<use strict> (recommended), these variables must be
  pre-declared with our() or C<use vars>.
  
      our $opt_length = 0;
      GetOptions ('length=i');	# will store in $opt_length
  
  To yield a usable Perl variable, characters that are not part of the
  syntax for variables are translated to underscores. For example,
  C<--fpp-struct-return> will set the variable
  C<$opt_fpp_struct_return>. Note that this variable resides in the
  namespace of the calling program, not necessarily C<main>. For
  example:
  
      GetOptions ("size=i", "sizes=i@");
  
  with command line "-size 10 -sizes 24 -sizes 48" will perform the
  equivalent of the assignments
  
      $opt_size = 10;
      @opt_sizes = (24, 48);
  
  =head2 Alternative option starters
  
  A string of alternative option starter characters may be passed as the
  first argument (or the first argument after a leading hash reference
  argument).
  
      my $len = 0;
      GetOptions ('/', 'length=i' => $len);
  
  Now the command line may look like:
  
      /length 24 -- arg
  
  Note that to terminate options processing still requires a double dash
  C<-->.
  
  GetOptions() will not interpret a leading C<< "<>" >> as option starters
  if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
  option starters, use C<< "><" >>. Confusing? Well, B<using a starter
  argument is strongly deprecated> anyway.
  
  =head2 Configuration variables
  
  Previous versions of Getopt::Long used variables for the purpose of
  configuring. Although manipulating these variables still work, it is
  strongly encouraged to use the C<Configure> routine that was introduced
  in version 2.17. Besides, it is much easier.
  
  =head1 Tips and Techniques
  
  =head2 Pushing multiple values in a hash option
  
  Sometimes you want to combine the best of hashes and arrays. For
  example, the command line:
  
    --list add=first --list add=second --list add=third
  
  where each successive 'list add' option will push the value of add
  into array ref $list->{'add'}. The result would be like
  
    $list->{add} = [qw(first second third)];
  
  This can be accomplished with a destination routine:
  
    GetOptions('list=s%' =>
                 sub { push(@{$list{$_[1]}}, $_[2]) });
  
  =head1 Troubleshooting
  
  =head2 GetOptions does not return a false result when an option is not supplied
  
  That's why they're called 'options'.
  
  =head2 GetOptions does not split the command line correctly
  
  The command line is not split by GetOptions, but by the command line
  interpreter (CLI). On Unix, this is the shell. On Windows, it is
  COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.
  
  It is important to know that these CLIs may behave different when the
  command line contains special characters, in particular quotes or
  backslashes. For example, with Unix shells you can use single quotes
  (C<'>) and double quotes (C<">) to group words together. The following
  alternatives are equivalent on Unix:
  
      "two words"
      'two words'
      two\ words
  
  In case of doubt, insert the following statement in front of your Perl
  program:
  
      print STDERR (join("|",@ARGV),"\n");
  
  to verify how your CLI passes the arguments to the program.
  
  =head2 Undefined subroutine &main::GetOptions called
  
  Are you running Windows, and did you write
  
      use GetOpt::Long;
  
  (note the capital 'O')?
  
  =head2 How do I put a "-?" option into a Getopt::Long?
  
  You can only obtain this using an alias, and Getopt::Long of at least
  version 2.13.
  
      use Getopt::Long;
      GetOptions ("help|?");    # -help and -? will both set $opt_help
  
  Other characters that can't appear in Perl identifiers are also supported
  as aliases with Getopt::Long of at least version 2.39.
  
  As of version 2.32 Getopt::Long provides auto-help, a quick and easy way
  to add the options --help and -? to your program, and handle them.
  
  See C<auto_help> in section L<Configuring Getopt::Long>.
  
  =head1 AUTHOR
  
  Johan Vromans <jvromans@squirrel.nl>
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  This program is Copyright 1990,2015 by Johan Vromans.
  This program is free software; you can redistribute it and/or
  modify it under the terms of the Perl Artistic License or the
  GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any
  later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  If you do not have a copy of the GNU General Public License write to
  the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
  MA 02139, USA.
  
  =cut
  
GETOPT_LONG

$fatpacked{"Git.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT';
  =head1 NAME
  
  Git - Perl interface to the Git version control system
  
  =cut
  
  
  package Git;
  
  use 5.008;
  use strict;
  
  
  BEGIN {
  
  our ($VERSION, @ISA, @EXPORT, @EXPORT_OK);
  
  # Totally unstable API.
  $VERSION = '0.42';
  # pulled from github, commit 217f2767cbcb562872437eed4dec62e00846d90c
  
  
  =head1 SYNOPSIS
  
    use Git;
  
    my $version = Git::command_oneline('version');
  
    git_cmd_try { Git::command_noisy('update-server-info') }
                '%s failed w/ code %d';
  
    my $repo = Git->repository (Directory => '/srv/git/cogito.git');
  
  
    my @revs = $repo->command('rev-list', '--since=last monday', '--all');
  
    my ($fh, $c) = $repo->command_output_pipe('rev-list', '--since=last monday', '--all');
    my $lastrev = <$fh>; chomp $lastrev;
    $repo->command_close_pipe($fh, $c);
  
    my $lastrev = $repo->command_oneline( [ 'rev-list', '--all' ],
                                          STDERR => 0 );
  
    my $sha1 = $repo->hash_and_insert_object('file.txt');
    my $tempfile = tempfile();
    my $size = $repo->cat_blob($sha1, $tempfile);
  
  =cut
  
  
  require Exporter;
  
  @ISA = qw(Exporter);
  
  @EXPORT = qw(git_cmd_try);
  
  # Methods which can be called as standalone functions as well:
  @EXPORT_OK = qw(command command_oneline command_noisy
                  command_output_pipe command_input_pipe command_close_pipe
                  command_bidi_pipe command_close_bidi_pipe
                  version exec_path html_path hash_object git_cmd_try
                  remote_refs prompt
                  get_tz_offset get_record
                  credential credential_read credential_write
                  temp_acquire temp_is_locked temp_release temp_reset temp_path
                  unquote_path);
  
  
  =head1 DESCRIPTION
  
  [MAINTAINER NOTE: This is Git.pm, plus the other files in the perl/Git directory,
  from github's git/git, which is a mirror of the git source.  I (cpan msouth, or
  current maintainer) update the VERSION string (necessary on CPAN because of another
  CPAN distribution that confused the CPAN toolchain about which was the actual
  official Git.pm), add this explanatory paragraph, and use Dist::Zilla to package
  and release on CPAN.  The only reason that I know of that you would need this is
  if you are using something like Git::Hooks and you are using a perlbrewed (or
  otherwise separate) perl from the one git is using on your system (e.g. if you
  have a dev perl that’s separate from system perl, and git uses the system perl.
  Then the Git.pm gets installed in the system lib and you have no way of getting
  it from CPAN, so your code--that uses modules that depend on Git.pm--doesn’t work).
  I try to keep this up to date, so that if you do pull this from CPAN it will be,
  hopefully, identical in functionality to the Git.pm and Git/*.pm from the git
  distribution.  If that is not the case, contact me and I'll look into it.]
  
  This module provides Perl scripts easy way to interface the Git version control
  system. The modules have an easy and well-tested way to call arbitrary Git
  commands; in the future, the interface will also provide specialized methods
  for doing easily operations which are not totally trivial to do over
  the generic command interface.
  
  While some commands can be executed outside of any context (e.g. 'version'
  or 'init'), most operations require a repository context, which in practice
  means getting an instance of the Git object using the repository() constructor.
  (In the future, we will also get a new_repository() constructor.) All commands
  called as methods of the object are then executed in the context of the
  repository.
  
  Part of the "repository state" is also information about path to the attached
  working copy (unless you work with a bare repository). You can also navigate
  inside of the working copy using the C<wc_chdir()> method. (Note that
  the repository object is self-contained and will not change working directory
  of your process.)
  
  TODO: In the future, we might also do
  
  	my $remoterepo = $repo->remote_repository (Name => 'cogito', Branch => 'master');
  	$remoterepo ||= Git->remote_repository ('http://git.or.cz/cogito.git/');
  	my @refs = $remoterepo->refs();
  
  Currently, the module merely wraps calls to external Git tools. In the future,
  it will provide a much faster way to interact with Git by linking directly
  to libgit. This should be completely opaque to the user, though (performance
  increase notwithstanding).
  
  =cut
  
  
  use Carp qw(carp croak); # but croak is bad - throw instead
  use Error qw(:try);
  use Cwd qw(abs_path cwd);
  use IPC::Open2 qw(open2);
  use Fcntl qw(SEEK_SET SEEK_CUR);
  use Time::Local qw(timegm);
  }
  
  
  =head1 CONSTRUCTORS
  
  =over 4
  
  =item repository ( OPTIONS )
  
  =item repository ( DIRECTORY )
  
  =item repository ()
  
  Construct a new repository object.
  C<OPTIONS> are passed in a hash like fashion, using key and value pairs.
  Possible options are:
  
  B<Repository> - Path to the Git repository.
  
  B<WorkingCopy> - Path to the associated working copy; not strictly required
  as many commands will happily crunch on a bare repository.
  
  B<WorkingSubdir> - Subdirectory in the working copy to work inside.
  Just left undefined if you do not want to limit the scope of operations.
  
  B<Directory> - Path to the Git working directory in its usual setup.
  The C<.git> directory is searched in the directory and all the parent
  directories; if found, C<WorkingCopy> is set to the directory containing
  it and C<Repository> to the C<.git> directory itself. If no C<.git>
  directory was found, the C<Directory> is assumed to be a bare repository,
  C<Repository> is set to point at it and C<WorkingCopy> is left undefined.
  If the C<$GIT_DIR> environment variable is set, things behave as expected
  as well.
  
  You should not use both C<Directory> and either of C<Repository> and
  C<WorkingCopy> - the results of that are undefined.
  
  Alternatively, a directory path may be passed as a single scalar argument
  to the constructor; it is equivalent to setting only the C<Directory> option
  field.
  
  Calling the constructor with no options whatsoever is equivalent to
  calling it with C<< Directory => '.' >>. In general, if you are building
  a standard porcelain command, simply doing C<< Git->repository() >> should
  do the right thing and setup the object to reflect exactly where the user
  is right now.
  
  =cut
  
  sub repository {
  	my $class = shift;
  	my @args = @_;
  	my %opts = ();
  	my $self;
  
  	if (defined $args[0]) {
  		if ($#args % 2 != 1) {
  			# Not a hash.
  			$#args == 0 or throw Error::Simple("bad usage");
  			%opts = ( Directory => $args[0] );
  		} else {
  			%opts = @args;
  		}
  	}
  
  	if (not defined $opts{Repository} and not defined $opts{WorkingCopy}
  		and not defined $opts{Directory}) {
  		$opts{Directory} = '.';
  	}
  
  	if (defined $opts{Directory}) {
  		-d $opts{Directory} or throw Error::Simple("Directory not found: $opts{Directory} $!");
  
  		my $search = Git->repository(WorkingCopy => $opts{Directory});
  		my $dir;
  		try {
  			$dir = $search->command_oneline(['rev-parse', '--git-dir'],
  			                                STDERR => 0);
  		} catch Git::Error::Command with {
  			$dir = undef;
  		};
  
  		if ($dir) {
  			_verify_require();
  			File::Spec->file_name_is_absolute($dir) or $dir = $opts{Directory} . '/' . $dir;
  			$opts{Repository} = abs_path($dir);
  
  			# If --git-dir went ok, this shouldn't die either.
  			my $prefix = $search->command_oneline('rev-parse', '--show-prefix');
  			$dir = abs_path($opts{Directory}) . '/';
  			if ($prefix) {
  				if (substr($dir, -length($prefix)) ne $prefix) {
  					throw Error::Simple("rev-parse confused me - $dir does not have trailing $prefix");
  				}
  				substr($dir, -length($prefix)) = '';
  			}
  			$opts{WorkingCopy} = $dir;
  			$opts{WorkingSubdir} = $prefix;
  
  		} else {
  			# A bare repository? Let's see...
  			$dir = $opts{Directory};
  
  			unless (-d "$dir/refs" and -d "$dir/objects" and -e "$dir/HEAD") {
  				# Mimic git-rev-parse --git-dir error message:
  				throw Error::Simple("fatal: Not a git repository: $dir");
  			}
  			my $search = Git->repository(Repository => $dir);
  			try {
  				$search->command('symbolic-ref', 'HEAD');
  			} catch Git::Error::Command with {
  				# Mimic git-rev-parse --git-dir error message:
  				throw Error::Simple("fatal: Not a git repository: $dir");
  			}
  
  			$opts{Repository} = abs_path($dir);
  		}
  
  		delete $opts{Directory};
  	}
  
  	$self = { opts => \%opts };
  	bless $self, $class;
  }
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item command ( COMMAND [, ARGUMENTS... ] )
  
  =item command ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )
  
  Execute the given Git C<COMMAND> (specify it without the 'git-'
  prefix), optionally with the specified extra C<ARGUMENTS>.
  
  The second more elaborate form can be used if you want to further adjust
  the command execution. Currently, only one option is supported:
  
  B<STDERR> - How to deal with the command's error output. By default (C<undef>)
  it is delivered to the caller's C<STDERR>. A false value (0 or '') will cause
  it to be thrown away. If you want to process it, you can get it in a filehandle
  you specify, but you must be extremely careful; if the error output is not
  very short and you want to read it in the same process as where you called
  C<command()>, you are set up for a nice deadlock!
  
  The method can be called without any instance or on a specified Git repository
  (in that case the command will be run in the repository context).
  
  In scalar context, it returns all the command output in a single string
  (verbatim).
  
  In array context, it returns an array containing lines printed to the
  command's stdout (without trailing newlines).
  
  In both cases, the command's stdin and stderr are the same as the caller's.
  
  =cut
  
  sub command {
  	my ($fh, $ctx) = command_output_pipe(@_);
  
  	if (not defined wantarray) {
  		# Nothing to pepper the possible exception with.
  		_cmd_close($ctx, $fh);
  
  	} elsif (not wantarray) {
  		local $/;
  		my $text = <$fh>;
  		try {
  			_cmd_close($ctx, $fh);
  		} catch Git::Error::Command with {
  			# Pepper with the output:
  			my $E = shift;
  			$E->{'-outputref'} = \$text;
  			throw $E;
  		};
  		return $text;
  
  	} else {
  		my @lines = <$fh>;
  		defined and chomp for @lines;
  		try {
  			_cmd_close($ctx, $fh);
  		} catch Git::Error::Command with {
  			my $E = shift;
  			$E->{'-outputref'} = \@lines;
  			throw $E;
  		};
  		return @lines;
  	}
  }
  
  
  =item command_oneline ( COMMAND [, ARGUMENTS... ] )
  
  =item command_oneline ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )
  
  Execute the given C<COMMAND> in the same way as command()
  does but always return a scalar string containing the first line
  of the command's standard output.
  
  =cut
  
  sub command_oneline {
  	my ($fh, $ctx) = command_output_pipe(@_);
  
  	my $line = <$fh>;
  	defined $line and chomp $line;
  	try {
  		_cmd_close($ctx, $fh);
  	} catch Git::Error::Command with {
  		# Pepper with the output:
  		my $E = shift;
  		$E->{'-outputref'} = \$line;
  		throw $E;
  	};
  	return $line;
  }
  
  
  =item command_output_pipe ( COMMAND [, ARGUMENTS... ] )
  
  =item command_output_pipe ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )
  
  Execute the given C<COMMAND> in the same way as command()
  does but return a pipe filehandle from which the command output can be
  read.
  
  The function can return C<($pipe, $ctx)> in array context.
  See C<command_close_pipe()> for details.
  
  =cut
  
  sub command_output_pipe {
  	_command_common_pipe('-|', @_);
  }
  
  
  =item command_input_pipe ( COMMAND [, ARGUMENTS... ] )
  
  =item command_input_pipe ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )
  
  Execute the given C<COMMAND> in the same way as command_output_pipe()
  does but return an input pipe filehandle instead; the command output
  is not captured.
  
  The function can return C<($pipe, $ctx)> in array context.
  See C<command_close_pipe()> for details.
  
  =cut
  
  sub command_input_pipe {
  	_command_common_pipe('|-', @_);
  }
  
  
  =item command_close_pipe ( PIPE [, CTX ] )
  
  Close the C<PIPE> as returned from C<command_*_pipe()>, checking
  whether the command finished successfully. The optional C<CTX> argument
  is required if you want to see the command name in the error message,
  and it is the second value returned by C<command_*_pipe()> when
  called in array context. The call idiom is:
  
  	my ($fh, $ctx) = $r->command_output_pipe('status');
  	while (<$fh>) { ... }
  	$r->command_close_pipe($fh, $ctx);
  
  Note that you should not rely on whatever actually is in C<CTX>;
  currently it is simply the command name but in future the context might
  have more complicated structure.
  
  =cut
  
  sub command_close_pipe {
  	my ($self, $fh, $ctx) = _maybe_self(@_);
  	$ctx ||= '<unknown>';
  	_cmd_close($ctx, $fh);
  }
  
  =item command_bidi_pipe ( COMMAND [, ARGUMENTS... ] )
  
  Execute the given C<COMMAND> in the same way as command_output_pipe()
  does but return both an input pipe filehandle and an output pipe filehandle.
  
  The function will return C<($pid, $pipe_in, $pipe_out, $ctx)>.
  See C<command_close_bidi_pipe()> for details.
  
  =cut
  
  sub command_bidi_pipe {
  	my ($pid, $in, $out);
  	my ($self) = _maybe_self(@_);
  	local %ENV = %ENV;
  	my $cwd_save = undef;
  	if ($self) {
  		shift;
  		$cwd_save = cwd();
  		_setup_git_cmd_env($self);
  	}
  	$pid = open2($in, $out, 'git', @_);
  	chdir($cwd_save) if $cwd_save;
  	return ($pid, $in, $out, join(' ', @_));
  }
  
  =item command_close_bidi_pipe ( PID, PIPE_IN, PIPE_OUT [, CTX] )
  
  Close the C<PIPE_IN> and C<PIPE_OUT> as returned from C<command_bidi_pipe()>,
  checking whether the command finished successfully. The optional C<CTX>
  argument is required if you want to see the command name in the error message,
  and it is the fourth value returned by C<command_bidi_pipe()>.  The call idiom
  is:
  
  	my ($pid, $in, $out, $ctx) = $r->command_bidi_pipe('cat-file --batch-check');
  	print $out "000000000\n";
  	while (<$in>) { ... }
  	$r->command_close_bidi_pipe($pid, $in, $out, $ctx);
  
  Note that you should not rely on whatever actually is in C<CTX>;
  currently it is simply the command name but in future the context might
  have more complicated structure.
  
  C<PIPE_IN> and C<PIPE_OUT> may be C<undef> if they have been closed prior to
  calling this function.  This may be useful in a query-response type of
  commands where caller first writes a query and later reads response, eg:
  
  	my ($pid, $in, $out, $ctx) = $r->command_bidi_pipe('cat-file --batch-check');
  	print $out "000000000\n";
  	close $out;
  	while (<$in>) { ... }
  	$r->command_close_bidi_pipe($pid, $in, undef, $ctx);
  
  This idiom may prevent potential dead locks caused by data sent to the output
  pipe not being flushed and thus not reaching the executed command.
  
  =cut
  
  sub command_close_bidi_pipe {
  	local $?;
  	my ($self, $pid, $in, $out, $ctx) = _maybe_self(@_);
  	_cmd_close($ctx, (grep { defined } ($in, $out)));
  	waitpid $pid, 0;
  	if ($? >> 8) {
  		throw Git::Error::Command($ctx, $? >>8);
  	}
  }
  
  
  =item command_noisy ( COMMAND [, ARGUMENTS... ] )
  
  Execute the given C<COMMAND> in the same way as command() does but do not
  capture the command output - the standard output is not redirected and goes
  to the standard output of the caller application.
  
  While the method is called command_noisy(), you might want to as well use
  it for the most silent Git commands which you know will never pollute your
  stdout but you want to avoid the overhead of the pipe setup when calling them.
  
  The function returns only after the command has finished running.
  
  =cut
  
  sub command_noisy {
  	my ($self, $cmd, @args) = _maybe_self(@_);
  	_check_valid_cmd($cmd);
  
  	my $pid = fork;
  	if (not defined $pid) {
  		throw Error::Simple("fork failed: $!");
  	} elsif ($pid == 0) {
  		_cmd_exec($self, $cmd, @args);
  	}
  	if (waitpid($pid, 0) > 0 and $?>>8 != 0) {
  		throw Git::Error::Command(join(' ', $cmd, @args), $? >> 8);
  	}
  }
  
  
  =item version ()
  
  Return the Git version in use.
  
  =cut
  
  sub version {
  	my $verstr = command_oneline('--version');
  	$verstr =~ s/^git version //;
  	$verstr;
  }
  
  
  =item exec_path ()
  
  Return path to the Git sub-command executables (the same as
  C<git --exec-path>). Useful mostly only internally.
  
  =cut
  
  sub exec_path { command_oneline('--exec-path') }
  
  
  =item html_path ()
  
  Return path to the Git html documentation (the same as
  C<git --html-path>). Useful mostly only internally.
  
  =cut
  
  sub html_path { command_oneline('--html-path') }
  
  
  =item get_tz_offset ( TIME )
  
  Return the time zone offset from GMT in the form +/-HHMM where HH is
  the number of hours from GMT and MM is the number of minutes.  This is
  the equivalent of what strftime("%z", ...) would provide on a GNU
  platform.
  
  If TIME is not supplied, the current local time is used.
  
  =cut
  
  sub get_tz_offset {
  	# some systems don't handle or mishandle %z, so be creative.
  	my $t = shift || time;
  	my $gm = timegm(localtime($t));
  	my $sign = qw( + + - )[ $gm <=> $t ];
  	return sprintf("%s%02d%02d", $sign, (gmtime(abs($t - $gm)))[2,1]);
  }
  
  =item get_record ( FILEHANDLE, INPUT_RECORD_SEPARATOR )
  
  Read one record from FILEHANDLE delimited by INPUT_RECORD_SEPARATOR,
  removing any trailing INPUT_RECORD_SEPARATOR.
  
  =cut
  
  sub get_record {
  	my ($fh, $rs) = @_;
  	local $/ = $rs;
  	my $rec = <$fh>;
  	chomp $rec if defined $rs;
  	$rec;
  }
  
  =item prompt ( PROMPT , ISPASSWORD  )
  
  Query user C<PROMPT> and return answer from user.
  
  Honours GIT_ASKPASS and SSH_ASKPASS environment variables for querying
  the user. If no *_ASKPASS variable is set or an error occoured,
  the terminal is tried as a fallback.
  If C<ISPASSWORD> is set and true, the terminal disables echo.
  
  =cut
  
  sub prompt {
  	my ($prompt, $isPassword) = @_;
  	my $ret;
  	if (exists $ENV{'GIT_ASKPASS'}) {
  		$ret = _prompt($ENV{'GIT_ASKPASS'}, $prompt);
  	}
  	if (!defined $ret && exists $ENV{'SSH_ASKPASS'}) {
  		$ret = _prompt($ENV{'SSH_ASKPASS'}, $prompt);
  	}
  	if (!defined $ret) {
  		print STDERR $prompt;
  		STDERR->flush;
  		if (defined $isPassword && $isPassword) {
  			require Term::ReadKey;
  			Term::ReadKey::ReadMode('noecho');
  			$ret = '';
  			while (defined(my $key = Term::ReadKey::ReadKey(0))) {
  				last if $key =~ /[\012\015]/; # \n\r
  				$ret .= $key;
  			}
  			Term::ReadKey::ReadMode('restore');
  			print STDERR "\n";
  			STDERR->flush;
  		} else {
  			chomp($ret = <STDIN>);
  		}
  	}
  	return $ret;
  }
  
  sub _prompt {
  	my ($askpass, $prompt) = @_;
  	return unless length $askpass;
  	$prompt =~ s/\n/ /g;
  	my $ret;
  	open my $fh, "-|", $askpass, $prompt or return;
  	$ret = <$fh>;
  	$ret =~ s/[\015\012]//g; # strip \r\n, chomp does not work on all systems (i.e. windows) as expected
  	close ($fh);
  	return $ret;
  }
  
  =item repo_path ()
  
  Return path to the git repository. Must be called on a repository instance.
  
  =cut
  
  sub repo_path { $_[0]->{opts}->{Repository} }
  
  
  =item wc_path ()
  
  Return path to the working copy. Must be called on a repository instance.
  
  =cut
  
  sub wc_path { $_[0]->{opts}->{WorkingCopy} }
  
  
  =item wc_subdir ()
  
  Return path to the subdirectory inside of a working copy. Must be called
  on a repository instance.
  
  =cut
  
  sub wc_subdir { $_[0]->{opts}->{WorkingSubdir} ||= '' }
  
  
  =item wc_chdir ( SUBDIR )
  
  Change the working copy subdirectory to work within. The C<SUBDIR> is
  relative to the working copy root directory (not the current subdirectory).
  Must be called on a repository instance attached to a working copy
  and the directory must exist.
  
  =cut
  
  sub wc_chdir {
  	my ($self, $subdir) = @_;
  	$self->wc_path()
  		or throw Error::Simple("bare repository");
  
  	-d $self->wc_path().'/'.$subdir
  		or throw Error::Simple("subdir not found: $subdir $!");
  	# Of course we will not "hold" the subdirectory so anyone
  	# can delete it now and we will never know. But at least we tried.
  
  	$self->{opts}->{WorkingSubdir} = $subdir;
  }
  
  
  =item config ( VARIABLE )
  
  Retrieve the configuration C<VARIABLE> in the same manner as C<config>
  does. In scalar context requires the variable to be set only one time
  (exception is thrown otherwise), in array context returns allows the
  variable to be set multiple times and returns all the values.
  
  =cut
  
  sub config {
  	return _config_common({}, @_);
  }
  
  
  =item config_bool ( VARIABLE )
  
  Retrieve the bool configuration C<VARIABLE>. The return value
  is usable as a boolean in perl (and C<undef> if it's not defined,
  of course).
  
  =cut
  
  sub config_bool {
  	my $val = scalar _config_common({'kind' => '--bool'}, @_);
  
  	# Do not rewrite this as return (defined $val && $val eq 'true')
  	# as some callers do care what kind of falsehood they receive.
  	if (!defined $val) {
  		return undef;
  	} else {
  		return $val eq 'true';
  	}
  }
  
  
  =item config_path ( VARIABLE )
  
  Retrieve the path configuration C<VARIABLE>. The return value
  is an expanded path or C<undef> if it's not defined.
  
  =cut
  
  sub config_path {
  	return _config_common({'kind' => '--path'}, @_);
  }
  
  
  =item config_int ( VARIABLE )
  
  Retrieve the integer configuration C<VARIABLE>. The return value
  is simple decimal number.  An optional value suffix of 'k', 'm',
  or 'g' in the config file will cause the value to be multiplied
  by 1024, 1048576 (1024^2), or 1073741824 (1024^3) prior to output.
  It would return C<undef> if configuration variable is not defined.
  
  =cut
  
  sub config_int {
  	return scalar _config_common({'kind' => '--int'}, @_);
  }
  
  # Common subroutine to implement bulk of what the config* family of methods
  # do. This currently wraps command('config') so it is not so fast.
  sub _config_common {
  	my ($opts) = shift @_;
  	my ($self, $var) = _maybe_self(@_);
  
  	try {
  		my @cmd = ('config', $opts->{'kind'} ? $opts->{'kind'} : ());
  		unshift @cmd, $self if $self;
  		if (wantarray) {
  			return command(@cmd, '--get-all', $var);
  		} else {
  			return command_oneline(@cmd, '--get', $var);
  		}
  	} catch Git::Error::Command with {
  		my $E = shift;
  		if ($E->value() == 1) {
  			# Key not found.
  			return;
  		} else {
  			throw $E;
  		}
  	};
  }
  
  =item get_colorbool ( NAME )
  
  Finds if color should be used for NAMEd operation from the configuration,
  and returns boolean (true for "use color", false for "do not use color").
  
  =cut
  
  sub get_colorbool {
  	my ($self, $var) = @_;
  	my $stdout_to_tty = (-t STDOUT) ? "true" : "false";
  	my $use_color = $self->command_oneline('config', '--get-colorbool',
  					       $var, $stdout_to_tty);
  	return ($use_color eq 'true');
  }
  
  =item get_color ( SLOT, COLOR )
  
  Finds color for SLOT from the configuration, while defaulting to COLOR,
  and returns the ANSI color escape sequence:
  
  	print $repo->get_color("color.interactive.prompt", "underline blue white");
  	print "some text";
  	print $repo->get_color("", "normal");
  
  =cut
  
  sub get_color {
  	my ($self, $slot, $default) = @_;
  	my $color = $self->command_oneline('config', '--get-color', $slot, $default);
  	if (!defined $color) {
  		$color = "";
  	}
  	return $color;
  }
  
  =item remote_refs ( REPOSITORY [, GROUPS [, REFGLOBS ] ] )
  
  This function returns a hashref of refs stored in a given remote repository.
  The hash is in the format C<refname =\> hash>. For tags, the C<refname> entry
  contains the tag object while a C<refname^{}> entry gives the tagged objects.
  
  C<REPOSITORY> has the same meaning as the appropriate C<git-ls-remote>
  argument; either a URL or a remote name (if called on a repository instance).
  C<GROUPS> is an optional arrayref that can contain 'tags' to return all the
  tags and/or 'heads' to return all the heads. C<REFGLOB> is an optional array
  of strings containing a shell-like glob to further limit the refs returned in
  the hash; the meaning is again the same as the appropriate C<git-ls-remote>
  argument.
  
  This function may or may not be called on a repository instance. In the former
  case, remote names as defined in the repository are recognized as repository
  specifiers.
  
  =cut
  
  sub remote_refs {
  	my ($self, $repo, $groups, $refglobs) = _maybe_self(@_);
  	my @args;
  	if (ref $groups eq 'ARRAY') {
  		foreach (@$groups) {
  			if ($_ eq 'heads') {
  				push (@args, '--heads');
  			} elsif ($_ eq 'tags') {
  				push (@args, '--tags');
  			} else {
  				# Ignore unknown groups for future
  				# compatibility
  			}
  		}
  	}
  	push (@args, $repo);
  	if (ref $refglobs eq 'ARRAY') {
  		push (@args, @$refglobs);
  	}
  
  	my @self = $self ? ($self) : (); # Ultra trickery
  	my ($fh, $ctx) = Git::command_output_pipe(@self, 'ls-remote', @args);
  	my %refs;
  	while (<$fh>) {
  		chomp;
  		my ($hash, $ref) = split(/\t/, $_, 2);
  		$refs{$ref} = $hash;
  	}
  	Git::command_close_pipe(@self, $fh, $ctx);
  	return \%refs;
  }
  
  
  =item ident ( TYPE | IDENTSTR )
  
  =item ident_person ( TYPE | IDENTSTR | IDENTARRAY )
  
  This suite of functions retrieves and parses ident information, as stored
  in the commit and tag objects or produced by C<var GIT_type_IDENT> (thus
  C<TYPE> can be either I<author> or I<committer>; case is insignificant).
  
  The C<ident> method retrieves the ident information from C<git var>
  and either returns it as a scalar string or as an array with the fields parsed.
  Alternatively, it can take a prepared ident string (e.g. from the commit
  object) and just parse it.
  
  C<ident_person> returns the person part of the ident - name and email;
  it can take the same arguments as C<ident> or the array returned by C<ident>.
  
  The synopsis is like:
  
  	my ($name, $email, $time_tz) = ident('author');
  	"$name <$email>" eq ident_person('author');
  	"$name <$email>" eq ident_person($name);
  	$time_tz =~ /^\d+ [+-]\d{4}$/;
  
  =cut
  
  sub ident {
  	my ($self, $type) = _maybe_self(@_);
  	my $identstr;
  	if (lc $type eq lc 'committer' or lc $type eq lc 'author') {
  		my @cmd = ('var', 'GIT_'.uc($type).'_IDENT');
  		unshift @cmd, $self if $self;
  		$identstr = command_oneline(@cmd);
  	} else {
  		$identstr = $type;
  	}
  	if (wantarray) {
  		return $identstr =~ /^(.*) <(.*)> (\d+ [+-]\d{4})$/;
  	} else {
  		return $identstr;
  	}
  }
  
  sub ident_person {
  	my ($self, @ident) = _maybe_self(@_);
  	$#ident == 0 and @ident = $self ? $self->ident($ident[0]) : ident($ident[0]);
  	return "$ident[0] <$ident[1]>";
  }
  
  =item parse_mailboxes
  
  Return an array of mailboxes extracted from a string.
  
  =cut
  
  # Very close to Mail::Address's parser, but we still have minor
  # differences in some cases (see t9000 for examples).
  sub parse_mailboxes {
  	my $re_comment = qr/\((?:[^)]*)\)/;
  	my $re_quote = qr/"(?:[^\"\\]|\\.)*"/;
  	my $re_word = qr/(?:[^]["\s()<>:;@\\,.]|\\.)+/;
  
  	# divide the string in tokens of the above form
  	my $re_token = qr/(?:$re_quote|$re_word|$re_comment|\S)/;
  	my @tokens = map { $_ =~ /\s*($re_token)\s*/g } @_;
  	my $end_of_addr_seen = 0;
  
  	# add a delimiter to simplify treatment for the last mailbox
  	push @tokens, ",";
  
  	my (@addr_list, @phrase, @address, @comment, @buffer) = ();
  	foreach my $token (@tokens) {
  		if ($token =~ /^[,;]$/) {
  			# if buffer still contains undeterminated strings
  			# append it at the end of @address or @phrase
  			if ($end_of_addr_seen) {
  				push @phrase, @buffer;
  			} else {
  				push @address, @buffer;
  			}
  
  			my $str_phrase = join ' ', @phrase;
  			my $str_address = join '', @address;
  			my $str_comment = join ' ', @comment;
  
  			# quote are necessary if phrase contains
  			# special characters
  			if ($str_phrase =~ /[][()<>:;@\\,.\000-\037\177]/) {
  				$str_phrase =~ s/(^|[^\\])"/$1/g;
  				$str_phrase = qq["$str_phrase"];
  			}
  
  			# add "<>" around the address if necessary
  			if ($str_address ne "" && $str_phrase ne "") {
  				$str_address = qq[<$str_address>];
  			}
  
  			my $str_mailbox = "$str_phrase $str_address $str_comment";
  			$str_mailbox =~ s/^\s*|\s*$//g;
  			push @addr_list, $str_mailbox if ($str_mailbox);
  
  			@phrase = @address = @comment = @buffer = ();
  			$end_of_addr_seen = 0;
  		} elsif ($token =~ /^\(/) {
  			push @comment, $token;
  		} elsif ($token eq "<") {
  			push @phrase, (splice @address), (splice @buffer);
  		} elsif ($token eq ">") {
  			$end_of_addr_seen = 1;
  			push @address, (splice @buffer);
  		} elsif ($token eq "@" && !$end_of_addr_seen) {
  			push @address, (splice @buffer), "@";
  		} else {
  			push @buffer, $token;
  		}
  	}
  
  	return @addr_list;
  }
  
  =item hash_object ( TYPE, FILENAME )
  
  Compute the SHA1 object id of the given C<FILENAME> considering it is
  of the C<TYPE> object type (C<blob>, C<commit>, C<tree>).
  
  The method can be called without any instance or on a specified Git repository,
  it makes zero difference.
  
  The function returns the SHA1 hash.
  
  =cut
  
  # TODO: Support for passing FILEHANDLE instead of FILENAME
  sub hash_object {
  	my ($self, $type, $file) = _maybe_self(@_);
  	command_oneline('hash-object', '-t', $type, $file);
  }
  
  
  =item hash_and_insert_object ( FILENAME )
  
  Compute the SHA1 object id of the given C<FILENAME> and add the object to the
  object database.
  
  The function returns the SHA1 hash.
  
  =cut
  
  # TODO: Support for passing FILEHANDLE instead of FILENAME
  sub hash_and_insert_object {
  	my ($self, $filename) = @_;
  
  	carp "Bad filename \"$filename\"" if $filename =~ /[\r\n]/;
  
  	$self->_open_hash_and_insert_object_if_needed();
  	my ($in, $out) = ($self->{hash_object_in}, $self->{hash_object_out});
  
  	unless (print $out $filename, "\n") {
  		$self->_close_hash_and_insert_object();
  		throw Error::Simple("out pipe went bad");
  	}
  
  	chomp(my $hash = <$in>);
  	unless (defined($hash)) {
  		$self->_close_hash_and_insert_object();
  		throw Error::Simple("in pipe went bad");
  	}
  
  	return $hash;
  }
  
  sub _open_hash_and_insert_object_if_needed {
  	my ($self) = @_;
  
  	return if defined($self->{hash_object_pid});
  
  	($self->{hash_object_pid}, $self->{hash_object_in},
  	 $self->{hash_object_out}, $self->{hash_object_ctx}) =
  		$self->command_bidi_pipe(qw(hash-object -w --stdin-paths --no-filters));
  }
  
  sub _close_hash_and_insert_object {
  	my ($self) = @_;
  
  	return unless defined($self->{hash_object_pid});
  
  	my @vars = map { 'hash_object_' . $_ } qw(pid in out ctx);
  
  	command_close_bidi_pipe(@$self{@vars});
  	delete @$self{@vars};
  }
  
  =item cat_blob ( SHA1, FILEHANDLE )
  
  Prints the contents of the blob identified by C<SHA1> to C<FILEHANDLE> and
  returns the number of bytes printed.
  
  =cut
  
  sub cat_blob {
  	my ($self, $sha1, $fh) = @_;
  
  	$self->_open_cat_blob_if_needed();
  	my ($in, $out) = ($self->{cat_blob_in}, $self->{cat_blob_out});
  
  	unless (print $out $sha1, "\n") {
  		$self->_close_cat_blob();
  		throw Error::Simple("out pipe went bad");
  	}
  
  	my $description = <$in>;
  	if ($description =~ / missing$/) {
  		carp "$sha1 doesn't exist in the repository";
  		return -1;
  	}
  
  	if ($description !~ /^[0-9a-fA-F]{40} \S+ (\d+)$/) {
  		carp "Unexpected result returned from git cat-file";
  		return -1;
  	}
  
  	my $size = $1;
  
  	my $blob;
  	my $bytesLeft = $size;
  
  	while (1) {
  		last unless $bytesLeft;
  
  		my $bytesToRead = $bytesLeft < 1024 ? $bytesLeft : 1024;
  		my $read = read($in, $blob, $bytesToRead);
  		unless (defined($read)) {
  			$self->_close_cat_blob();
  			throw Error::Simple("in pipe went bad");
  		}
  		unless (print $fh $blob) {
  			$self->_close_cat_blob();
  			throw Error::Simple("couldn't write to passed in filehandle");
  		}
  		$bytesLeft -= $read;
  	}
  
  	# Skip past the trailing newline.
  	my $newline;
  	my $read = read($in, $newline, 1);
  	unless (defined($read)) {
  		$self->_close_cat_blob();
  		throw Error::Simple("in pipe went bad");
  	}
  	unless ($read == 1 && $newline eq "\n") {
  		$self->_close_cat_blob();
  		throw Error::Simple("didn't find newline after blob");
  	}
  
  	return $size;
  }
  
  sub _open_cat_blob_if_needed {
  	my ($self) = @_;
  
  	return if defined($self->{cat_blob_pid});
  
  	($self->{cat_blob_pid}, $self->{cat_blob_in},
  	 $self->{cat_blob_out}, $self->{cat_blob_ctx}) =
  		$self->command_bidi_pipe(qw(cat-file --batch));
  }
  
  sub _close_cat_blob {
  	my ($self) = @_;
  
  	return unless defined($self->{cat_blob_pid});
  
  	my @vars = map { 'cat_blob_' . $_ } qw(pid in out ctx);
  
  	command_close_bidi_pipe(@$self{@vars});
  	delete @$self{@vars};
  }
  
  
  =item credential_read( FILEHANDLE )
  
  Reads credential key-value pairs from C<FILEHANDLE>.  Reading stops at EOF or
  when an empty line is encountered.  Each line must be of the form C<key=value>
  with a non-empty key.  Function returns hash with all read values.  Any white
  space (other than new-line character) is preserved.
  
  =cut
  
  sub credential_read {
  	my ($self, $reader) = _maybe_self(@_);
  	my %credential;
  	while (<$reader>) {
  		chomp;
  		if ($_ eq '') {
  			last;
  		} elsif (!/^([^=]+)=(.*)$/) {
  			throw Error::Simple("unable to parse git credential data:\n$_");
  		}
  		$credential{$1} = $2;
  	}
  	return %credential;
  }
  
  =item credential_write( FILEHANDLE, CREDENTIAL_HASHREF )
  
  Writes credential key-value pairs from hash referenced by
  C<CREDENTIAL_HASHREF> to C<FILEHANDLE>.  Keys and values cannot contain
  new-lines or NUL bytes characters, and key cannot contain equal signs nor be
  empty (if they do Error::Simple is thrown).  Any white space is preserved.  If
  value for a key is C<undef>, it will be skipped.
  
  If C<'url'> key exists it will be written first.  (All the other key-value
  pairs are written in sorted order but you should not depend on that).  Once
  all lines are written, an empty line is printed.
  
  =cut
  
  sub credential_write {
  	my ($self, $writer, $credential) = _maybe_self(@_);
  	my ($key, $value);
  
  	# Check if $credential is valid prior to writing anything
  	while (($key, $value) = each %$credential) {
  		if (!defined $key || !length $key) {
  			throw Error::Simple("credential key empty or undefined");
  		} elsif ($key =~ /[=\n\0]/) {
  			throw Error::Simple("credential key contains invalid characters: $key");
  		} elsif (defined $value && $value =~ /[\n\0]/) {
  			throw Error::Simple("credential value for key=$key contains invalid characters: $value");
  		}
  	}
  
  	for $key (sort {
  		# url overwrites other fields, so it must come first
  		return -1 if $a eq 'url';
  		return  1 if $b eq 'url';
  		return $a cmp $b;
  	} keys %$credential) {
  		if (defined $credential->{$key}) {
  			print $writer $key, '=', $credential->{$key}, "\n";
  		}
  	}
  	print $writer "\n";
  }
  
  sub _credential_run {
  	my ($self, $credential, $op) = _maybe_self(@_);
  	my ($pid, $reader, $writer, $ctx) = command_bidi_pipe('credential', $op);
  
  	credential_write $writer, $credential;
  	close $writer;
  
  	if ($op eq "fill") {
  		%$credential = credential_read $reader;
  	}
  	if (<$reader>) {
  		throw Error::Simple("unexpected output from git credential $op response:\n$_\n");
  	}
  
  	command_close_bidi_pipe($pid, $reader, undef, $ctx);
  }
  
  =item credential( CREDENTIAL_HASHREF [, OPERATION ] )
  
  =item credential( CREDENTIAL_HASHREF, CODE )
  
  Executes C<git credential> for a given set of credentials and specified
  operation.  In both forms C<CREDENTIAL_HASHREF> needs to be a reference to
  a hash which stores credentials.  Under certain conditions the hash can
  change.
  
  In the first form, C<OPERATION> can be C<'fill'>, C<'approve'> or C<'reject'>,
  and function will execute corresponding C<git credential> sub-command.  If
  it's omitted C<'fill'> is assumed.  In case of C<'fill'> the values stored in
  C<CREDENTIAL_HASHREF> will be changed to the ones returned by the C<git
  credential fill> command.  The usual usage would look something like:
  
  	my %cred = (
  		'protocol' => 'https',
  		'host' => 'example.com',
  		'username' => 'bob'
  	);
  	Git::credential \%cred;
  	if (try_to_authenticate($cred{'username'}, $cred{'password'})) {
  		Git::credential \%cred, 'approve';
  		... do more stuff ...
  	} else {
  		Git::credential \%cred, 'reject';
  	}
  
  In the second form, C<CODE> needs to be a reference to a subroutine.  The
  function will execute C<git credential fill> to fill the provided credential
  hash, then call C<CODE> with C<CREDENTIAL_HASHREF> as the sole argument.  If
  C<CODE>'s return value is defined, the function will execute C<git credential
  approve> (if return value yields true) or C<git credential reject> (if return
  value is false).  If the return value is undef, nothing at all is executed;
  this is useful, for example, if the credential could neither be verified nor
  rejected due to an unrelated network error.  The return value is the same as
  what C<CODE> returns.  With this form, the usage might look as follows:
  
  	if (Git::credential {
  		'protocol' => 'https',
  		'host' => 'example.com',
  		'username' => 'bob'
  	}, sub {
  		my $cred = shift;
  		return !!try_to_authenticate($cred->{'username'},
  		                             $cred->{'password'});
  	}) {
  		... do more stuff ...
  	}
  
  =cut
  
  sub credential {
  	my ($self, $credential, $op_or_code) = (_maybe_self(@_), 'fill');
  
  	if ('CODE' eq ref $op_or_code) {
  		_credential_run $credential, 'fill';
  		my $ret = $op_or_code->($credential);
  		if (defined $ret) {
  			_credential_run $credential, $ret ? 'approve' : 'reject';
  		}
  		return $ret;
  	} else {
  		_credential_run $credential, $op_or_code;
  	}
  }
  
  { # %TEMP_* Lexical Context
  
  my (%TEMP_FILEMAP, %TEMP_FILES);
  
  =item temp_acquire ( NAME )
  
  Attempts to retrieve the temporary file mapped to the string C<NAME>. If an
  associated temp file has not been created this session or was closed, it is
  created, cached, and set for autoflush and binmode.
  
  Internally locks the file mapped to C<NAME>. This lock must be released with
  C<temp_release()> when the temp file is no longer needed. Subsequent attempts
  to retrieve temporary files mapped to the same C<NAME> while still locked will
  cause an error. This locking mechanism provides a weak guarantee and is not
  threadsafe. It does provide some error checking to help prevent temp file refs
  writing over one another.
  
  In general, the L<File::Handle> returned should not be closed by consumers as
  it defeats the purpose of this caching mechanism. If you need to close the temp
  file handle, then you should use L<File::Temp> or another temp file faculty
  directly. If a handle is closed and then requested again, then a warning will
  issue.
  
  =cut
  
  sub temp_acquire {
  	my $temp_fd = _temp_cache(@_);
  
  	$TEMP_FILES{$temp_fd}{locked} = 1;
  	$temp_fd;
  }
  
  =item temp_is_locked ( NAME )
  
  Returns true if the internal lock created by a previous C<temp_acquire()>
  call with C<NAME> is still in effect.
  
  When temp_acquire is called on a C<NAME>, it internally locks the temporary
  file mapped to C<NAME>.  That lock will not be released until C<temp_release()>
  is called with either the original C<NAME> or the L<File::Handle> that was
  returned from the original call to temp_acquire.
  
  Subsequent attempts to call C<temp_acquire()> with the same C<NAME> will fail
  unless there has been an intervening C<temp_release()> call for that C<NAME>
  (or its corresponding L<File::Handle> that was returned by the original
  C<temp_acquire()> call).
  
  If true is returned by C<temp_is_locked()> for a C<NAME>, an attempt to
  C<temp_acquire()> the same C<NAME> will cause an error unless
  C<temp_release> is first called on that C<NAME> (or its corresponding
  L<File::Handle> that was returned by the original C<temp_acquire()> call).
  
  =cut
  
  sub temp_is_locked {
  	my ($self, $name) = _maybe_self(@_);
  	my $temp_fd = \$TEMP_FILEMAP{$name};
  
  	defined $$temp_fd && $$temp_fd->opened && $TEMP_FILES{$$temp_fd}{locked};
  }
  
  =item temp_release ( NAME )
  
  =item temp_release ( FILEHANDLE )
  
  Releases a lock acquired through C<temp_acquire()>. Can be called either with
  the C<NAME> mapping used when acquiring the temp file or with the C<FILEHANDLE>
  referencing a locked temp file.
  
  Warns if an attempt is made to release a file that is not locked.
  
  The temp file will be truncated before being released. This can help to reduce
  disk I/O where the system is smart enough to detect the truncation while data
  is in the output buffers. Beware that after the temp file is released and
  truncated, any operations on that file may fail miserably until it is
  re-acquired. All contents are lost between each release and acquire mapped to
  the same string.
  
  =cut
  
  sub temp_release {
  	my ($self, $temp_fd, $trunc) = _maybe_self(@_);
  
  	if (exists $TEMP_FILEMAP{$temp_fd}) {
  		$temp_fd = $TEMP_FILES{$temp_fd};
  	}
  	unless ($TEMP_FILES{$temp_fd}{locked}) {
  		carp "Attempt to release temp file '",
  			$temp_fd, "' that has not been locked";
  	}
  	temp_reset($temp_fd) if $trunc and $temp_fd->opened;
  
  	$TEMP_FILES{$temp_fd}{locked} = 0;
  	undef;
  }
  
  sub _temp_cache {
  	my ($self, $name) = _maybe_self(@_);
  
  	_verify_require();
  
  	my $temp_fd = \$TEMP_FILEMAP{$name};
  	if (defined $$temp_fd and $$temp_fd->opened) {
  		if ($TEMP_FILES{$$temp_fd}{locked}) {
  			throw Error::Simple("Temp file with moniker '" .
  				$name . "' already in use");
  		}
  	} else {
  		if (defined $$temp_fd) {
  			# then we're here because of a closed handle.
  			carp "Temp file '", $name,
  				"' was closed. Opening replacement.";
  		}
  		my $fname;
  
  		my $tmpdir;
  		if (defined $self) {
  			$tmpdir = $self->repo_path();
  		}
  
  		my $n = $name;
  		$n =~ s/\W/_/g; # no strange chars
  
  		($$temp_fd, $fname) = File::Temp::tempfile(
  			"Git_${n}_XXXXXX", UNLINK => 1, DIR => $tmpdir,
  			) or throw Error::Simple("couldn't open new temp file");
  
  		$$temp_fd->autoflush;
  		binmode $$temp_fd;
  		$TEMP_FILES{$$temp_fd}{fname} = $fname;
  	}
  	$$temp_fd;
  }
  
  sub _verify_require {
  	eval { require File::Temp; require File::Spec; };
  	$@ and throw Error::Simple($@);
  }
  
  =item temp_reset ( FILEHANDLE )
  
  Truncates and resets the position of the C<FILEHANDLE>.
  
  =cut
  
  sub temp_reset {
  	my ($self, $temp_fd) = _maybe_self(@_);
  
  	truncate $temp_fd, 0
  		or throw Error::Simple("couldn't truncate file");
  	sysseek($temp_fd, 0, SEEK_SET) and seek($temp_fd, 0, SEEK_SET)
  		or throw Error::Simple("couldn't seek to beginning of file");
  	sysseek($temp_fd, 0, SEEK_CUR) == 0 and tell($temp_fd) == 0
  		or throw Error::Simple("expected file position to be reset");
  }
  
  =item temp_path ( NAME )
  
  =item temp_path ( FILEHANDLE )
  
  Returns the filename associated with the given tempfile.
  
  =cut
  
  sub temp_path {
  	my ($self, $temp_fd) = _maybe_self(@_);
  
  	if (exists $TEMP_FILEMAP{$temp_fd}) {
  		$temp_fd = $TEMP_FILEMAP{$temp_fd};
  	}
  	$TEMP_FILES{$temp_fd}{fname};
  }
  
  sub END {
  	unlink values %TEMP_FILEMAP if %TEMP_FILEMAP;
  }
  
  } # %TEMP_* Lexical Context
  
  =item prefix_lines ( PREFIX, STRING [, STRING... ])
  
  Prefixes lines in C<STRING> with C<PREFIX>.
  
  =cut
  
  sub prefix_lines {
  	my $prefix = shift;
  	my $string = join("\n", @_);
  	$string =~ s/^/$prefix/mg;
  	return $string;
  }
  
  =item unquote_path ( PATH )
  
  Unquote a quoted path containing c-escapes as returned by ls-files etc.
  when not using -z or when parsing the output of diff -u.
  
  =cut
  
  {
  	my %cquote_map = (
  		"a" => chr(7),
  		"b" => chr(8),
  		"t" => chr(9),
  		"n" => chr(10),
  		"v" => chr(11),
  		"f" => chr(12),
  		"r" => chr(13),
  		"\\" => "\\",
  		"\042" => "\042",
  	);
  
  	sub unquote_path {
  		local ($_) = @_;
  		my ($retval, $remainder);
  		if (!/^\042(.*)\042$/) {
  			return $_;
  		}
  		($_, $retval) = ($1, "");
  		while (/^([^\\]*)\\(.*)$/) {
  			$remainder = $2;
  			$retval .= $1;
  			for ($remainder) {
  				if (/^([0-3][0-7][0-7])(.*)$/) {
  					$retval .= chr(oct($1));
  					$_ = $2;
  					last;
  				}
  				if (/^([\\\042abtnvfr])(.*)$/) {
  					$retval .= $cquote_map{$1};
  					$_ = $2;
  					last;
  				}
  				# This is malformed
  				throw Error::Simple("invalid quoted path $_[0]");
  			}
  			$_ = $remainder;
  		}
  		$retval .= $_;
  		return $retval;
  	}
  }
  
  =item get_comment_line_char ( )
  
  Gets the core.commentchar configuration value.
  The value falls-back to '#' if core.commentchar is set to 'auto'.
  
  =cut
  
  sub get_comment_line_char {
  	my $comment_line_char = config("core.commentchar") || '#';
  	$comment_line_char = '#' if ($comment_line_char eq 'auto');
  	$comment_line_char = '#' if (length($comment_line_char) != 1);
  	return $comment_line_char;
  }
  
  =item comment_lines ( STRING [, STRING... ])
  
  Comments lines following core.commentchar configuration.
  
  =cut
  
  sub comment_lines {
  	my $comment_line_char = get_comment_line_char;
  	return prefix_lines("$comment_line_char ", @_);
  }
  
  =back
  
  =head1 ERROR HANDLING
  
  All functions are supposed to throw Perl exceptions in case of errors.
  See the L<Error> module on how to catch those. Most exceptions are mere
  L<Error::Simple> instances.
  
  However, the C<command()>, C<command_oneline()> and C<command_noisy()>
  functions suite can throw C<Git::Error::Command> exceptions as well: those are
  thrown when the external command returns an error code and contain the error
  code as well as access to the captured command's output. The exception class
  provides the usual C<stringify> and C<value> (command's exit code) methods and
  in addition also a C<cmd_output> method that returns either an array or a
  string with the captured command output (depending on the original function
  call context; C<command_noisy()> returns C<undef>) and $<cmdline> which
  returns the command and its arguments (but without proper quoting).
  
  Note that the C<command_*_pipe()> functions cannot throw this exception since
  it has no idea whether the command failed or not. You will only find out
  at the time you C<close> the pipe; if you want to have that automated,
  use C<command_close_pipe()>, which can throw the exception.
  
  =cut
  
  {
  	package Git::Error::Command;
  
  	@Git::Error::Command::ISA = qw(Error);
  
  	sub new {
  		my $self = shift;
  		my $cmdline = '' . shift;
  		my $value = 0 + shift;
  		my $outputref = shift;
  		my(@args) = ();
  
  		local $Error::Depth = $Error::Depth + 1;
  
  		push(@args, '-cmdline', $cmdline);
  		push(@args, '-value', $value);
  		push(@args, '-outputref', $outputref);
  
  		$self->SUPER::new(-text => 'command returned error', @args);
  	}
  
  	sub stringify {
  		my $self = shift;
  		my $text = $self->SUPER::stringify;
  		$self->cmdline() . ': ' . $text . ': ' . $self->value() . "\n";
  	}
  
  	sub cmdline {
  		my $self = shift;
  		$self->{'-cmdline'};
  	}
  
  	sub cmd_output {
  		my $self = shift;
  		my $ref = $self->{'-outputref'};
  		defined $ref or undef;
  		if (ref $ref eq 'ARRAY') {
  			return @$ref;
  		} else { # SCALAR
  			return $$ref;
  		}
  	}
  }
  
  =over 4
  
  =item git_cmd_try { CODE } ERRMSG
  
  This magical statement will automatically catch any C<Git::Error::Command>
  exceptions thrown by C<CODE> and make your program die with C<ERRMSG>
  on its lips; the message will have %s substituted for the command line
  and %d for the exit status. This statement is useful mostly for producing
  more user-friendly error messages.
  
  In case of no exception caught the statement returns C<CODE>'s return value.
  
  Note that this is the only auto-exported function.
  
  =cut
  
  sub git_cmd_try(&$) {
  	my ($code, $errmsg) = @_;
  	my @result;
  	my $err;
  	my $array = wantarray;
  	try {
  		if ($array) {
  			@result = &$code;
  		} else {
  			$result[0] = &$code;
  		}
  	} catch Git::Error::Command with {
  		my $E = shift;
  		$err = $errmsg;
  		$err =~ s/\%s/$E->cmdline()/ge;
  		$err =~ s/\%d/$E->value()/ge;
  		# We can't croak here since Error.pm would mangle
  		# that to Error::Simple.
  	};
  	$err and croak $err;
  	return $array ? @result : $result[0];
  }
  
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2006 by Petr Baudis E<lt>pasky@suse.czE<gt>.
  
  This module is free software; it may be used, copied, modified
  and distributed under the terms of the GNU General Public Licence,
  either version 2, or (at your option) any later version.
  
  =cut
  
  
  # Take raw method argument list and return ($obj, @args) in case
  # the method was called upon an instance and (undef, @args) if
  # it was called directly.
  sub _maybe_self {
  	UNIVERSAL::isa($_[0], 'Git') ? @_ : (undef, @_);
  }
  
  # Check if the command id is something reasonable.
  sub _check_valid_cmd {
  	my ($cmd) = @_;
  	$cmd =~ /^[a-z0-9A-Z_-]+$/ or throw Error::Simple("bad command: $cmd");
  }
  
  # Common backend for the pipe creators.
  sub _command_common_pipe {
  	my $direction = shift;
  	my ($self, @p) = _maybe_self(@_);
  	my (%opts, $cmd, @args);
  	if (ref $p[0]) {
  		($cmd, @args) = @{shift @p};
  		%opts = ref $p[0] ? %{$p[0]} : @p;
  	} else {
  		($cmd, @args) = @p;
  	}
  	_check_valid_cmd($cmd);
  
  	my $fh;
  	if ($^O eq 'MSWin32') {
  		# ActiveState Perl
  		#defined $opts{STDERR} and
  		#	warn 'ignoring STDERR option - running w/ ActiveState';
  		$direction eq '-|' or
  			die 'input pipe for ActiveState not implemented';
  		# the strange construction with *ACPIPE is just to
  		# explain the tie below that we want to bind to
  		# a handle class, not scalar. It is not known if
  		# it is something specific to ActiveState Perl or
  		# just a Perl quirk.
  		tie (*ACPIPE, 'Git::activestate_pipe', $cmd, @args);
  		$fh = *ACPIPE;
  
  	} else {
  		my $pid = open($fh, $direction);
  		if (not defined $pid) {
  			throw Error::Simple("open failed: $!");
  		} elsif ($pid == 0) {
  			if ($opts{STDERR}) {
  				open (STDERR, '>&', $opts{STDERR})
  					or die "dup failed: $!";
  			} elsif (defined $opts{STDERR}) {
  				open (STDERR, '>', '/dev/null')
  					or die "opening /dev/null failed: $!";
  			}
  			_cmd_exec($self, $cmd, @args);
  		}
  	}
  	return wantarray ? ($fh, join(' ', $cmd, @args)) : $fh;
  }
  
  # When already in the subprocess, set up the appropriate state
  # for the given repository and execute the git command.
  sub _cmd_exec {
  	my ($self, @args) = @_;
  	_setup_git_cmd_env($self);
  	_execv_git_cmd(@args);
  	die qq[exec "@args" failed: $!];
  }
  
  # set up the appropriate state for git command
  sub _setup_git_cmd_env {
  	my $self = shift;
  	if ($self) {
  		$self->repo_path() and $ENV{'GIT_DIR'} = $self->repo_path();
  		$self->repo_path() and $self->wc_path()
  			and $ENV{'GIT_WORK_TREE'} = $self->wc_path();
  		$self->wc_path() and chdir($self->wc_path());
  		$self->wc_subdir() and chdir($self->wc_subdir());
  	}
  }
  
  # Execute the given Git command ($_[0]) with arguments ($_[1..])
  # by searching for it at proper places.
  sub _execv_git_cmd { exec('git', @_); }
  
  # Close pipe to a subprocess.
  sub _cmd_close {
  	my $ctx = shift @_;
  	foreach my $fh (@_) {
  		if (close $fh) {
  			# nop
  		} elsif ($!) {
  			# It's just close, no point in fatalities
  			carp "error closing pipe: $!";
  		} elsif ($? >> 8) {
  			# The caller should pepper this.
  			throw Git::Error::Command($ctx, $? >> 8);
  		}
  		# else we might e.g. closed a live stream; the command
  		# dying of SIGPIPE would drive us here.
  	}
  }
  
  
  sub DESTROY {
  	my ($self) = @_;
  	$self->_close_hash_and_insert_object();
  	$self->_close_cat_blob();
  }
  
  
  # Pipe implementation for ActiveState Perl.
  
  package Git::activestate_pipe;
  use strict;
  
  sub TIEHANDLE {
  	my ($class, @params) = @_;
  	# FIXME: This is probably horrible idea and the thing will explode
  	# at the moment you give it arguments that require some quoting,
  	# but I have no ActiveState clue... --pasky
  	# Let's just hope ActiveState Perl does at least the quoting
  	# correctly.
  	my @data = qx{git @params};
  	bless { i => 0, data => \@data }, $class;
  }
  
  sub READLINE {
  	my $self = shift;
  	if ($self->{i} >= scalar @{$self->{data}}) {
  		return undef;
  	}
  	my $i = $self->{i};
  	if (wantarray) {
  		$self->{i} = $#{$self->{'data'}} + 1;
  		return splice(@{$self->{'data'}}, $i);
  	}
  	$self->{i} = $i + 1;
  	return $self->{'data'}->[ $i ];
  }
  
  sub CLOSE {
  	my $self = shift;
  	delete $self->{data};
  	delete $self->{i};
  }
  
  sub EOF {
  	my $self = shift;
  	return ($self->{i} >= scalar @{$self->{data}});
  }
  
  
  1; # Famous last words
GIT

$fatpacked{"Git/I18N.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_I18N';
  package Git::I18N;
  use 5.008;
  use strict;
  use warnings;
  BEGIN {
  	require Exporter;
  	if ($] < 5.008003) {
  		*import = \&Exporter::import;
  	} else {
  		# Exporter 5.57 which supports this invocation was
  		# released with perl 5.8.3
  		Exporter->import('import');
  	}
  }
  
  our @EXPORT = qw(__ __n N__);
  our @EXPORT_OK = @EXPORT;
  
  sub __bootstrap_locale_messages {
  	our $TEXTDOMAIN = 'git';
  	our $TEXTDOMAINDIR = $ENV{GIT_TEXTDOMAINDIR} || '++LOCALEDIR++';
  
  	require POSIX;
  	POSIX->import(qw(setlocale));
  	# Non-core prerequisite module
  	require Locale::Messages;
  	Locale::Messages->import(qw(:locale_h :libintl_h));
  
  	setlocale(LC_MESSAGES(), '');
  	setlocale(LC_CTYPE(), '');
  	textdomain($TEXTDOMAIN);
  	bindtextdomain($TEXTDOMAIN => $TEXTDOMAINDIR);
  
  	return;
  }
  
  BEGIN
  {
  	# Used by our test script to see if it should test fallbacks or
  	# not.
  	our $__HAS_LIBRARY = 1;
  
  	local $@;
  	eval {
  		__bootstrap_locale_messages();
  		*__ = \&Locale::Messages::gettext;
  		*__n = \&Locale::Messages::ngettext;
  		1;
  	} or do {
  		# Tell test.pl that we couldn't load the gettext library.
  		$Git::I18N::__HAS_LIBRARY = 0;
  
  		# Just a fall-through no-op
  		*__ = sub ($) { $_[0] };
  		*__n = sub ($$$) { $_[2] == 1 ? $_[0] : $_[1] };
  	};
  
  	sub N__($) { return shift; }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Git::I18N - Perl interface to Git's Gettext localizations
  
  =head1 SYNOPSIS
  
  	use Git::I18N;
  
  	print __("Welcome to Git!\n");
  
  	printf __("The following error occurred: %s\n"), $error;
  
  	printf __n("committed %d file\n", "committed %d files\n", $files), $files;
  
  
  =head1 DESCRIPTION
  
  Git's internal Perl interface to gettext via L<Locale::Messages>. If
  L<Locale::Messages> can't be loaded (it's not a core module) we
  provide stub passthrough fallbacks.
  
  This is a distilled interface to gettext, see C<info '(gettext)Perl'>
  for the full interface. This module implements only a small part of
  it.
  
  =head1 FUNCTIONS
  
  =head2 __($)
  
  L<Locale::Messages>'s gettext function if all goes well, otherwise our
  passthrough fallback function.
  
  =head2 __n($$$)
  
  L<Locale::Messages>'s ngettext function or passthrough fallback function.
  
  =head2 N__($)
  
  No-operation that only returns its argument. Use this if you want xgettext to
  extract the text to the pot template but do not want to trigger retrival of the
  translation at run time.
  
  =head1 AUTHOR
  
  E<AElig>var ArnfjE<ouml>rE<eth> Bjarmason <avarab@gmail.com>
  
  =head1 COPYRIGHT
  
  Copyright 2010 E<AElig>var ArnfjE<ouml>rE<eth> Bjarmason <avarab@gmail.com>
  
  =cut
GIT_I18N

$fatpacked{"Git/IndexInfo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_INDEXINFO';
  package Git::IndexInfo;
  use strict;
  use warnings;
  use Git qw/command_input_pipe command_close_pipe/;
  
  sub new {
  	my ($class) = @_;
  	my ($gui, $ctx) = command_input_pipe(qw/update-index -z --index-info/);
  	bless { gui => $gui, ctx => $ctx, nr => 0}, $class;
  }
  
  sub remove {
  	my ($self, $path) = @_;
  	if (print { $self->{gui} } '0 ', 0 x 40, "\t", $path, "\0") {
  		return ++$self->{nr};
  	}
  	undef;
  }
  
  sub update {
  	my ($self, $mode, $hash, $path) = @_;
  	if (print { $self->{gui} } $mode, ' ', $hash, "\t", $path, "\0") {
  		return ++$self->{nr};
  	}
  	undef;
  }
  
  sub DESTROY {
  	my ($self) = @_;
  	command_close_pipe($self->{gui}, $self->{ctx});
  }
  
  1;
GIT_INDEXINFO

$fatpacked{"Git/SVN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN';
  package Git::SVN;
  use strict;
  use warnings;
  use Fcntl qw/:DEFAULT :seek/;
  use constant rev_map_fmt => 'NH40';
  use vars qw/$_no_metadata
              $_repack $_repack_flags $_use_svm_props $_head
              $_use_svnsync_props $no_reuse_existing
  	    $_use_log_author $_add_author_from $_localtime/;
  use Carp qw/croak/;
  use File::Path qw/mkpath/;
  use IPC::Open3;
  use Memoize;  # core since 5.8.0, Jul 2002
  use POSIX qw(:signal_h);
  use Time::Local;
  
  use Git qw(
      command
      command_oneline
      command_noisy
      command_output_pipe
      command_close_pipe
      get_tz_offset
  );
  use Git::SVN::Utils qw(
  	fatal
  	can_compress
  	join_paths
  	canonicalize_path
  	canonicalize_url
  	add_path_to_url
  );
  
  my $memo_backend;
  our $_follow_parent  = 1;
  our $_minimize_url   = 'unset';
  our $default_repo_id = 'svn';
  our $default_ref_id  = $ENV{GIT_SVN_ID} || 'git-svn';
  
  my ($_gc_nr, $_gc_period);
  
  # properties that we do not log:
  my %SKIP_PROP;
  BEGIN {
  	%SKIP_PROP = map { $_ => 1 } qw/svn:wc:ra_dav:version-url
  	                                svn:special svn:executable
  	                                svn:entry:committed-rev
  	                                svn:entry:last-author
  	                                svn:entry:uuid
  	                                svn:entry:committed-date/;
  
  	# some options are read globally, but can be overridden locally
  	# per [svn-remote "..."] section.  Command-line options will *NOT*
  	# override options set in an [svn-remote "..."] section
  	no strict 'refs';
  	for my $option (qw/follow_parent no_metadata use_svm_props
  			   use_svnsync_props/) {
  		my $key = $option;
  		$key =~ tr/_//d;
  		my $prop = "-$option";
  		*$option = sub {
  			my ($self) = @_;
  			return $self->{$prop} if exists $self->{$prop};
  			my $k = "svn-remote.$self->{repo_id}.$key";
  			eval { command_oneline(qw/config --get/, $k) };
  			if ($@) {
  				$self->{$prop} = ${"Git::SVN::_$option"};
  			} else {
  				my $v = command_oneline(qw/config --bool/,$k);
  				$self->{$prop} = $v eq 'false' ? 0 : 1;
  			}
  			return $self->{$prop};
  		}
  	}
  }
  
  
  my (%LOCKFILES, %INDEX_FILES);
  END {
  	unlink keys %LOCKFILES if %LOCKFILES;
  	unlink keys %INDEX_FILES if %INDEX_FILES;
  }
  
  sub resolve_local_globs {
  	my ($url, $fetch, $glob_spec) = @_;
  	return unless defined $glob_spec;
  	my $ref = $glob_spec->{ref};
  	my $path = $glob_spec->{path};
  	foreach (command(qw#for-each-ref --format=%(refname) refs/#)) {
  		next unless m#^$ref->{regex}$#;
  		my $p = $1;
  		my $pathname = desanitize_refname($path->full_path($p));
  		my $refname = desanitize_refname($ref->full_path($p));
  		if (my $existing = $fetch->{$pathname}) {
  			if ($existing ne $refname) {
  				die "Refspec conflict:\n",
  				    "existing: $existing\n",
  				    " globbed: $refname\n";
  			}
  			my $u = (::cmt_metadata("$refname"))[0];
  			if (!defined($u)) {
  				warn
  "W: $refname: no associated commit metadata from SVN, skipping\n";
  				next;
  			}
  			$u =~ s!^\Q$url\E(/|$)!! or die
  			  "$refname: '$url' not found in '$u'\n";
  			if ($pathname ne $u) {
  				warn "W: Refspec glob conflict ",
  				     "(ref: $refname):\n",
  				     "expected path: $pathname\n",
  				     "    real path: $u\n",
  				     "Continuing ahead with $u\n";
  				next;
  			}
  		} else {
  			$fetch->{$pathname} = $refname;
  		}
  	}
  }
  
  sub parse_revision_argument {
  	my ($base, $head) = @_;
  	if (!defined $::_revision || $::_revision eq 'BASE:HEAD') {
  		return ($base, $head);
  	}
  	return ($1, $2) if ($::_revision =~ /^(\d+):(\d+)$/);
  	return ($::_revision, $::_revision) if ($::_revision =~ /^\d+$/);
  	return ($head, $head) if ($::_revision eq 'HEAD');
  	return ($base, $1) if ($::_revision =~ /^BASE:(\d+)$/);
  	return ($1, $head) if ($::_revision =~ /^(\d+):HEAD$/);
  	die "revision argument: $::_revision not understood by git-svn\n";
  }
  
  sub fetch_all {
  	my ($repo_id, $remotes) = @_;
  	if (ref $repo_id) {
  		my $gs = $repo_id;
  		$repo_id = undef;
  		$repo_id = $gs->{repo_id};
  	}
  	$remotes ||= read_all_remotes();
  	my $remote = $remotes->{$repo_id} or
  	             die "[svn-remote \"$repo_id\"] unknown\n";
  	my $fetch = $remote->{fetch};
  	my $url = $remote->{url} or die "svn-remote.$repo_id.url not defined\n";
  	my (@gs, @globs);
  	my $ra = Git::SVN::Ra->new($url);
  	my $uuid = $ra->get_uuid;
  	my $head = $ra->get_latest_revnum;
  
  	# ignore errors, $head revision may not even exist anymore
  	eval { $ra->get_log("", $head, 0, 1, 0, 1, sub { $head = $_[1] }) };
  	warn "W: $@\n" if $@;
  
  	my $base = defined $fetch ? $head : 0;
  
  	# read the max revs for wildcard expansion (branches/*, tags/*)
  	foreach my $t (qw/branches tags/) {
  		defined $remote->{$t} or next;
  		push @globs, @{$remote->{$t}};
  
  		my $max_rev = eval { tmp_config(qw/--int --get/,
  		                         "svn-remote.$repo_id.${t}-maxRev") };
  		if (defined $max_rev && ($max_rev < $base)) {
  			$base = $max_rev;
  		} elsif (!defined $max_rev) {
  			$base = 0;
  		}
  	}
  
  	if ($fetch) {
  		foreach my $p (sort keys %$fetch) {
  			my $gs = Git::SVN->new($fetch->{$p}, $repo_id, $p);
  			my $lr = $gs->rev_map_max;
  			if (defined $lr) {
  				$base = $lr if ($lr < $base);
  			}
  			push @gs, $gs;
  		}
  	}
  
  	($base, $head) = parse_revision_argument($base, $head);
  	$ra->gs_fetch_loop_common($base, $head, \@gs, \@globs);
  }
  
  sub read_all_remotes {
  	my $r = {};
  	my $use_svm_props = eval { command_oneline(qw/config --bool
  	    svn.useSvmProps/) };
  	$use_svm_props = $use_svm_props eq 'true' if $use_svm_props;
  	my $svn_refspec = qr{\s*(.*?)\s*:\s*(.+?)\s*};
  	foreach (grep { s/^svn-remote\.// } command(qw/config -l/)) {
  		if (m!^(.+)\.fetch=$svn_refspec$!) {
  			my ($remote, $local_ref, $remote_ref) = ($1, $2, $3);
  			die("svn-remote.$remote: remote ref '$remote_ref' "
  			    . "must start with 'refs/'\n")
  				unless $remote_ref =~ m{^refs/};
  			$local_ref = uri_decode($local_ref);
  			$r->{$remote}->{fetch}->{$local_ref} = $remote_ref;
  			$r->{$remote}->{svm} = {} if $use_svm_props;
  		} elsif (m!^(.+)\.usesvmprops=\s*(.*)\s*$!) {
  			$r->{$1}->{svm} = {};
  		} elsif (m!^(.+)\.url=\s*(.*)\s*$!) {
  			$r->{$1}->{url} = canonicalize_url($2);
  		} elsif (m!^(.+)\.pushurl=\s*(.*)\s*$!) {
  			$r->{$1}->{pushurl} = canonicalize_url($2);
  		} elsif (m!^(.+)\.ignore-refs=\s*(.*)\s*$!) {
  			$r->{$1}->{ignore_refs_regex} = $2;
  		} elsif (m!^(.+)\.(branches|tags)=$svn_refspec$!) {
  			my ($remote, $t, $local_ref, $remote_ref) =
  			                                     ($1, $2, $3, $4);
  			die("svn-remote.$remote: remote ref '$remote_ref' ($t) "
  			    . "must start with 'refs/'\n")
  				unless $remote_ref =~ m{^refs/};
  			$local_ref = uri_decode($local_ref);
  
  			require Git::SVN::GlobSpec;
  			my $rs = {
  			    t => $t,
  			    remote => $remote,
  			    path => Git::SVN::GlobSpec->new($local_ref, 1),
  			    ref => Git::SVN::GlobSpec->new($remote_ref, 0) };
  			if (length($rs->{ref}->{right}) != 0) {
  				die "The '*' glob character must be the last ",
  				    "character of '$remote_ref'\n";
  			}
  			push @{ $r->{$remote}->{$t} }, $rs;
  		}
  	}
  
  	map {
  		if (defined $r->{$_}->{svm}) {
  			my $svm;
  			eval {
  				my $section = "svn-remote.$_";
  				$svm = {
  					source => tmp_config('--get',
  					    "$section.svm-source"),
  					replace => tmp_config('--get',
  					    "$section.svm-replace"),
  				}
  			};
  			$r->{$_}->{svm} = $svm;
  		}
  	} keys %$r;
  
  	foreach my $remote (keys %$r) {
  		foreach ( grep { defined $_ }
  			  map { $r->{$remote}->{$_} } qw(branches tags) ) {
  			foreach my $rs ( @$_ ) {
  				$rs->{ignore_refs_regex} =
  				    $r->{$remote}->{ignore_refs_regex};
  			}
  		}
  	}
  
  	$r;
  }
  
  sub init_vars {
  	$_gc_nr = $_gc_period = 1000;
  	if (defined $_repack || defined $_repack_flags) {
  	       warn "Repack options are obsolete; they have no effect.\n";
  	}
  }
  
  sub verify_remotes_sanity {
  	return unless -d $ENV{GIT_DIR};
  	my %seen;
  	foreach (command(qw/config -l/)) {
  		if (m!^svn-remote\.(?:.+)\.fetch=.*:refs/remotes/(\S+)\s*$!) {
  			if ($seen{$1}) {
  				die "Remote ref refs/remote/$1 is tracked by",
  				    "\n  \"$_\"\nand\n  \"$seen{$1}\"\n",
  				    "Please resolve this ambiguity in ",
  				    "your git configuration file before ",
  				    "continuing\n";
  			}
  			$seen{$1} = $_;
  		}
  	}
  }
  
  sub find_existing_remote {
  	my ($url, $remotes) = @_;
  	return undef if $no_reuse_existing;
  	my $existing;
  	foreach my $repo_id (keys %$remotes) {
  		my $u = $remotes->{$repo_id}->{url} or next;
  		next if $u ne $url;
  		$existing = $repo_id;
  		last;
  	}
  	$existing;
  }
  
  sub init_remote_config {
  	my ($self, $url, $no_write) = @_;
  	$url = canonicalize_url($url);
  	my $r = read_all_remotes();
  	my $existing = find_existing_remote($url, $r);
  	if ($existing) {
  		unless ($no_write) {
  			print STDERR "Using existing ",
  				     "[svn-remote \"$existing\"]\n";
  		}
  		$self->{repo_id} = $existing;
  	} elsif ($_minimize_url) {
  		my $min_url = Git::SVN::Ra->new($url)->minimize_url;
  		$existing = find_existing_remote($min_url, $r);
  		if ($existing) {
  			unless ($no_write) {
  				print STDERR "Using existing ",
  					     "[svn-remote \"$existing\"]\n";
  			}
  			$self->{repo_id} = $existing;
  		}
  		if ($min_url ne $url) {
  			unless ($no_write) {
  				print STDERR "Using higher level of URL: ",
  					     "$url => $min_url\n";
  			}
  			my $old_path = $self->path;
  			$url =~ s!^\Q$min_url\E(/|$)!!;
  			$url = join_paths($url, $old_path);
  			$self->path($url);
  			$url = $min_url;
  		}
  	}
  	my $orig_url;
  	if (!$existing) {
  		# verify that we aren't overwriting anything:
  		$orig_url = eval {
  			command_oneline('config', '--get',
  					"svn-remote.$self->{repo_id}.url")
  		};
  		if ($orig_url && ($orig_url ne $url)) {
  			die "svn-remote.$self->{repo_id}.url already set: ",
  			    "$orig_url\nwanted to set to: $url\n";
  		}
  	}
  	my ($xrepo_id, $xpath) = find_ref($self->refname);
  	if (!$no_write && defined $xpath) {
  		die "svn-remote.$xrepo_id.fetch already set to track ",
  		    "$xpath:", $self->refname, "\n";
  	}
  	unless ($no_write) {
  		command_noisy('config',
  			      "svn-remote.$self->{repo_id}.url", $url);
  		my $path = $self->path;
  		$path =~ s{^/}{};
  		$path =~ s{%([0-9A-F]{2})}{chr hex($1)}ieg;
  		$self->path($path);
  		command_noisy('config', '--add',
  			      "svn-remote.$self->{repo_id}.fetch",
  			      $self->path.":".$self->refname);
  	}
  	$self->url($url);
  }
  
  sub find_by_url { # repos_root and, path are optional
  	my ($class, $full_url, $repos_root, $path) = @_;
  
  	$full_url = canonicalize_url($full_url);
  
  	return undef unless defined $full_url;
  	remove_username($full_url);
  	remove_username($repos_root) if defined $repos_root;
  	my $remotes = read_all_remotes();
  	if (defined $full_url && defined $repos_root && !defined $path) {
  		$path = $full_url;
  		$path =~ s#^\Q$repos_root\E(?:/|$)##;
  	}
  	foreach my $repo_id (keys %$remotes) {
  		my $u = $remotes->{$repo_id}->{url} or next;
  		remove_username($u);
  		next if defined $repos_root && $repos_root ne $u;
  
  		my $fetch = $remotes->{$repo_id}->{fetch} || {};
  		foreach my $t (qw/branches tags/) {
  			foreach my $globspec (@{$remotes->{$repo_id}->{$t}}) {
  				resolve_local_globs($u, $fetch, $globspec);
  			}
  		}
  		my $p = $path;
  		my $rwr = rewrite_root({repo_id => $repo_id});
  		my $svm = $remotes->{$repo_id}->{svm}
  			if defined $remotes->{$repo_id}->{svm};
  		unless (defined $p) {
  			$p = $full_url;
  			my $z = $u;
  			my $prefix = '';
  			if ($rwr) {
  				$z = $rwr;
  				remove_username($z);
  			} elsif (defined $svm) {
  				$z = $svm->{source};
  				$prefix = $svm->{replace};
  				$prefix =~ s#^\Q$u\E(?:/|$)##;
  				$prefix =~ s#/$##;
  			}
  			$p =~ s#^\Q$z\E(?:/|$)#$prefix# or next;
  		}
  
  		# remote fetch paths are not URI escaped.  Decode ours
  		# so they match
  		$p = uri_decode($p);
  
  		foreach my $f (keys %$fetch) {
  			next if $f ne $p;
  			return Git::SVN->new($fetch->{$f}, $repo_id, $f);
  		}
  	}
  	undef;
  }
  
  sub init {
  	my ($class, $url, $path, $repo_id, $ref_id, $no_write) = @_;
  	my $self = _new($class, $repo_id, $ref_id, $path);
  	if (defined $url) {
  		$self->init_remote_config($url, $no_write);
  	}
  	$self;
  }
  
  sub find_ref {
  	my ($ref_id) = @_;
  	foreach (command(qw/config -l/)) {
  		next unless m!^svn-remote\.(.+)\.fetch=
  		              \s*(.*?)\s*:\s*(.+?)\s*$!x;
  		my ($repo_id, $path, $ref) = ($1, $2, $3);
  		if ($ref eq $ref_id) {
  			$path = '' if ($path =~ m#^\./?#);
  			return ($repo_id, $path);
  		}
  	}
  	(undef, undef, undef);
  }
  
  sub new {
  	my ($class, $ref_id, $repo_id, $path) = @_;
  	if (defined $ref_id && !defined $repo_id && !defined $path) {
  		($repo_id, $path) = find_ref($ref_id);
  		if (!defined $repo_id) {
  			die "Could not find a \"svn-remote.*.fetch\" key ",
  			    "in the repository configuration matching: ",
  			    "$ref_id\n";
  		}
  	}
  	my $self = _new($class, $repo_id, $ref_id, $path);
  	if (!defined $self->path || !length $self->path) {
  		my $fetch = command_oneline('config', '--get',
  		                            "svn-remote.$repo_id.fetch",
  		                            ":$ref_id\$") or
  		     die "Failed to read \"svn-remote.$repo_id.fetch\" ",
  		         "\":$ref_id\$\" in config\n";
  		my($path) = split(/\s*:\s*/, $fetch);
  		$self->path($path);
  	}
  	{
  		my $path = $self->path;
  		$path =~ s{\A/}{};
  		$path =~ s{/\z}{};
  		$self->path($path);
  	}
  	my $url = command_oneline('config', '--get',
  	                          "svn-remote.$repo_id.url") or
                    die "Failed to read \"svn-remote.$repo_id.url\" in config\n";
  	$self->url($url);
  	$self->{pushurl} = eval { command_oneline('config', '--get',
  	                          "svn-remote.$repo_id.pushurl") };
  	$self->rebuild;
  	$self;
  }
  
  sub refname {
  	my ($refname) = $_[0]->{ref_id} ;
  
  	# It cannot end with a slash /, we'll throw up on this because
  	# SVN can't have directories with a slash in their name, either:
  	if ($refname =~ m{/$}) {
  		die "ref: '$refname' ends with a trailing slash; this is ",
  		    "not permitted by git or Subversion\n";
  	}
  
  	# It cannot have ASCII control character space, tilde ~, caret ^,
  	# colon :, question-mark ?, asterisk *, space, or open bracket [
  	# anywhere.
  	#
  	# Additionally, % must be escaped because it is used for escaping
  	# and we want our escaped refname to be reversible
  	$refname =~ s{([ \%~\^:\?\*\[\t\\])}{sprintf('%%%02X',ord($1))}eg;
  
  	# no slash-separated component can begin with a dot .
  	# /.* becomes /%2E*
  	$refname =~ s{/\.}{/%2E}g;
  
  	# It cannot have two consecutive dots .. anywhere
  	# .. becomes %2E%2E
  	$refname =~ s{\.\.}{%2E%2E}g;
  
  	# trailing dots and .lock are not allowed
  	# .$ becomes %2E and .lock becomes %2Elock
  	$refname =~ s{\.(?=$|lock$)}{%2E};
  
  	# the sequence @{ is used to access the reflog
  	# @{ becomes %40{
  	$refname =~ s{\@\{}{%40\{}g;
  
  	return $refname;
  }
  
  sub desanitize_refname {
  	my ($refname) = @_;
  	$refname =~ s{%(?:([0-9A-F]{2}))}{chr hex($1)}eg;
  	return $refname;
  }
  
  sub svm_uuid {
  	my ($self) = @_;
  	return $self->{svm}->{uuid} if $self->svm;
  	$self->ra;
  	unless ($self->{svm}) {
  		die "SVM UUID not cached, and reading remotely failed\n";
  	}
  	$self->{svm}->{uuid};
  }
  
  sub svm {
  	my ($self) = @_;
  	return $self->{svm} if $self->{svm};
  	my $svm;
  	# see if we have it in our config, first:
  	eval {
  		my $section = "svn-remote.$self->{repo_id}";
  		$svm = {
  		  source => tmp_config('--get', "$section.svm-source"),
  		  uuid => tmp_config('--get', "$section.svm-uuid"),
  		  replace => tmp_config('--get', "$section.svm-replace"),
  		}
  	};
  	if ($svm && $svm->{source} && $svm->{uuid} && $svm->{replace}) {
  		$self->{svm} = $svm;
  	}
  	$self->{svm};
  }
  
  sub _set_svm_vars {
  	my ($self, $ra) = @_;
  	return $ra if $self->svm;
  
  	my @err = ( "useSvmProps set, but failed to read SVM properties\n",
  		    "(svm:source, svm:uuid) ",
  		    "from the following URLs:\n" );
  	sub read_svm_props {
  		my ($self, $ra, $path, $r) = @_;
  		my $props = ($ra->get_dir($path, $r))[2];
  		my $src = $props->{'svm:source'};
  		my $uuid = $props->{'svm:uuid'};
  		return undef if (!$src || !$uuid);
  
  		chomp($src, $uuid);
  
  		$uuid =~ m{^[0-9a-f\-]{30,}$}i
  		    or die "doesn't look right - svm:uuid is '$uuid'\n";
  
  		# the '!' is used to mark the repos_root!/relative/path
  		$src =~ s{/?!/?}{/};
  		$src =~ s{/+$}{}; # no trailing slashes please
  		# username is of no interest
  		$src =~ s{(^[a-z\+]*://)[^/@]*@}{$1};
  
  		my $replace = add_path_to_url($ra->url, $path);
  
  		my $section = "svn-remote.$self->{repo_id}";
  		tmp_config("$section.svm-source", $src);
  		tmp_config("$section.svm-replace", $replace);
  		tmp_config("$section.svm-uuid", $uuid);
  		$self->{svm} = {
  			source => $src,
  			uuid => $uuid,
  			replace => $replace
  		};
  	}
  
  	my $r = $ra->get_latest_revnum;
  	my $path = $self->path;
  	my %tried;
  	while (length $path) {
  		my $try = add_path_to_url($self->url, $path);
  		unless ($tried{$try}) {
  			return $ra if $self->read_svm_props($ra, $path, $r);
  			$tried{$try} = 1;
  		}
  		$path =~ s#/?[^/]+$##;
  	}
  	die "Path: '$path' should be ''\n" if $path ne '';
  	return $ra if $self->read_svm_props($ra, $path, $r);
  	$tried{ add_path_to_url($self->url, $path) } = 1;
  
  	if ($ra->{repos_root} eq $self->url) {
  		die @err, (map { "  $_\n" } keys %tried), "\n";
  	}
  
  	# nope, make sure we're connected to the repository root:
  	my $ok;
  	my @tried_b;
  	$path = $ra->{svn_path};
  	$ra = Git::SVN::Ra->new($ra->{repos_root});
  	while (length $path) {
  		my $try = add_path_to_url($ra->url, $path);
  		unless ($tried{$try}) {
  			$ok = $self->read_svm_props($ra, $path, $r);
  			last if $ok;
  			$tried{$try} = 1;
  		}
  		$path =~ s#/?[^/]+$##;
  	}
  	die "Path: '$path' should be ''\n" if $path ne '';
  	$ok ||= $self->read_svm_props($ra, $path, $r);
  	$tried{ add_path_to_url($ra->url, $path) } = 1;
  	if (!$ok) {
  		die @err, (map { "  $_\n" } keys %tried), "\n";
  	}
  	Git::SVN::Ra->new($self->url);
  }
  
  sub svnsync {
  	my ($self) = @_;
  	return $self->{svnsync} if $self->{svnsync};
  
  	if ($self->no_metadata) {
  		die "Can't have both 'noMetadata' and ",
  		    "'useSvnsyncProps' options set!\n";
  	}
  	if ($self->rewrite_root) {
  		die "Can't have both 'useSvnsyncProps' and 'rewriteRoot' ",
  		    "options set!\n";
  	}
  	if ($self->rewrite_uuid) {
  		die "Can't have both 'useSvnsyncProps' and 'rewriteUUID' ",
  		    "options set!\n";
  	}
  
  	my $svnsync;
  	# see if we have it in our config, first:
  	eval {
  		my $section = "svn-remote.$self->{repo_id}";
  
  		my $url = tmp_config('--get', "$section.svnsync-url");
  		($url) = ($url =~ m{^([a-z\+]+://\S+)$}) or
  		   die "doesn't look right - svn:sync-from-url is '$url'\n";
  
  		my $uuid = tmp_config('--get', "$section.svnsync-uuid");
  		($uuid) = ($uuid =~ m{^([0-9a-f\-]{30,})$}i) or
  		   die "doesn't look right - svn:sync-from-uuid is '$uuid'\n";
  
  		$svnsync = { url => $url, uuid => $uuid }
  	};
  	if ($svnsync && $svnsync->{url} && $svnsync->{uuid}) {
  		return $self->{svnsync} = $svnsync;
  	}
  
  	my $err = "useSvnsyncProps set, but failed to read " .
  	          "svnsync property: svn:sync-from-";
  	my $rp = $self->ra->rev_proplist(0);
  
  	my $url = $rp->{'svn:sync-from-url'} or die $err . "url\n";
  	($url) = ($url =~ m{^([a-z\+]+://\S+)$}) or
  	           die "doesn't look right - svn:sync-from-url is '$url'\n";
  
  	my $uuid = $rp->{'svn:sync-from-uuid'} or die $err . "uuid\n";
  	($uuid) = ($uuid =~ m{^([0-9a-f\-]{30,})$}i) or
  	           die "doesn't look right - svn:sync-from-uuid is '$uuid'\n";
  
  	my $section = "svn-remote.$self->{repo_id}";
  	tmp_config('--add', "$section.svnsync-uuid", $uuid);
  	tmp_config('--add', "$section.svnsync-url", $url);
  	return $self->{svnsync} = { url => $url, uuid => $uuid };
  }
  
  # this allows us to memoize our SVN::Ra UUID locally and avoid a
  # remote lookup (useful for 'git svn log').
  sub ra_uuid {
  	my ($self) = @_;
  	unless ($self->{ra_uuid}) {
  		my $key = "svn-remote.$self->{repo_id}.uuid";
  		my $uuid = eval { tmp_config('--get', $key) };
  		if (!$@ && $uuid && $uuid =~ /^([a-f\d\-]{30,})$/i) {
  			$self->{ra_uuid} = $uuid;
  		} else {
  			die "ra_uuid called without URL\n" unless $self->url;
  			$self->{ra_uuid} = $self->ra->get_uuid;
  			tmp_config('--add', $key, $self->{ra_uuid});
  		}
  	}
  	$self->{ra_uuid};
  }
  
  sub _set_repos_root {
  	my ($self, $repos_root) = @_;
  	my $k = "svn-remote.$self->{repo_id}.reposRoot";
  	$repos_root ||= $self->ra->{repos_root};
  	tmp_config($k, $repos_root);
  	$repos_root;
  }
  
  sub repos_root {
  	my ($self) = @_;
  	my $k = "svn-remote.$self->{repo_id}.reposRoot";
  	eval { tmp_config('--get', $k) } || $self->_set_repos_root;
  }
  
  sub ra {
  	my ($self) = shift;
  	my $ra = Git::SVN::Ra->new($self->url);
  	$self->_set_repos_root($ra->{repos_root});
  	if ($self->use_svm_props && !$self->{svm}) {
  		if ($self->no_metadata) {
  			die "Can't have both 'noMetadata' and ",
  			    "'useSvmProps' options set!\n";
  		} elsif ($self->use_svnsync_props) {
  			die "Can't have both 'useSvnsyncProps' and ",
  			    "'useSvmProps' options set!\n";
  		}
  		$ra = $self->_set_svm_vars($ra);
  		$self->{-want_revprops} = 1;
  	}
  	$ra;
  }
  
  # prop_walk(PATH, REV, SUB)
  # -------------------------
  # Recursively traverse PATH at revision REV and invoke SUB for each
  # directory that contains a SVN property.  SUB will be invoked as
  # follows:  &SUB(gs, path, props);  where `gs' is this instance of
  # Git::SVN, `path' the path to the directory where the properties
  # `props' were found.  The `path' will be relative to point of checkout,
  # that is, if url://repo/trunk is the current Git branch, and that
  # directory contains a sub-directory `d', SUB will be invoked with `/d/'
  # as `path' (note the trailing `/').
  sub prop_walk {
  	my ($self, $path, $rev, $sub) = @_;
  
  	$path =~ s#^/##;
  	my ($dirent, undef, $props) = $self->ra->get_dir($path, $rev);
  	$path =~ s#^/*#/#g;
  	my $p = $path;
  	# Strip the irrelevant part of the path.
  	$p =~ s#^/+\Q@{[$self->path]}\E(/|$)#/#;
  	# Ensure the path is terminated by a `/'.
  	$p =~ s#/*$#/#;
  
  	# The properties contain all the internal SVN stuff nobody
  	# (usually) cares about.
  	my $interesting_props = 0;
  	foreach (keys %{$props}) {
  		# If it doesn't start with `svn:', it must be a
  		# user-defined property.
  		++$interesting_props and next if $_ !~ /^svn:/;
  		# FIXME: Fragile, if SVN adds new public properties,
  		# this needs to be updated.
  		++$interesting_props if /^svn:(?:ignore|keywords|executable
  		                                 |eol-style|mime-type
  						 |externals|needs-lock)$/x;
  	}
  	&$sub($self, $p, $props) if $interesting_props;
  
  	foreach (sort keys %$dirent) {
  		next if $dirent->{$_}->{kind} != $SVN::Node::dir;
  		$self->prop_walk($self->path . $p . $_, $rev, $sub);
  	}
  }
  
  sub last_rev { ($_[0]->last_rev_commit)[0] }
  sub last_commit { ($_[0]->last_rev_commit)[1] }
  
  # returns the newest SVN revision number and newest commit SHA1
  sub last_rev_commit {
  	my ($self) = @_;
  	if (defined $self->{last_rev} && defined $self->{last_commit}) {
  		return ($self->{last_rev}, $self->{last_commit});
  	}
  	my $c = ::verify_ref($self->refname.'^0');
  	if ($c && !$self->use_svm_props && !$self->no_metadata) {
  		my $rev = (::cmt_metadata($c))[1];
  		if (defined $rev) {
  			($self->{last_rev}, $self->{last_commit}) = ($rev, $c);
  			return ($rev, $c);
  		}
  	}
  	my $map_path = $self->map_path;
  	unless (-e $map_path) {
  		($self->{last_rev}, $self->{last_commit}) = (undef, undef);
  		return (undef, undef);
  	}
  	my ($rev, $commit) = $self->rev_map_max(1);
  	($self->{last_rev}, $self->{last_commit}) = ($rev, $commit);
  	return ($rev, $commit);
  }
  
  sub get_fetch_range {
  	my ($self, $min, $max) = @_;
  	$max ||= $self->ra->get_latest_revnum;
  	$min ||= $self->rev_map_max;
  	(++$min, $max);
  }
  
  sub svn_dir {
  	command_oneline(qw(rev-parse --git-path svn));
  }
  
  sub tmp_config {
  	my (@args) = @_;
  	my $svn_dir = svn_dir();
  	my $old_def_config = "$svn_dir/config";
  	my $config = "$svn_dir/.metadata";
  	if (! -f $config && -f $old_def_config) {
  		rename $old_def_config, $config or
  		       die "Failed rename $old_def_config => $config: $!\n";
  	}
  	my $old_config = $ENV{GIT_CONFIG};
  	$ENV{GIT_CONFIG} = $config;
  	$@ = undef;
  	my @ret = eval {
  		unless (-f $config) {
  			mkfile($config);
  			open my $fh, '>', $config or
  			    die "Can't open $config: $!\n";
  			print $fh "; This file is used internally by ",
  			          "git-svn\n" or die
  				  "Couldn't write to $config: $!\n";
  			print $fh "; You should not have to edit it\n" or
  			      die "Couldn't write to $config: $!\n";
  			close $fh or die "Couldn't close $config: $!\n";
  		}
  		command('config', @args);
  	};
  	my $err = $@;
  	if (defined $old_config) {
  		$ENV{GIT_CONFIG} = $old_config;
  	} else {
  		delete $ENV{GIT_CONFIG};
  	}
  	die $err if $err;
  	wantarray ? @ret : $ret[0];
  }
  
  sub tmp_index_do {
  	my ($self, $sub) = @_;
  	my $old_index = $ENV{GIT_INDEX_FILE};
  	$ENV{GIT_INDEX_FILE} = $self->{index};
  	$@ = undef;
  	my @ret = eval {
  		my ($dir, $base) = ($self->{index} =~ m#^(.*?)/?([^/]+)$#);
  		mkpath([$dir]) unless -d $dir;
  		&$sub;
  	};
  	my $err = $@;
  	if (defined $old_index) {
  		$ENV{GIT_INDEX_FILE} = $old_index;
  	} else {
  		delete $ENV{GIT_INDEX_FILE};
  	}
  	die $err if $err;
  	wantarray ? @ret : $ret[0];
  }
  
  sub assert_index_clean {
  	my ($self, $treeish) = @_;
  
  	$self->tmp_index_do(sub {
  		command_noisy('read-tree', $treeish) unless -e $self->{index};
  		my $x = command_oneline('write-tree');
  		my ($y) = (command(qw/cat-file commit/, $treeish) =~
  		           /^tree ($::sha1)/mo);
  		return if $y eq $x;
  
  		warn "Index mismatch: $y != $x\nrereading $treeish\n";
  		unlink $self->{index} or die "unlink $self->{index}: $!\n";
  		command_noisy('read-tree', $treeish);
  		$x = command_oneline('write-tree');
  		if ($y ne $x) {
  			fatal "trees ($treeish) $y != $x\n",
  			      "Something is seriously wrong...";
  		}
  	});
  }
  
  sub get_commit_parents {
  	my ($self, $log_entry) = @_;
  	my (%seen, @ret, @tmp);
  	# legacy support for 'set-tree'; this is only used by set_tree_cb:
  	if (my $ip = $self->{inject_parents}) {
  		if (my $commit = delete $ip->{$log_entry->{revision}}) {
  			push @tmp, $commit;
  		}
  	}
  	if (my $cur = ::verify_ref($self->refname.'^0')) {
  		push @tmp, $cur;
  	}
  	if (my $ipd = $self->{inject_parents_dcommit}) {
  		if (my $commit = delete $ipd->{$log_entry->{revision}}) {
  			push @tmp, @$commit;
  		}
  	}
  	push @tmp, $_ foreach (@{$log_entry->{parents}}, @tmp);
  	while (my $p = shift @tmp) {
  		next if $seen{$p};
  		$seen{$p} = 1;
  		push @ret, $p;
  	}
  	@ret;
  }
  
  sub rewrite_root {
  	my ($self) = @_;
  	return $self->{-rewrite_root} if exists $self->{-rewrite_root};
  	my $k = "svn-remote.$self->{repo_id}.rewriteRoot";
  	my $rwr = eval { command_oneline(qw/config --get/, $k) };
  	if ($rwr) {
  		$rwr =~ s#/+$##;
  		if ($rwr !~ m#^[a-z\+]+://#) {
  			die "$rwr is not a valid URL (key: $k)\n";
  		}
  	}
  	$self->{-rewrite_root} = $rwr;
  }
  
  sub rewrite_uuid {
  	my ($self) = @_;
  	return $self->{-rewrite_uuid} if exists $self->{-rewrite_uuid};
  	my $k = "svn-remote.$self->{repo_id}.rewriteUUID";
  	my $rwid = eval { command_oneline(qw/config --get/, $k) };
  	if ($rwid) {
  		$rwid =~ s#/+$##;
  		if ($rwid !~ m#^[a-f0-9]{8}-(?:[a-f0-9]{4}-){3}[a-f0-9]{12}$#) {
  			die "$rwid is not a valid UUID (key: $k)\n";
  		}
  	}
  	$self->{-rewrite_uuid} = $rwid;
  }
  
  sub metadata_url {
  	my ($self) = @_;
  	my $url = $self->rewrite_root || $self->url;
  	return canonicalize_url( add_path_to_url( $url, $self->path ) );
  }
  
  sub full_url {
  	my ($self) = @_;
  	return canonicalize_url( add_path_to_url( $self->url, $self->path ) );
  }
  
  sub full_pushurl {
  	my ($self) = @_;
  	if ($self->{pushurl}) {
  		return canonicalize_url( add_path_to_url( $self->{pushurl}, $self->path ) );
  	} else {
  		return $self->full_url;
  	}
  }
  
  sub set_commit_header_env {
  	my ($log_entry) = @_;
  	my %env;
  	foreach my $ned (qw/NAME EMAIL DATE/) {
  		foreach my $ac (qw/AUTHOR COMMITTER/) {
  			$env{"GIT_${ac}_${ned}"} = $ENV{"GIT_${ac}_${ned}"};
  		}
  	}
  
  	$ENV{GIT_AUTHOR_NAME} = $log_entry->{name};
  	$ENV{GIT_AUTHOR_EMAIL} = $log_entry->{email};
  	$ENV{GIT_AUTHOR_DATE} = $ENV{GIT_COMMITTER_DATE} = $log_entry->{date};
  
  	$ENV{GIT_COMMITTER_NAME} = (defined $log_entry->{commit_name})
  						? $log_entry->{commit_name}
  						: $log_entry->{name};
  	$ENV{GIT_COMMITTER_EMAIL} = (defined $log_entry->{commit_email})
  						? $log_entry->{commit_email}
  						: $log_entry->{email};
  	\%env;
  }
  
  sub restore_commit_header_env {
  	my ($env) = @_;
  	foreach my $ned (qw/NAME EMAIL DATE/) {
  		foreach my $ac (qw/AUTHOR COMMITTER/) {
  			my $k = "GIT_${ac}_${ned}";
  			if (defined $env->{$k}) {
  				$ENV{$k} = $env->{$k};
  			} else {
  				delete $ENV{$k};
  			}
  		}
  	}
  }
  
  sub gc {
  	command_noisy('gc', '--auto');
  };
  
  sub do_git_commit {
  	my ($self, $log_entry) = @_;
  	my $lr = $self->last_rev;
  	if (defined $lr && $lr >= $log_entry->{revision}) {
  		die "Last fetched revision of ", $self->refname,
  		    " was r$lr, but we are about to fetch: ",
  		    "r$log_entry->{revision}!\n";
  	}
  	if (my $c = $self->rev_map_get($log_entry->{revision})) {
  		croak "$log_entry->{revision} = $c already exists! ",
  		      "Why are we refetching it?\n";
  	}
  	my $old_env = set_commit_header_env($log_entry);
  	my $tree = $log_entry->{tree};
  	if (!defined $tree) {
  		$tree = $self->tmp_index_do(sub {
  		                            command_oneline('write-tree') });
  	}
  	die "Tree is not a valid sha1: $tree\n" if $tree !~ /^$::sha1$/o;
  
  	my @exec = ('git', 'commit-tree', $tree);
  	foreach ($self->get_commit_parents($log_entry)) {
  		push @exec, '-p', $_;
  	}
  	defined(my $pid = open3(my $msg_fh, my $out_fh, '>&STDERR', @exec))
  	                                                           or croak $!;
  	binmode $msg_fh;
  
  	# we always get UTF-8 from SVN, but we may want our commits in
  	# a different encoding.
  	if (my $enc = Git::config('i18n.commitencoding')) {
  		require Encode;
  		Encode::from_to($log_entry->{log}, 'UTF-8', $enc);
  	}
  	print $msg_fh $log_entry->{log} or croak $!;
  	restore_commit_header_env($old_env);
  	unless ($self->no_metadata) {
  		print $msg_fh "\ngit-svn-id: $log_entry->{metadata}\n"
  		              or croak $!;
  	}
  	$msg_fh->flush == 0 or croak $!;
  	close $msg_fh or croak $!;
  	chomp(my $commit = do { local $/; <$out_fh> });
  	close $out_fh or croak $!;
  	waitpid $pid, 0;
  	croak $? if $?;
  	if ($commit !~ /^$::sha1$/o) {
  		die "Failed to commit, invalid sha1: $commit\n";
  	}
  
  	$self->rev_map_set($log_entry->{revision}, $commit, 1);
  
  	$self->{last_rev} = $log_entry->{revision};
  	$self->{last_commit} = $commit;
  	print "r$log_entry->{revision}" unless $::_q > 1;
  	if (defined $log_entry->{svm_revision}) {
  		 print " (\@$log_entry->{svm_revision})" unless $::_q > 1;
  		 $self->rev_map_set($log_entry->{svm_revision}, $commit,
  		                   0, $self->svm_uuid);
  	}
  	print " = $commit ($self->{ref_id})\n" unless $::_q > 1;
  	if (--$_gc_nr == 0) {
  		$_gc_nr = $_gc_period;
  		gc();
  	}
  	return $commit;
  }
  
  sub match_paths {
  	my ($self, $paths, $r) = @_;
  	return 1 if $self->path eq '';
  	if (my $path = $paths->{"/".$self->path}) {
  		return ($path->{action} eq 'D') ? 0 : 1;
  	}
  	$self->{path_regex} ||= qr{^/\Q@{[$self->path]}\E/};
  	if (grep /$self->{path_regex}/, keys %$paths) {
  		return 1;
  	}
  	my $c = '';
  	foreach (split m#/#, $self->path) {
  		$c .= "/$_";
  		next unless ($paths->{$c} &&
  		             ($paths->{$c}->{action} =~ /^[AR]$/));
  		if ($self->ra->check_path($self->path, $r) ==
  		    $SVN::Node::dir) {
  			return 1;
  		}
  	}
  	return 0;
  }
  
  sub find_parent_branch {
  	my ($self, $paths, $rev) = @_;
  	return undef unless $self->follow_parent;
  	unless (defined $paths) {
  		my $err_handler = $SVN::Error::handler;
  		$SVN::Error::handler = \&Git::SVN::Ra::skip_unknown_revs;
  		$self->ra->get_log([$self->path], $rev, $rev, 0, 1, 1,
  				   sub { $paths = $_[0] });
  		$SVN::Error::handler = $err_handler;
  	}
  	return undef unless defined $paths;
  
  	# look for a parent from another branch:
  	my @b_path_components = split m#/#, $self->path;
  	my @a_path_components;
  	my $i;
  	while (@b_path_components) {
  		$i = $paths->{'/'.join('/', @b_path_components)};
  		last if $i && defined $i->{copyfrom_path};
  		unshift(@a_path_components, pop(@b_path_components));
  	}
  	return undef unless defined $i && defined $i->{copyfrom_path};
  	my $branch_from = $i->{copyfrom_path};
  	if (@a_path_components) {
  		print STDERR "branch_from: $branch_from => ";
  		$branch_from .= '/'.join('/', @a_path_components);
  		print STDERR $branch_from, "\n";
  	}
  	my $r = $i->{copyfrom_rev};
  	my $repos_root = $self->ra->{repos_root};
  	my $url = $self->ra->url;
  	my $new_url = canonicalize_url( add_path_to_url( $url, $branch_from ) );
  	print STDERR  "Found possible branch point: ",
  	              "$new_url => ", $self->full_url, ", $r\n"
  	              unless $::_q > 1;
  	$branch_from =~ s#^/##;
  	my $gs = $self->other_gs($new_url, $url,
  		                 $branch_from, $r, $self->{ref_id});
  	my ($r0, $parent) = $gs->find_rev_before($r, 1);
  	{
  		my ($base, $head);
  		if (!defined $r0 || !defined $parent) {
  			($base, $head) = parse_revision_argument(0, $r);
  		} else {
  			if ($r0 < $r) {
  				$gs->ra->get_log([$gs->path], $r0 + 1, $r, 1,
  					0, 1, sub { $base = $_[1] - 1 });
  			}
  		}
  		if (defined $base && $base <= $r) {
  			$gs->fetch($base, $r);
  		}
  		($r0, $parent) = $gs->find_rev_before($r, 1);
  	}
  	if (defined $r0 && defined $parent) {
  		print STDERR "Found branch parent: ($self->{ref_id}) $parent\n"
  		             unless $::_q > 1;
  		my $ed;
  		if ($self->ra->can_do_switch) {
  			$self->assert_index_clean($parent);
  			print STDERR "Following parent with do_switch\n"
  			             unless $::_q > 1;
  			# do_switch works with svn/trunk >= r22312, but that
  			# is not included with SVN 1.4.3 (the latest version
  			# at the moment), so we can't rely on it
  			$self->{last_rev} = $r0;
  			$self->{last_commit} = $parent;
  			$ed = Git::SVN::Fetcher->new($self, $gs->path);
  			$gs->ra->gs_do_switch($r0, $rev, $gs,
  					      $self->full_url, $ed)
  			  or die "SVN connection failed somewhere...\n";
  		} elsif ($self->ra->trees_match($new_url, $r0,
  			                        $self->full_url, $rev)) {
  			print STDERR "Trees match:\n",
  			             "  $new_url\@$r0\n",
  			             "  ${\$self->full_url}\@$rev\n",
  			             "Following parent with no changes\n"
  			             unless $::_q > 1;
  			$self->tmp_index_do(sub {
  			    command_noisy('read-tree', $parent);
  			});
  			$self->{last_commit} = $parent;
  		} else {
  			print STDERR "Following parent with do_update\n"
  			             unless $::_q > 1;
  			$ed = Git::SVN::Fetcher->new($self);
  			$self->ra->gs_do_update($rev, $rev, $self, $ed)
  			  or die "SVN connection failed somewhere...\n";
  		}
  		print STDERR "Successfully followed parent\n" unless $::_q > 1;
  		return $self->make_log_entry($rev, [$parent], $ed, $r0, $branch_from);
  	}
  	return undef;
  }
  
  sub do_fetch {
  	my ($self, $paths, $rev) = @_;
  	my $ed;
  	my ($last_rev, @parents);
  	if (my $lc = $self->last_commit) {
  		# we can have a branch that was deleted, then re-added
  		# under the same name but copied from another path, in
  		# which case we'll have multiple parents (we don't
  		# want to break the original ref or lose copypath info):
  		if (my $log_entry = $self->find_parent_branch($paths, $rev)) {
  			push @{$log_entry->{parents}}, $lc;
  			return $log_entry;
  		}
  		$ed = Git::SVN::Fetcher->new($self);
  		$last_rev = $self->{last_rev};
  		$ed->{c} = $lc;
  		@parents = ($lc);
  	} else {
  		$last_rev = $rev;
  		if (my $log_entry = $self->find_parent_branch($paths, $rev)) {
  			return $log_entry;
  		}
  		$ed = Git::SVN::Fetcher->new($self);
  	}
  	unless ($self->ra->gs_do_update($last_rev, $rev, $self, $ed)) {
  		die "SVN connection failed somewhere...\n";
  	}
  	$self->make_log_entry($rev, \@parents, $ed, $last_rev, $self->path);
  }
  
  sub mkemptydirs {
  	my ($self, $r) = @_;
  
  	# add/remove/collect a paths table
  	#
  	# Paths are split into a tree of nodes, stored as a hash of hashes.
  	#
  	# Each node contains a 'path' entry for the path (if any) associated
  	# with that node and a 'children' entry for any nodes under that
  	# location.
  	#
  	# Removing a path requires a hash lookup for each component then
  	# dropping that node (and anything under it), which is substantially
  	# faster than a grep slice into a single hash of paths for large
  	# numbers of paths.
  	#
  	# For a large (200K) number of empty_dir directives this reduces
  	# scanning time to 3 seconds vs 10 minutes for grep+delete on a single
  	# hash of paths.
  	sub add_path {
  		my ($paths_table, $path) = @_;
  		my $node_ref;
  
  		foreach my $x (split('/', $path)) {
  			if (!exists($paths_table->{$x})) {
  				$paths_table->{$x} = { children => {} };
  			}
  
  			$node_ref = $paths_table->{$x};
  			$paths_table = $paths_table->{$x}->{children};
  		}
  
  		$node_ref->{path} = $path;
  	}
  
  	sub remove_path {
  		my ($paths_table, $path) = @_;
  		my $nodes_ref;
  		my $node_name;
  
  		foreach my $x (split('/', $path)) {
  			if (!exists($paths_table->{$x})) {
  				return;
  			}
  
  			$nodes_ref = $paths_table;
  			$node_name = $x;
  
  			$paths_table = $paths_table->{$x}->{children};
  		}
  
  		delete($nodes_ref->{$node_name});
  	}
  
  	sub collect_paths {
  		my ($paths_table, $paths_ref) = @_;
  
  		foreach my $v (values %$paths_table) {
  			my $p = $v->{path};
  			my $c = $v->{children};
  
  			collect_paths($c, $paths_ref);
  
  			if (defined($p)) {
  				push(@$paths_ref, $p);
  			}
  		}
  	}
  
  	sub scan {
  		my ($r, $paths_table, $line) = @_;
  		if (defined $r && $line =~ /^r(\d+)$/) {
  			return 0 if $1 > $r;
  		} elsif ($line =~ /^  \+empty_dir: (.+)$/) {
  			add_path($paths_table, $1);
  		} elsif ($line =~ /^  \-empty_dir: (.+)$/) {
  			remove_path($paths_table, $1);
  		}
  		1; # continue
  	};
  
  	my @empty_dirs;
  	my %paths_table;
  
  	my $gz_file = "$self->{dir}/unhandled.log.gz";
  	if (-f $gz_file) {
  		if (!can_compress()) {
  			warn "Compress::Zlib could not be found; ",
  			     "empty directories in $gz_file will not be read\n";
  		} else {
  			my $gz = Compress::Zlib::gzopen($gz_file, "rb") or
  				die "Unable to open $gz_file: $!\n";
  			my $line;
  			while ($gz->gzreadline($line) > 0) {
  				scan($r, \%paths_table, $line) or last;
  			}
  			$gz->gzclose;
  		}
  	}
  
  	if (open my $fh, '<', "$self->{dir}/unhandled.log") {
  		binmode $fh or croak "binmode: $!";
  		while (<$fh>) {
  			scan($r, \%paths_table, $_) or last;
  		}
  		close $fh;
  	}
  
  	collect_paths(\%paths_table, \@empty_dirs);
  	my $strip = qr/\A\Q@{[$self->path]}\E(?:\/|$)/;
  	foreach my $d (sort @empty_dirs) {
  		$d = uri_decode($d);
  		$d =~ s/$strip//;
  		next unless length($d);
  		next if -d $d;
  		if (-e $d) {
  			warn "$d exists but is not a directory\n";
  		} else {
  			print "creating empty directory: $d\n";
  			mkpath([$d]);
  		}
  	}
  }
  
  sub get_untracked {
  	my ($self, $ed) = @_;
  	my @out;
  	my $h = $ed->{empty};
  	foreach (sort keys %$h) {
  		my $act = $h->{$_} ? '+empty_dir' : '-empty_dir';
  		push @out, "  $act: " . uri_encode($_);
  		warn "W: $act: $_\n";
  	}
  	foreach my $t (qw/dir_prop file_prop/) {
  		$h = $ed->{$t} or next;
  		foreach my $path (sort keys %$h) {
  			my $ppath = $path eq '' ? '.' : $path;
  			foreach my $prop (sort keys %{$h->{$path}}) {
  				next if $SKIP_PROP{$prop};
  				my $v = $h->{$path}->{$prop};
  				my $t_ppath_prop = "$t: " .
  				                    uri_encode($ppath) . ' ' .
  				                    uri_encode($prop);
  				if (defined $v) {
  					push @out, "  +$t_ppath_prop " .
  					           uri_encode($v);
  				} else {
  					push @out, "  -$t_ppath_prop";
  				}
  			}
  		}
  	}
  	foreach my $t (qw/absent_file absent_directory/) {
  		$h = $ed->{$t} or next;
  		foreach my $parent (sort keys %$h) {
  			foreach my $path (sort @{$h->{$parent}}) {
  				push @out, "  $t: " .
  				           uri_encode("$parent/$path");
  				warn "W: $t: $parent/$path ",
  				     "Insufficient permissions?\n";
  			}
  		}
  	}
  	\@out;
  }
  
  # parse_svn_date(DATE)
  # --------------------
  # Given a date (in UTC) from Subversion, return a string in the format
  # "<TZ Offset> <local date/time>" that Git will use.
  #
  # By default the parsed date will be in UTC; if $Git::SVN::_localtime
  # is true we'll convert it to the local timezone instead.
  sub parse_svn_date {
  	my $date = shift || return '+0000 1970-01-01 00:00:00';
  	my ($Y,$m,$d,$H,$M,$S) = ($date =~ /^(\d{4})\-(\d\d)\-(\d\d)T
  	                                    (\d\d?)\:(\d\d)\:(\d\d)\.\d*Z$/x) or
  	                                 croak "Unable to parse date: $date\n";
  	my $parsed_date;    # Set next.
  
  	if ($Git::SVN::_localtime) {
  		# Translate the Subversion datetime to an epoch time.
  		# Begin by switching ourselves to $date's timezone, UTC.
  		my $old_env_TZ = $ENV{TZ};
  		$ENV{TZ} = 'UTC';
  
  		my $epoch_in_UTC =
  		    Time::Local::timelocal($S, $M, $H, $d, $m - 1, $Y - 1900);
  
  		# Determine our local timezone (including DST) at the
  		# time of $epoch_in_UTC.  $Git::SVN::Log::TZ stored the
  		# value of TZ, if any, at the time we were run.
  		if (defined $Git::SVN::Log::TZ) {
  			$ENV{TZ} = $Git::SVN::Log::TZ;
  		} else {
  			delete $ENV{TZ};
  		}
  
  		my $our_TZ = get_tz_offset($epoch_in_UTC);
  
  		# This converts $epoch_in_UTC into our local timezone.
  		my ($sec, $min, $hour, $mday, $mon, $year,
  		    $wday, $yday, $isdst) = localtime($epoch_in_UTC);
  
  		$parsed_date = sprintf('%s %04d-%02d-%02d %02d:%02d:%02d',
  				       $our_TZ, $year + 1900, $mon + 1,
  				       $mday, $hour, $min, $sec);
  
  		# Reset us to the timezone in effect when we entered
  		# this routine.
  		if (defined $old_env_TZ) {
  			$ENV{TZ} = $old_env_TZ;
  		} else {
  			delete $ENV{TZ};
  		}
  	} else {
  		$parsed_date = "+0000 $Y-$m-$d $H:$M:$S";
  	}
  
  	return $parsed_date;
  }
  
  sub other_gs {
  	my ($self, $new_url, $url,
  	    $branch_from, $r, $old_ref_id) = @_;
  	my $gs = Git::SVN->find_by_url($new_url, $url, $branch_from);
  	unless ($gs) {
  		my $ref_id = $old_ref_id;
  		$ref_id =~ s/\@\d+-*$//;
  		$ref_id .= "\@$r";
  		# just grow a tail if we're not unique enough :x
  		$ref_id .= '-' while find_ref($ref_id);
  		my ($u, $p, $repo_id) = ($new_url, '', $ref_id);
  		if ($u =~ s#^\Q$url\E(/|$)##) {
  			$p = $u;
  			$u = $url;
  			$repo_id = $self->{repo_id};
  		}
  		while (1) {
  			# It is possible to tag two different subdirectories at
  			# the same revision.  If the url for an existing ref
  			# does not match, we must either find a ref with a
  			# matching url or create a new ref by growing a tail.
  			$gs = Git::SVN->init($u, $p, $repo_id, $ref_id, 1);
  			my (undef, $max_commit) = $gs->rev_map_max(1);
  			last if (!$max_commit);
  			my ($url) = ::cmt_metadata($max_commit);
  			last if ($url eq $gs->metadata_url);
  			$ref_id .= '-';
  		}
  		print STDERR "Initializing parent: $ref_id\n" unless $::_q > 1;
  	}
  	$gs
  }
  
  sub call_authors_prog {
  	my ($orig_author) = @_;
  	$orig_author = command_oneline('rev-parse', '--sq-quote', $orig_author);
  	my $author = `$::_authors_prog $orig_author`;
  	if ($? != 0) {
  		die "$::_authors_prog failed with exit code $?\n"
  	}
  	if ($author =~ /^\s*(.+?)\s*<(.*)>\s*$/) {
  		my ($name, $email) = ($1, $2);
  		$email = undef if length $2 == 0;
  		return [$name, $email];
  	} else {
  		die "Author: $orig_author: $::_authors_prog returned "
  			. "invalid author format: $author\n";
  	}
  }
  
  sub check_author {
  	my ($author) = @_;
  	if (!defined $author || length $author == 0) {
  		$author = '(no author)';
  	}
  	if (!defined $::users{$author}) {
  		if (defined $::_authors_prog) {
  			$::users{$author} = call_authors_prog($author);
  		} elsif (defined $::_authors) {
  			die "Author: $author not defined in $::_authors file\n";
  		}
  	}
  	$author;
  }
  
  sub find_extra_svk_parents {
  	my ($self, $tickets, $parents) = @_;
  	# aha!  svk:merge property changed...
  	my @tickets = split "\n", $tickets;
  	my @known_parents;
  	for my $ticket ( @tickets ) {
  		my ($uuid, $path, $rev) = split /:/, $ticket;
  		if ( $uuid eq $self->ra_uuid ) {
  			my $repos_root = $self->url;
  			my $branch_from = $path;
  			$branch_from =~ s{^/}{};
  			my $gs = $self->other_gs(add_path_to_url( $repos_root, $branch_from ),
  			                         $repos_root,
  			                         $branch_from,
  			                         $rev,
  			                         $self->{ref_id});
  			if ( my $commit = $gs->rev_map_get($rev, $uuid) ) {
  				# wahey!  we found it, but it might be
  				# an old one (!)
  				push @known_parents, [ $rev, $commit ];
  			}
  		}
  	}
  	# Ordering matters; highest-numbered commit merge tickets
  	# first, as they may account for later merge ticket additions
  	# or changes.
  	@known_parents = map {$_->[1]} sort {$b->[0] <=> $a->[0]} @known_parents;
  	for my $parent ( @known_parents ) {
  		my @cmd = ('rev-list', $parent, map { "^$_" } @$parents );
  		my ($msg_fh, $ctx) = command_output_pipe(@cmd);
  		my $new;
  		while ( <$msg_fh> ) {
  			$new=1;last;
  		}
  		command_close_pipe($msg_fh, $ctx);
  		if ( $new ) {
  			print STDERR
  			    "Found merge parent (svk:merge ticket): $parent\n";
  			push @$parents, $parent;
  		}
  	}
  }
  
  sub lookup_svn_merge {
  	my $uuid = shift;
  	my $url = shift;
  	my $source = shift;
  	my $revs = shift;
  
  	my $path = $source;
  	$path =~ s{^/}{};
  	my $gs = Git::SVN->find_by_url($url.$source, $url, $path);
  	if ( !$gs ) {
  		warn "Couldn't find revmap for $url$source\n";
  		return;
  	}
  	my @ranges = split ",", $revs;
  	my ($tip, $tip_commit);
  	my @merged_commit_ranges;
  	# find the tip
  	for my $range ( @ranges ) {
  		if ($range =~ /[*]$/) {
  			warn "W: Ignoring partial merge in svn:mergeinfo "
  				."dirprop: $source:$range\n";
  			next;
  		}
  		my ($bottom, $top) = split "-", $range;
  		$top ||= $bottom;
  		my $bottom_commit = $gs->find_rev_after( $bottom, 1, $top );
  		my $top_commit = $gs->find_rev_before( $top, 1, $bottom );
  
  		unless ($top_commit and $bottom_commit) {
  			warn "W: unknown path/rev in svn:mergeinfo "
  				."dirprop: $source:$range\n";
  			next;
  		}
  
  		if (scalar(command('rev-parse', "$bottom_commit^@"))) {
  			push @merged_commit_ranges,
  			     "$bottom_commit^..$top_commit";
  		} else {
  			push @merged_commit_ranges, "$top_commit";
  		}
  
  		if ( !defined $tip or $top > $tip ) {
  			$tip = $top;
  			$tip_commit = $top_commit;
  		}
  	}
  	return ($tip_commit, @merged_commit_ranges);
  }
  
  sub _rev_list {
  	my ($msg_fh, $ctx) = command_output_pipe(
  		"rev-list", @_,
  	       );
  	my @rv;
  	while ( <$msg_fh> ) {
  		chomp;
  		push @rv, $_;
  	}
  	command_close_pipe($msg_fh, $ctx);
  	@rv;
  }
  
  sub check_cherry_pick2 {
  	my $base = shift;
  	my $tip = shift;
  	my $parents = shift;
  	my @ranges = @_;
  	my %commits = map { $_ => 1 }
  		_rev_list("--no-merges", $tip, "--not", $base, @$parents, "--");
  	for my $range ( @ranges ) {
  		delete @commits{_rev_list($range, "--")};
  	}
  	for my $commit (keys %commits) {
  		if (has_no_changes($commit)) {
  			delete $commits{$commit};
  		}
  	}
  	my @k = (keys %commits);
  	return (scalar @k, $k[0]);
  }
  
  sub has_no_changes {
  	my $commit = shift;
  
  	my @revs = split / /, command_oneline(
  		qw(rev-list --parents -1 -m), $commit);
  
  	# Commits with no parents, e.g. the start of a partial branch,
  	# have changes by definition.
  	return 1 if (@revs < 2);
  
  	# Commits with multiple parents, e.g a merge, have no changes
  	# by definition.
  	return 0 if (@revs > 2);
  
  	return (command_oneline("rev-parse", "$commit^{tree}") eq
  		command_oneline("rev-parse", "$commit~1^{tree}"));
  }
  
  sub tie_for_persistent_memoization {
  	my $hash = shift;
  	my $path = shift;
  
  	unless ($memo_backend) {
  		if (eval { require Git::SVN::Memoize::YAML; 1}) {
  			$memo_backend = 1;
  		} else {
  			require Memoize::Storable;
  			$memo_backend = -1;
  		}
  	}
  
  	if ($memo_backend > 0) {
  		tie %$hash => 'Git::SVN::Memoize::YAML', "$path.yaml";
  	} else {
  		# first verify that any existing file can actually be loaded
  		# (it may have been saved by an incompatible version)
  		my $db = "$path.db";
  		if (-e $db) {
  			use Storable qw(retrieve);
  
  			if (!eval { retrieve($db); 1 }) {
  				unlink $db or die "unlink $db failed: $!";
  			}
  		}
  		tie %$hash => 'Memoize::Storable', $db, 'nstore';
  	}
  }
  
  # The GIT_DIR environment variable is not always set until after the command
  # line arguments are processed, so we can't memoize in a BEGIN block.
  {
  	my $memoized = 0;
  
  	sub memoize_svn_mergeinfo_functions {
  		return if $memoized;
  		$memoized = 1;
  
  		my $cache_path = svn_dir() . '/.caches/';
  		mkpath([$cache_path]) unless -d $cache_path;
  
  		my %lookup_svn_merge_cache;
  		my %check_cherry_pick2_cache;
  		my %has_no_changes_cache;
  
  		tie_for_persistent_memoization(\%lookup_svn_merge_cache,
  		    "$cache_path/lookup_svn_merge");
  		memoize 'lookup_svn_merge',
  			SCALAR_CACHE => 'FAULT',
  			LIST_CACHE => ['HASH' => \%lookup_svn_merge_cache],
  		;
  
  		tie_for_persistent_memoization(\%check_cherry_pick2_cache,
  		    "$cache_path/check_cherry_pick2");
  		memoize 'check_cherry_pick2',
  			SCALAR_CACHE => 'FAULT',
  			LIST_CACHE => ['HASH' => \%check_cherry_pick2_cache],
  		;
  
  		tie_for_persistent_memoization(\%has_no_changes_cache,
  		    "$cache_path/has_no_changes");
  		memoize 'has_no_changes',
  			SCALAR_CACHE => ['HASH' => \%has_no_changes_cache],
  			LIST_CACHE => 'FAULT',
  		;
  	}
  
  	sub unmemoize_svn_mergeinfo_functions {
  		return if not $memoized;
  		$memoized = 0;
  
  		Memoize::unmemoize 'lookup_svn_merge';
  		Memoize::unmemoize 'check_cherry_pick2';
  		Memoize::unmemoize 'has_no_changes';
  	}
  
  	sub clear_memoized_mergeinfo_caches {
  		die "Only call this method in non-memoized context" if ($memoized);
  
  		my $cache_path = svn_dir() . '/.caches/';
  		return unless -d $cache_path;
  
  		for my $cache_file (("$cache_path/lookup_svn_merge",
  				     "$cache_path/check_cherry_pick", # old
  				     "$cache_path/check_cherry_pick2",
  				     "$cache_path/has_no_changes")) {
  			for my $suffix (qw(yaml db)) {
  				my $file = "$cache_file.$suffix";
  				next unless -e $file;
  				unlink($file) or die "unlink($file) failed: $!\n";
  			}
  		}
  	}
  
  
  	Memoize::memoize 'Git::SVN::repos_root';
  }
  
  END {
  	# Force cache writeout explicitly instead of waiting for
  	# global destruction to avoid segfault in Storable:
  	# http://rt.cpan.org/Public/Bug/Display.html?id=36087
  	unmemoize_svn_mergeinfo_functions();
  }
  
  sub parents_exclude {
  	my $parents = shift;
  	my @commits = @_;
  	return unless @commits;
  
  	my @excluded;
  	my $excluded;
  	do {
  		my @cmd = ('rev-list', "-1", @commits, "--not", @$parents );
  		$excluded = command_oneline(@cmd);
  		if ( $excluded ) {
  			my @new;
  			my $found;
  			for my $commit ( @commits ) {
  				if ( $commit eq $excluded ) {
  					push @excluded, $commit;
  					$found++;
  				}
  				else {
  					push @new, $commit;
  				}
  			}
  			die "saw commit '$excluded' in rev-list output, "
  				."but we didn't ask for that commit (wanted: @commits --not @$parents)"
  					unless $found;
  			@commits = @new;
  		}
  	}
  		while ($excluded and @commits);
  
  	return @excluded;
  }
  
  # Compute what's new in svn:mergeinfo.
  sub mergeinfo_changes {
  	my ($self, $old_path, $old_rev, $path, $rev, $mergeinfo_prop) = @_;
  	my %minfo = map {split ":", $_ } split "\n", $mergeinfo_prop;
  	my $old_minfo = {};
  
  	my $ra = $self->ra;
  	# Give up if $old_path isn't in the repo.
  	# This is probably a merge on a subtree.
  	if ($ra->check_path($old_path, $old_rev) != $SVN::Node::dir) {
  		warn "W: ignoring svn:mergeinfo on $old_path, ",
  			"directory didn't exist in r$old_rev\n";
  		return {};
  	}
  	my (undef, undef, $props) = $ra->get_dir($old_path, $old_rev);
  	if (defined $props->{"svn:mergeinfo"}) {
  		my %omi = map {split ":", $_ } split "\n",
  			$props->{"svn:mergeinfo"};
  		$old_minfo = \%omi;
  	}
  
  	my %changes = ();
  	foreach my $p (keys %minfo) {
  		my $a = $old_minfo->{$p} || "";
  		my $b = $minfo{$p};
  		# Omit merged branches whose ranges lists are unchanged.
  		next if $a eq $b;
  		# Remove any common range list prefix.
  		($a ^ $b) =~ /^[\0]*/;
  		my $common_prefix = rindex $b, ",", $+[0] - 1;
  		$changes{$p} = substr $b, $common_prefix + 1;
  	}
  	print STDERR "Checking svn:mergeinfo changes since r$old_rev: ",
  		scalar(keys %minfo), " sources, ",
  		scalar(keys %changes), " changed\n";
  
  	return \%changes;
  }
  
  # note: this function should only be called if the various dirprops
  # have actually changed
  sub find_extra_svn_parents {
  	my ($self, $mergeinfo, $parents) = @_;
  	# aha!  svk:merge property changed...
  
  	memoize_svn_mergeinfo_functions();
  
  	# We first search for merged tips which are not in our
  	# history.  Then, we figure out which git revisions are in
  	# that tip, but not this revision.  If all of those revisions
  	# are now marked as merge, we can add the tip as a parent.
  	my @merges = sort keys %$mergeinfo;
  	my @merge_tips;
  	my $url = $self->url;
  	my $uuid = $self->ra_uuid;
  	my @all_ranges;
  	for my $merge ( @merges ) {
  		my ($tip_commit, @ranges) =
  			lookup_svn_merge( $uuid, $url,
  					  $merge, $mergeinfo->{$merge} );
  		unless (!$tip_commit or
  				grep { $_ eq $tip_commit } @$parents ) {
  			push @merge_tips, $tip_commit;
  			push @all_ranges, @ranges;
  		} else {
  			push @merge_tips, undef;
  		}
  	}
  
  	my %excluded = map { $_ => 1 }
  		parents_exclude($parents, grep { defined } @merge_tips);
  
  	# check merge tips for new parents
  	my @new_parents;
  	for my $merge_tip ( @merge_tips ) {
  		my $merge = shift @merges;
  		next unless $merge_tip and $excluded{$merge_tip};
  		my $spec = "$merge:$mergeinfo->{$merge}";
  
  		# check out 'new' tips
  		my $merge_base;
  		eval {
  			$merge_base = command_oneline(
  				"merge-base",
  				@$parents, $merge_tip,
  			);
  		};
  		if ($@) {
  			die "An error occurred during merge-base"
  				unless $@->isa("Git::Error::Command");
  
  			warn "W: Cannot find common ancestor between ".
  			     "@$parents and $merge_tip. Ignoring merge info.\n";
  			next;
  		}
  
  		# double check that there are no missing non-merge commits
  		my ($ninc, $ifirst) = check_cherry_pick2(
  			$merge_base, $merge_tip,
  			$parents,
  			@all_ranges,
  		       );
  
  		if ($ninc) {
  			warn "W: svn cherry-pick ignored ($spec) - missing " .
  				"$ninc commit(s) (eg $ifirst)\n";
  		} else {
  			warn "Found merge parent ($spec): ", $merge_tip, "\n";
  			push @new_parents, $merge_tip;
  		}
  	}
  
  	# cater for merges which merge commits from multiple branches
  	if ( @new_parents > 1 ) {
  		for ( my $i = 0; $i <= $#new_parents; $i++ ) {
  			for ( my $j = 0; $j <= $#new_parents; $j++ ) {
  				next if $i == $j;
  				next unless $new_parents[$i];
  				next unless $new_parents[$j];
  				my $revs = command_oneline(
  					"rev-list", "-1",
  					"$new_parents[$i]..$new_parents[$j]",
  				       );
  				if ( !$revs ) {
  					undef($new_parents[$j]);
  				}
  			}
  		}
  	}
  	push @$parents, grep { defined } @new_parents;
  }
  
  sub make_log_entry {
  	my ($self, $rev, $parents, $ed, $parent_rev, $parent_path) = @_;
  	my $untracked = $self->get_untracked($ed);
  
  	my @parents = @$parents;
  	my $props = $ed->{dir_prop}{$self->path};
  	if ($self->follow_parent) {
  		my $tickets = $props->{"svk:merge"};
  		if ($tickets) {
  			$self->find_extra_svk_parents($tickets, \@parents);
  		}
  
  		my $mergeinfo_prop = $props->{"svn:mergeinfo"};
  		if ($mergeinfo_prop) {
  			my $mi_changes = $self->mergeinfo_changes(
  						$parent_path,
  						$parent_rev,
  						$self->path,
  						$rev,
  						$mergeinfo_prop);
  			$self->find_extra_svn_parents($mi_changes, \@parents);
  		}
  	}
  
  	open my $un, '>>', "$self->{dir}/unhandled.log" or croak $!;
  	print $un "r$rev\n" or croak $!;
  	print $un $_, "\n" foreach @$untracked;
  	my %log_entry = ( parents => \@parents, revision => $rev,
  	                  log => '');
  
  	my $headrev;
  	my $logged = delete $self->{logged_rev_props};
  	if (!$logged || $self->{-want_revprops}) {
  		my $rp = $self->ra->rev_proplist($rev);
  		foreach (sort keys %$rp) {
  			my $v = $rp->{$_};
  			if (/^svn:(author|date|log)$/) {
  				$log_entry{$1} = $v;
  			} elsif ($_ eq 'svm:headrev') {
  				$headrev = $v;
  			} else {
  				print $un "  rev_prop: ", uri_encode($_), ' ',
  					  uri_encode($v), "\n";
  			}
  		}
  	} else {
  		map { $log_entry{$_} = $logged->{$_} } keys %$logged;
  	}
  	close $un or croak $!;
  
  	$log_entry{date} = parse_svn_date($log_entry{date});
  	$log_entry{log} .= "\n";
  	my $author = $log_entry{author} = check_author($log_entry{author});
  	my ($name, $email) = defined $::users{$author} ? @{$::users{$author}}
  						       : ($author, undef);
  
  	my ($commit_name, $commit_email) = ($name, $email);
  	if ($_use_log_author) {
  		my $name_field;
  		if ($log_entry{log} =~ /From:\s+(.*\S)\s*\n/i) {
  			$name_field = $1;
  		} elsif ($log_entry{log} =~ /Signed-off-by:\s+(.*\S)\s*\n/i) {
  			$name_field = $1;
  		}
  		if (!defined $name_field) {
  			if (!defined $email) {
  				$email = $name;
  			}
  		} elsif ($name_field =~ /(.*?)\s+<(.*)>/) {
  			($name, $email) = ($1, $2);
  		} elsif ($name_field =~ /(.*)@/) {
  			($name, $email) = ($1, $name_field);
  		} else {
  			($name, $email) = ($name_field, $name_field);
  		}
  	}
  	if (defined $headrev && $self->use_svm_props) {
  		if ($self->rewrite_root) {
  			die "Can't have both 'useSvmProps' and 'rewriteRoot' ",
  			    "options set!\n";
  		}
  		if ($self->rewrite_uuid) {
  			die "Can't have both 'useSvmProps' and 'rewriteUUID' ",
  			    "options set!\n";
  		}
  		my ($uuid, $r) = $headrev =~ m{^([a-f\d\-]{30,}):(\d+)$}i;
  		# we don't want "SVM: initializing mirror for junk" ...
  		return undef if $r == 0;
  		my $svm = $self->svm;
  		if ($uuid ne $svm->{uuid}) {
  			die "UUID mismatch on SVM path:\n",
  			    "expected: $svm->{uuid}\n",
  			    "     got: $uuid\n";
  		}
  		my $full_url = $self->full_url;
  		$full_url =~ s#^\Q$svm->{replace}\E(/|$)#$svm->{source}$1# or
  		             die "Failed to replace '$svm->{replace}' with ",
  		                 "'$svm->{source}' in $full_url\n";
  		# throw away username for storing in records
  		remove_username($full_url);
  		$log_entry{metadata} = "$full_url\@$r $uuid";
  		$log_entry{svm_revision} = $r;
  		$email ||= "$author\@$uuid";
  		$commit_email ||= "$author\@$uuid";
  	} elsif ($self->use_svnsync_props) {
  		my $full_url = canonicalize_url(
  			add_path_to_url( $self->svnsync->{url}, $self->path )
  		);
  		remove_username($full_url);
  		my $uuid = $self->svnsync->{uuid};
  		$log_entry{metadata} = "$full_url\@$rev $uuid";
  		$email ||= "$author\@$uuid";
  		$commit_email ||= "$author\@$uuid";
  	} else {
  		my $url = $self->metadata_url;
  		remove_username($url);
  		my $uuid = $self->rewrite_uuid || $self->ra->get_uuid;
  		$log_entry{metadata} = "$url\@$rev " . $uuid;
  		$email ||= "$author\@" . $uuid;
  		$commit_email ||= "$author\@" . $uuid;
  	}
  	$log_entry{name} = $name;
  	$log_entry{email} = $email;
  	$log_entry{commit_name} = $commit_name;
  	$log_entry{commit_email} = $commit_email;
  	\%log_entry;
  }
  
  sub fetch {
  	my ($self, $min_rev, $max_rev, @parents) = @_;
  	my ($last_rev, $last_commit) = $self->last_rev_commit;
  	my ($base, $head) = $self->get_fetch_range($min_rev, $max_rev);
  	$self->ra->gs_fetch_loop_common($base, $head, [$self]);
  }
  
  sub set_tree_cb {
  	my ($self, $log_entry, $tree, $rev, $date, $author) = @_;
  	$self->{inject_parents} = { $rev => $tree };
  	$self->fetch(undef, undef);
  }
  
  sub set_tree {
  	my ($self, $tree) = (shift, shift);
  	my $log_entry = ::get_commit_entry($tree);
  	unless ($self->{last_rev}) {
  		fatal("Must have an existing revision to commit");
  	}
  	my %ed_opts = ( r => $self->{last_rev},
  	                log => $log_entry->{log},
  	                ra => $self->ra,
  	                tree_a => $self->{last_commit},
  	                tree_b => $tree,
  	                editor_cb => sub {
  			       $self->set_tree_cb($log_entry, $tree, @_) },
  	                svn_path => $self->path );
  	if (!Git::SVN::Editor->new(\%ed_opts)->apply_diff) {
  		print "No changes\nr$self->{last_rev} = $tree\n";
  	}
  }
  
  sub rebuild_from_rev_db {
  	my ($self, $path) = @_;
  	my $r = -1;
  	open my $fh, '<', $path or croak "open: $!";
  	binmode $fh or croak "binmode: $!";
  	while (<$fh>) {
  		length($_) == 41 or croak "inconsistent size in ($_) != 41";
  		chomp($_);
  		++$r;
  		next if $_ eq ('0' x 40);
  		$self->rev_map_set($r, $_);
  		print "r$r = $_\n";
  	}
  	close $fh or croak "close: $!";
  	unlink $path or croak "unlink: $!";
  }
  
  #define a global associate map to record rebuild status
  my %rebuild_status;
  #define a global associate map to record rebuild verify status
  my %rebuild_verify_status;
  
  sub rebuild {
  	my ($self) = @_;
  	my $map_path = $self->map_path;
  	my $partial = (-e $map_path && ! -z $map_path);
  	my $verify_key = $self->refname.'^0';
  	if (!$rebuild_verify_status{$verify_key}) {
  		my $verify_result = ::verify_ref($verify_key);
  		if ($verify_result) {
  			$rebuild_verify_status{$verify_key} = 1;
  		}
  	}
  	if (!$rebuild_verify_status{$verify_key}) {
  		return;
  	}
  	if (!$partial && ($self->use_svm_props || $self->no_metadata)) {
  		my $rev_db = $self->rev_db_path;
  		$self->rebuild_from_rev_db($rev_db);
  		if ($self->use_svm_props) {
  			my $svm_rev_db = $self->rev_db_path($self->svm_uuid);
  			$self->rebuild_from_rev_db($svm_rev_db);
  		}
  		$self->unlink_rev_db_symlink;
  		return;
  	}
  	print "Rebuilding $map_path ...\n" if (!$partial);
  	my ($base_rev, $head) = ($partial ? $self->rev_map_max_norebuild(1) :
  		(undef, undef));
  	my $key_value = ($head ? "$head.." : "") . $self->refname;
  	if (exists $rebuild_status{$key_value}) {
  		print "Done rebuilding $map_path\n" if (!$partial || !$head);
  		my $rev_db_path = $self->rev_db_path;
  		if (-f $self->rev_db_path) {
  			unlink $self->rev_db_path or croak "unlink: $!";
  		}
  		$self->unlink_rev_db_symlink;
  		return;
  	}
  	my ($log, $ctx) =
  		command_output_pipe(qw/rev-list --pretty=raw --reverse/,
  				$key_value,
  				'--');
  	$rebuild_status{$key_value} = 1;
  	my $metadata_url = $self->metadata_url;
  	remove_username($metadata_url);
  	my $svn_uuid = $self->rewrite_uuid || $self->ra_uuid;
  	my $c;
  	while (<$log>) {
  		if ( m{^commit ($::sha1)$} ) {
  			$c = $1;
  			next;
  		}
  		next unless s{^\s*(git-svn-id:)}{$1};
  		my ($url, $rev, $uuid) = ::extract_metadata($_);
  		remove_username($url);
  
  		# ignore merges (from set-tree)
  		next if (!defined $rev || !$uuid);
  
  		# if we merged or otherwise started elsewhere, this is
  		# how we break out of it
  		if (($uuid ne $svn_uuid) ||
  		    ($metadata_url && $url && ($url ne $metadata_url))) {
  			next;
  		}
  		if ($partial && $head) {
  			print "Partial-rebuilding $map_path ...\n";
  			print "Currently at $base_rev = $head\n";
  			$head = undef;
  		}
  
  		$self->rev_map_set($rev, $c);
  		print "r$rev = $c\n";
  	}
  	command_close_pipe($log, $ctx);
  	print "Done rebuilding $map_path\n" if (!$partial || !$head);
  	my $rev_db_path = $self->rev_db_path;
  	if (-f $self->rev_db_path) {
  		unlink $self->rev_db_path or croak "unlink: $!";
  	}
  	$self->unlink_rev_db_symlink;
  }
  
  # rev_map:
  # Tie::File seems to be prone to offset errors if revisions get sparse,
  # it's not that fast, either.  Tie::File is also not in Perl 5.6.  So
  # one of my favorite modules is out :<  Next up would be one of the DBM
  # modules, but I'm not sure which is most portable...
  #
  # This is the replacement for the rev_db format, which was too big
  # and inefficient for large repositories with a lot of sparse history
  # (mainly tags)
  #
  # The format is this:
  #   - 24 bytes for every record,
  #     * 4 bytes for the integer representing an SVN revision number
  #     * 20 bytes representing the sha1 of a git commit
  #   - No empty padding records like the old format
  #     (except the last record, which can be overwritten)
  #   - new records are written append-only since SVN revision numbers
  #     increase monotonically
  #   - lookups on SVN revision number are done via a binary search
  #   - Piping the file to xxd -c24 is a good way of dumping it for
  #     viewing or editing (piped back through xxd -r), should the need
  #     ever arise.
  #   - The last record can be padding revision with an all-zero sha1
  #     This is used to optimize fetch performance when using multiple
  #     "fetch" directives in .git/config
  #
  # These files are disposable unless noMetadata or useSvmProps is set
  
  sub _rev_map_set {
  	my ($fh, $rev, $commit) = @_;
  
  	binmode $fh or croak "binmode: $!";
  	my $size = (stat($fh))[7];
  	($size % 24) == 0 or croak "inconsistent size: $size";
  
  	my $wr_offset = 0;
  	if ($size > 0) {
  		sysseek($fh, -24, SEEK_END) or croak "seek: $!";
  		my $read = sysread($fh, my $buf, 24) or croak "read: $!";
  		$read == 24 or croak "read only $read bytes (!= 24)";
  		my ($last_rev, $last_commit) = unpack(rev_map_fmt, $buf);
  		if ($last_commit eq ('0' x40)) {
  			if ($size >= 48) {
  				sysseek($fh, -48, SEEK_END) or croak "seek: $!";
  				$read = sysread($fh, $buf, 24) or
  				    croak "read: $!";
  				$read == 24 or
  				    croak "read only $read bytes (!= 24)";
  				($last_rev, $last_commit) =
  				    unpack(rev_map_fmt, $buf);
  				if ($last_commit eq ('0' x40)) {
  					croak "inconsistent .rev_map\n";
  				}
  			}
  			if ($last_rev >= $rev) {
  				croak "last_rev is higher!: $last_rev >= $rev";
  			}
  			$wr_offset = -24;
  		}
  	}
  	sysseek($fh, $wr_offset, SEEK_END) or croak "seek: $!";
  	syswrite($fh, pack(rev_map_fmt, $rev, $commit), 24) == 24 or
  	  croak "write: $!";
  }
  
  sub _rev_map_reset {
  	my ($fh, $rev, $commit) = @_;
  	my $c = _rev_map_get($fh, $rev);
  	$c eq $commit or die "_rev_map_reset(@_) commit $c does not match!\n";
  	my $offset = sysseek($fh, 0, SEEK_CUR) or croak "seek: $!";
  	truncate $fh, $offset or croak "truncate: $!";
  }
  
  sub mkfile {
  	my ($path) = @_;
  	unless (-e $path) {
  		my ($dir, $base) = ($path =~ m#^(.*?)/?([^/]+)$#);
  		mkpath([$dir]) unless -d $dir;
  		open my $fh, '>>', $path or die "Couldn't create $path: $!\n";
  		close $fh or die "Couldn't close (create) $path: $!\n";
  	}
  }
  
  sub rev_map_set {
  	my ($self, $rev, $commit, $update_ref, $uuid) = @_;
  	defined $commit or die "missing arg3\n";
  	length $commit == 40 or die "arg3 must be a full SHA1 hexsum\n";
  	my $db = $self->map_path($uuid);
  	my $db_lock = "$db.lock";
  	my $sigmask;
  	$update_ref ||= 0;
  	if ($update_ref) {
  		$sigmask = POSIX::SigSet->new();
  		my $signew = POSIX::SigSet->new(SIGINT, SIGHUP, SIGTERM,
  			SIGALRM, SIGUSR1, SIGUSR2);
  		sigprocmask(SIG_BLOCK, $signew, $sigmask) or
  			croak "Can't block signals: $!";
  	}
  	mkfile($db);
  
  	$LOCKFILES{$db_lock} = 1;
  	my $sync;
  	# both of these options make our .rev_db file very, very important
  	# and we can't afford to lose it because rebuild() won't work
  	if ($self->use_svm_props || $self->no_metadata) {
  		require File::Copy;
  		$sync = 1;
  		File::Copy::copy($db, $db_lock) or die "rev_map_set(@_): ",
  					   "Failed to copy: ",
  					   "$db => $db_lock ($!)\n";
  	} else {
  		rename $db, $db_lock or die "rev_map_set(@_): ",
  					    "Failed to rename: ",
  					    "$db => $db_lock ($!)\n";
  	}
  
  	sysopen(my $fh, $db_lock, O_RDWR | O_CREAT)
  	     or croak "Couldn't open $db_lock: $!\n";
  	if ($update_ref eq 'reset') {
  		clear_memoized_mergeinfo_caches();
  		_rev_map_reset($fh, $rev, $commit);
  	} else {
  		_rev_map_set($fh, $rev, $commit);
  	}
  
  	if ($sync) {
  		$fh->flush or die "Couldn't flush $db_lock: $!\n";
  		$fh->sync or die "Couldn't sync $db_lock: $!\n";
  	}
  	close $fh or croak $!;
  	if ($update_ref) {
  		$_head = $self;
  		my $note = "";
  		$note = " ($update_ref)" if ($update_ref !~ /^\d*$/);
  		command_noisy('update-ref', '-m', "r$rev$note",
  		              $self->refname, $commit);
  	}
  	rename $db_lock, $db or die "rev_map_set(@_): ", "Failed to rename: ",
  	                            "$db_lock => $db ($!)\n";
  	delete $LOCKFILES{$db_lock};
  	if ($update_ref) {
  		sigprocmask(SIG_SETMASK, $sigmask) or
  			croak "Can't restore signal mask: $!";
  	}
  }
  
  # If want_commit, this will return an array of (rev, commit) where
  # commit _must_ be a valid commit in the archive.
  # Otherwise, it'll return the max revision (whether or not the
  # commit is valid or just a 0x40 placeholder).
  sub rev_map_max {
  	my ($self, $want_commit) = @_;
  	$self->rebuild;
  	my ($r, $c) = $self->rev_map_max_norebuild($want_commit);
  	$want_commit ? ($r, $c) : $r;
  }
  
  sub rev_map_max_norebuild {
  	my ($self, $want_commit) = @_;
  	my $map_path = $self->map_path;
  	stat $map_path or return $want_commit ? (0, undef) : 0;
  	sysopen(my $fh, $map_path, O_RDONLY) or croak "open: $!";
  	binmode $fh or croak "binmode: $!";
  	my $size = (stat($fh))[7];
  	($size % 24) == 0 or croak "inconsistent size: $size";
  
  	if ($size == 0) {
  		close $fh or croak "close: $!";
  		return $want_commit ? (0, undef) : 0;
  	}
  
  	sysseek($fh, -24, SEEK_END) or croak "seek: $!";
  	sysread($fh, my $buf, 24) == 24 or croak "read: $!";
  	my ($r, $c) = unpack(rev_map_fmt, $buf);
  	if ($want_commit && $c eq ('0' x40)) {
  		if ($size < 48) {
  			return $want_commit ? (0, undef) : 0;
  		}
  		sysseek($fh, -48, SEEK_END) or croak "seek: $!";
  		sysread($fh, $buf, 24) == 24 or croak "read: $!";
  		($r, $c) = unpack(rev_map_fmt, $buf);
  		if ($c eq ('0'x40)) {
  			croak "Penultimate record is all-zeroes in $map_path";
  		}
  	}
  	close $fh or croak "close: $!";
  	$want_commit ? ($r, $c) : $r;
  }
  
  sub rev_map_get {
  	my ($self, $rev, $uuid) = @_;
  	my $map_path = $self->map_path($uuid);
  	return undef unless -e $map_path;
  
  	sysopen(my $fh, $map_path, O_RDONLY) or croak "open: $!";
  	my $c = _rev_map_get($fh, $rev);
  	close($fh) or croak "close: $!";
  	$c
  }
  
  sub _rev_map_get {
  	my ($fh, $rev) = @_;
  
  	binmode $fh or croak "binmode: $!";
  	my $size = (stat($fh))[7];
  	($size % 24) == 0 or croak "inconsistent size: $size";
  
  	if ($size == 0) {
  		return undef;
  	}
  
  	my ($l, $u) = (0, $size - 24);
  	my ($r, $c, $buf);
  
  	while ($l <= $u) {
  		my $i = int(($l/24 + $u/24) / 2) * 24;
  		sysseek($fh, $i, SEEK_SET) or croak "seek: $!";
  		sysread($fh, my $buf, 24) == 24 or croak "read: $!";
  		my ($r, $c) = unpack(rev_map_fmt, $buf);
  
  		if ($r < $rev) {
  			$l = $i + 24;
  		} elsif ($r > $rev) {
  			$u = $i - 24;
  		} else { # $r == $rev
  			return $c eq ('0' x 40) ? undef : $c;
  		}
  	}
  	undef;
  }
  
  # Finds the first svn revision that exists on (if $eq_ok is true) or
  # before $rev for the current branch.  It will not search any lower
  # than $min_rev.  Returns the git commit hash and svn revision number
  # if found, else (undef, undef).
  sub find_rev_before {
  	my ($self, $rev, $eq_ok, $min_rev) = @_;
  	--$rev unless $eq_ok;
  	$min_rev ||= 1;
  	my $max_rev = $self->rev_map_max;
  	$rev = $max_rev if ($rev > $max_rev);
  	while ($rev >= $min_rev) {
  		if (my $c = $self->rev_map_get($rev)) {
  			return ($rev, $c);
  		}
  		--$rev;
  	}
  	return (undef, undef);
  }
  
  # Finds the first svn revision that exists on (if $eq_ok is true) or
  # after $rev for the current branch.  It will not search any higher
  # than $max_rev.  Returns the git commit hash and svn revision number
  # if found, else (undef, undef).
  sub find_rev_after {
  	my ($self, $rev, $eq_ok, $max_rev) = @_;
  	++$rev unless $eq_ok;
  	$max_rev ||= $self->rev_map_max;
  	while ($rev <= $max_rev) {
  		if (my $c = $self->rev_map_get($rev)) {
  			return ($rev, $c);
  		}
  		++$rev;
  	}
  	return (undef, undef);
  }
  
  sub _new {
  	my ($class, $repo_id, $ref_id, $path) = @_;
  	unless (defined $repo_id && length $repo_id) {
  		$repo_id = $default_repo_id;
  	}
  	unless (defined $ref_id && length $ref_id) {
  		# Access the prefix option from the git-svn main program if it's loaded.
  		my $prefix = defined &::opt_prefix ? ::opt_prefix() : "";
  		$_[2] = $ref_id =
  		             "refs/remotes/$prefix$default_ref_id";
  	}
  	$_[1] = $repo_id;
  	my $svn_dir = svn_dir();
  	my $dir = "$svn_dir/$ref_id";
  
  	# Older repos imported by us used $svn_dir/foo instead of
  	# $svn_dir/refs/remotes/foo when tracking refs/remotes/foo
  	if ($ref_id =~ m{^refs/remotes/(.+)}) {
  		my $old_dir = "$svn_dir/$1";
  		if (-d $old_dir && ! -d $dir) {
  			$dir = $old_dir;
  		}
  	}
  
  	$_[3] = $path = '' unless (defined $path);
  	mkpath([$dir]);
  	my $obj = bless {
  		ref_id => $ref_id, dir => $dir, index => "$dir/index",
  	        config => "$svn_dir/config",
  	        map_root => "$dir/.rev_map", repo_id => $repo_id }, $class;
  
  	# Ensure it gets canonicalized
  	$obj->path($path);
  
  	return $obj;
  }
  
  sub path {
  	my $self = shift;
  
  	if (@_) {
  		my $path = shift;
  		$self->{_path} = canonicalize_path($path);
  		return;
  	}
  
  	return $self->{_path};
  }
  
  sub url {
  	my $self = shift;
  
  	if (@_) {
  		my $url = shift;
  		$self->{url} = canonicalize_url($url);
  		return;
  	}
  
  	return $self->{url};
  }
  
  # for read-only access of old .rev_db formats
  sub unlink_rev_db_symlink {
  	my ($self) = @_;
  	my $link = $self->rev_db_path;
  	$link =~ s/\.[\w-]+$// or croak "missing UUID at the end of $link";
  	if (-l $link) {
  		unlink $link or croak "unlink: $link failed!";
  	}
  }
  
  sub rev_db_path {
  	my ($self, $uuid) = @_;
  	my $db_path = $self->map_path($uuid);
  	$db_path =~ s{/\.rev_map\.}{/\.rev_db\.}
  	    or croak "map_path: $db_path does not contain '/.rev_map.' !";
  	$db_path;
  }
  
  # the new replacement for .rev_db
  sub map_path {
  	my ($self, $uuid) = @_;
  	$uuid ||= $self->ra_uuid;
  	"$self->{map_root}.$uuid";
  }
  
  sub uri_encode {
  	my ($f) = @_;
  	$f =~ s#([^a-zA-Z0-9\*!\:_\./\-])#sprintf("%%%02X",ord($1))#eg;
  	$f
  }
  
  sub uri_decode {
  	my ($f) = @_;
  	$f =~ s#%([0-9a-fA-F]{2})#chr(hex($1))#eg;
  	$f
  }
  
  sub remove_username {
  	$_[0] =~ s{^([^:]*://)[^@]+@}{$1};
  }
  
  1;
GIT_SVN

$fatpacked{"Git/SVN/Editor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_EDITOR';
  package Git::SVN::Editor;
  use vars qw/@ISA $_rmdir $_cp_similarity $_find_copies_harder $_rename_limit/;
  use strict;
  use warnings;
  use SVN::Core;
  use SVN::Delta;
  use Carp qw/croak/;
  use Git qw/command command_oneline command_noisy command_output_pipe
             command_input_pipe command_close_pipe
             command_bidi_pipe command_close_bidi_pipe
             get_record/;
  
  BEGIN {
  	@ISA = qw(SVN::Delta::Editor);
  }
  
  sub new {
  	my ($class, $opts) = @_;
  	foreach (qw/svn_path r ra tree_a tree_b log editor_cb/) {
  		die "$_ required!\n" unless (defined $opts->{$_});
  	}
  
  	my $pool = SVN::Pool->new;
  	my $mods = generate_diff($opts->{tree_a}, $opts->{tree_b});
  	my $types = check_diff_paths($opts->{ra}, $opts->{svn_path},
  	                             $opts->{r}, $mods);
  
  	# $opts->{ra} functions should not be used after this:
  	my @ce  = $opts->{ra}->get_commit_editor($opts->{log},
  	                                        $opts->{editor_cb}, $pool);
  	my $self = SVN::Delta::Editor->new(@ce, $pool);
  	bless $self, $class;
  	foreach (qw/svn_path r tree_a tree_b/) {
  		$self->{$_} = $opts->{$_};
  	}
  	$self->{url} = $opts->{ra}->{url};
  	$self->{mods} = $mods;
  	$self->{types} = $types;
  	$self->{pool} = $pool;
  	$self->{bat} = { '' => $self->open_root($self->{r}, $self->{pool}) };
  	$self->{rm} = { };
  	$self->{path_prefix} = length $self->{svn_path} ?
  	                       "$self->{svn_path}/" : '';
  	$self->{config} = $opts->{config};
  	$self->{mergeinfo} = $opts->{mergeinfo};
  	$self->{pathnameencoding} = Git::config('svn.pathnameencoding');
  	return $self;
  }
  
  sub generate_diff {
  	my ($tree_a, $tree_b) = @_;
  	my @diff_tree = qw(diff-tree -z -r);
  	if ($_cp_similarity) {
  		push @diff_tree, "-C$_cp_similarity";
  	} else {
  		push @diff_tree, '-C';
  	}
  	push @diff_tree, '--find-copies-harder' if $_find_copies_harder;
  	push @diff_tree, "-l$_rename_limit" if defined $_rename_limit;
  	push @diff_tree, $tree_a, $tree_b;
  	my ($diff_fh, $ctx) = command_output_pipe(@diff_tree);
  	my $state = 'meta';
  	my @mods;
  	while (defined($_ = get_record($diff_fh, "\0"))) {
  		if ($state eq 'meta' && /^:(\d{6})\s(\d{6})\s
  					($::sha1)\s($::sha1)\s
  					([MTCRAD])\d*$/xo) {
  			push @mods, {	mode_a => $1, mode_b => $2,
  					sha1_a => $3, sha1_b => $4,
  					chg => $5 };
  			if ($5 =~ /^(?:C|R)$/) {
  				$state = 'file_a';
  			} else {
  				$state = 'file_b';
  			}
  		} elsif ($state eq 'file_a') {
  			my $x = $mods[$#mods] or croak "Empty array\n";
  			if ($x->{chg} !~ /^(?:C|R)$/) {
  				croak "Error parsing $_, $x->{chg}\n";
  			}
  			$x->{file_a} = $_;
  			$state = 'file_b';
  		} elsif ($state eq 'file_b') {
  			my $x = $mods[$#mods] or croak "Empty array\n";
  			if (exists $x->{file_a} && $x->{chg} !~ /^(?:C|R)$/) {
  				croak "Error parsing $_, $x->{chg}\n";
  			}
  			if (!exists $x->{file_a} && $x->{chg} =~ /^(?:C|R)$/) {
  				croak "Error parsing $_, $x->{chg}\n";
  			}
  			$x->{file_b} = $_;
  			$state = 'meta';
  		} else {
  			croak "Error parsing $_\n";
  		}
  	}
  	command_close_pipe($diff_fh, $ctx);
  	\@mods;
  }
  
  sub check_diff_paths {
  	my ($ra, $pfx, $rev, $mods) = @_;
  	my %types;
  	$pfx .= '/' if length $pfx;
  
  	sub type_diff_paths {
  		my ($ra, $types, $path, $rev) = @_;
  		my @p = split m#/+#, $path;
  		my $c = shift @p;
  		unless (defined $types->{$c}) {
  			$types->{$c} = $ra->check_path($c, $rev);
  		}
  		while (@p) {
  			$c .= '/' . shift @p;
  			next if defined $types->{$c};
  			$types->{$c} = $ra->check_path($c, $rev);
  		}
  	}
  
  	foreach my $m (@$mods) {
  		foreach my $f (qw/file_a file_b/) {
  			next unless defined $m->{$f};
  			my ($dir) = ($m->{$f} =~ m#^(.*?)/?(?:[^/]+)$#);
  			if (length $pfx.$dir && ! defined $types{$dir}) {
  				type_diff_paths($ra, \%types, $pfx.$dir, $rev);
  			}
  		}
  	}
  	\%types;
  }
  
  sub split_path {
  	return ($_[0] =~ m#^(.*?)/?([^/]+)$#);
  }
  
  sub repo_path {
  	my ($self, $path) = @_;
  	if (my $enc = $self->{pathnameencoding}) {
  		require Encode;
  		Encode::from_to($path, $enc, 'UTF-8');
  	}
  	$self->{path_prefix}.(defined $path ? $path : '');
  }
  
  sub url_path {
  	my ($self, $path) = @_;
  	$path = $self->repo_path($path);
  	if ($self->{url} =~ m#^https?://#) {
  		# characters are taken from subversion/libsvn_subr/path.c
  		$path =~ s#([^~a-zA-Z0-9_./!$&'()*+,-])#sprintf("%%%02X",ord($1))#eg;
  	}
  	$self->{url} . '/' . $path;
  }
  
  sub rmdirs {
  	my ($self) = @_;
  	my $rm = $self->{rm};
  	delete $rm->{''}; # we never delete the url we're tracking
  	return unless %$rm;
  
  	foreach (keys %$rm) {
  		my @d = split m#/#, $_;
  		my $c = shift @d;
  		$rm->{$c} = 1;
  		while (@d) {
  			$c .= '/' . shift @d;
  			$rm->{$c} = 1;
  		}
  	}
  	delete $rm->{$self->{svn_path}};
  	delete $rm->{''}; # we never delete the url we're tracking
  	return unless %$rm;
  
  	my ($fh, $ctx) = command_output_pipe(qw/ls-tree --name-only -r -z/,
  	                                     $self->{tree_b});
  	while (defined($_ = get_record($fh, "\0"))) {
  		my @dn = split m#/#, $_;
  		while (pop @dn) {
  			delete $rm->{join '/', @dn};
  		}
  		unless (%$rm) {
  			close $fh;
  			return;
  		}
  	}
  	command_close_pipe($fh, $ctx);
  
  	my ($r, $p, $bat) = ($self->{r}, $self->{pool}, $self->{bat});
  	foreach my $d (sort { $b =~ tr#/#/# <=> $a =~ tr#/#/# } keys %$rm) {
  		$self->close_directory($bat->{$d}, $p);
  		my ($dn) = ($d =~ m#^(.*?)/?(?:[^/]+)$#);
  		print "\tD+\t$d/\n" unless $::_q;
  		$self->SUPER::delete_entry($d, $r, $bat->{$dn}, $p);
  		delete $bat->{$d};
  	}
  }
  
  sub open_or_add_dir {
  	my ($self, $full_path, $baton, $deletions) = @_;
  	my $t = $self->{types}->{$full_path};
  	if (!defined $t) {
  		die "$full_path not known in r$self->{r} or we have a bug!\n";
  	}
  	{
  		no warnings 'once';
  		# SVN::Node::none and SVN::Node::file are used only once,
  		# so we're shutting up Perl's warnings about them.
  		if ($t == $SVN::Node::none || defined($deletions->{$full_path})) {
  			return $self->add_directory($full_path, $baton,
  			    undef, -1, $self->{pool});
  		} elsif ($t == $SVN::Node::dir) {
  			return $self->open_directory($full_path, $baton,
  			    $self->{r}, $self->{pool});
  		} # no warnings 'once'
  		print STDERR "$full_path already exists in repository at ",
  		    "r$self->{r} and it is not a directory (",
  		    ($t == $SVN::Node::file ? 'file' : 'unknown'),"/$t)\n";
  	} # no warnings 'once'
  	exit 1;
  }
  
  sub ensure_path {
  	my ($self, $path, $deletions) = @_;
  	my $bat = $self->{bat};
  	my $repo_path = $self->repo_path($path);
  	return $bat->{''} unless (length $repo_path);
  
  	my @p = split m#/+#, $repo_path;
  	my $c = shift @p;
  	$bat->{$c} ||= $self->open_or_add_dir($c, $bat->{''}, $deletions);
  	while (@p) {
  		my $c0 = $c;
  		$c .= '/' . shift @p;
  		$bat->{$c} ||= $self->open_or_add_dir($c, $bat->{$c0}, $deletions);
  	}
  	return $bat->{$c};
  }
  
  # Subroutine to convert a globbing pattern to a regular expression.
  # From perl cookbook.
  sub glob2pat {
  	my $globstr = shift;
  	my %patmap = ('*' => '.*', '?' => '.', '[' => '[', ']' => ']');
  	$globstr =~ s{(.)} { $patmap{$1} || "\Q$1" }ge;
  	return '^' . $globstr . '$';
  }
  
  sub check_autoprop {
  	my ($self, $pattern, $properties, $file, $fbat) = @_;
  	# Convert the globbing pattern to a regular expression.
  	my $regex = glob2pat($pattern);
  	# Check if the pattern matches the file name.
  	if($file =~ m/($regex)/) {
  		# Parse the list of properties to set.
  		my @props = split(/;/, $properties);
  		foreach my $prop (@props) {
  			# Parse 'name=value' syntax and set the property.
  			if ($prop =~ /([^=]+)=(.*)/) {
  				my ($n,$v) = ($1,$2);
  				for ($n, $v) {
  					s/^\s+//; s/\s+$//;
  				}
  				$self->change_file_prop($fbat, $n, $v);
  			}
  		}
  	}
  }
  
  sub apply_autoprops {
  	my ($self, $file, $fbat) = @_;
  	my $conf_t = ${$self->{config}}{'config'};
  	no warnings 'once';
  	# Check [miscellany]/enable-auto-props in svn configuration.
  	if (SVN::_Core::svn_config_get_bool(
  		$conf_t,
  		$SVN::_Core::SVN_CONFIG_SECTION_MISCELLANY,
  		$SVN::_Core::SVN_CONFIG_OPTION_ENABLE_AUTO_PROPS,
  		0)) {
  		# Auto-props are enabled.  Enumerate them to look for matches.
  		my $callback = sub {
  			$self->check_autoprop($_[0], $_[1], $file, $fbat);
  		};
  		SVN::_Core::svn_config_enumerate(
  			$conf_t,
  			$SVN::_Core::SVN_CONFIG_SECTION_AUTO_PROPS,
  			$callback);
  	}
  }
  
  sub check_attr {
  	my ($attr,$path) = @_;
  	my $val = command_oneline("check-attr", $attr, "--", $path);
  	if ($val) { $val =~ s/^[^:]*:\s*[^:]*:\s*(.*)\s*$/$1/; }
  	return $val;
  }
  
  sub apply_manualprops {
  	my ($self, $file, $fbat) = @_;
  	my $pending_properties = check_attr( "svn-properties", $file );
  	if ($pending_properties eq "") { return; }
  	# Parse the list of properties to set.
  	my @props = split(/;/, $pending_properties);
  	# TODO: get existing properties to compare to
  	# - this fails for add so currently not done
  	# my $existing_props = ::get_svnprops($file);
  	my $existing_props = {};
  	# TODO: caching svn properties or storing them in .gitattributes
  	# would make that faster
  	foreach my $prop (@props) {
  		# Parse 'name=value' syntax and set the property.
  		if ($prop =~ /([^=]+)=(.*)/) {
  			my ($n,$v) = ($1,$2);
  			for ($n, $v) {
  				s/^\s+//; s/\s+$//;
  			}
  			my $existing = $existing_props->{$n};
  			if (!defined($existing) || $existing ne $v) {
  			    $self->change_file_prop($fbat, $n, $v);
  			}
  		}
  	}
  }
  
  sub A {
  	my ($self, $m, $deletions) = @_;
  	my ($dir, $file) = split_path($m->{file_b});
  	my $pbat = $self->ensure_path($dir, $deletions);
  	my $fbat = $self->add_file($self->repo_path($m->{file_b}), $pbat,
  					undef, -1);
  	print "\tA\t$m->{file_b}\n" unless $::_q;
  	$self->apply_autoprops($file, $fbat);
  	$self->apply_manualprops($m->{file_b}, $fbat);
  	$self->chg_file($fbat, $m);
  	$self->close_file($fbat,undef,$self->{pool});
  }
  
  sub C {
  	my ($self, $m, $deletions) = @_;
  	my ($dir, $file) = split_path($m->{file_b});
  	my $pbat = $self->ensure_path($dir, $deletions);
  	# workaround for a bug in svn serf backend (v1.8.5 and below):
  	# store third argument to ->add_file() in a local variable, to make it
  	# have the same lifetime as $fbat
  	my $upa = $self->url_path($m->{file_a});
  	my $fbat = $self->add_file($self->repo_path($m->{file_b}), $pbat,
  				$upa, $self->{r});
  	print "\tC\t$m->{file_a} => $m->{file_b}\n" unless $::_q;
  	$self->apply_manualprops($m->{file_b}, $fbat);
  	$self->chg_file($fbat, $m);
  	$self->close_file($fbat,undef,$self->{pool});
  }
  
  sub delete_entry {
  	my ($self, $path, $pbat) = @_;
  	my $rpath = $self->repo_path($path);
  	my ($dir, $file) = split_path($rpath);
  	$self->{rm}->{$dir} = 1;
  	$self->SUPER::delete_entry($rpath, $self->{r}, $pbat, $self->{pool});
  }
  
  sub R {
  	my ($self, $m, $deletions) = @_;
  	my ($dir, $file) = split_path($m->{file_b});
  	my $pbat = $self->ensure_path($dir, $deletions);
  	# workaround for a bug in svn serf backend, see comment in C() above
  	my $upa = $self->url_path($m->{file_a});
  	my $fbat = $self->add_file($self->repo_path($m->{file_b}), $pbat,
  				$upa, $self->{r});
  	print "\tR\t$m->{file_a} => $m->{file_b}\n" unless $::_q;
  	$self->apply_autoprops($file, $fbat);
  	$self->apply_manualprops($m->{file_b}, $fbat);
  	$self->chg_file($fbat, $m);
  	$self->close_file($fbat,undef,$self->{pool});
  
  	($dir, $file) = split_path($m->{file_a});
  	$pbat = $self->ensure_path($dir, $deletions);
  	$self->delete_entry($m->{file_a}, $pbat);
  }
  
  sub M {
  	my ($self, $m, $deletions) = @_;
  	my ($dir, $file) = split_path($m->{file_b});
  	my $pbat = $self->ensure_path($dir, $deletions);
  	my $fbat = $self->open_file($self->repo_path($m->{file_b}),
  				$pbat,$self->{r},$self->{pool});
  	print "\t$m->{chg}\t$m->{file_b}\n" unless $::_q;
  	$self->apply_manualprops($m->{file_b}, $fbat);
  	$self->chg_file($fbat, $m);
  	$self->close_file($fbat,undef,$self->{pool});
  }
  
  sub T {
  	my ($self, $m, $deletions) = @_;
  
  	# Work around subversion issue 4091: toggling the "is a
  	# symlink" property requires removing and re-adding a
  	# file or else "svn up" on affected clients trips an
  	# assertion and aborts.
  	if (($m->{mode_b} =~ /^120/ && $m->{mode_a} !~ /^120/) ||
  	    ($m->{mode_b} !~ /^120/ && $m->{mode_a} =~ /^120/)) {
  		$self->D({
  			mode_a => $m->{mode_a}, mode_b => '000000',
  			sha1_a => $m->{sha1_a}, sha1_b => '0' x 40,
  			chg => 'D', file_b => $m->{file_b}
  		}, $deletions);
  		$self->A({
  			mode_a => '000000', mode_b => $m->{mode_b},
  			sha1_a => '0' x 40, sha1_b => $m->{sha1_b},
  			chg => 'A', file_b => $m->{file_b}
  		}, $deletions);
  		return;
  	}
  
  	$self->M($m, $deletions);
  }
  
  sub change_file_prop {
  	my ($self, $fbat, $pname, $pval) = @_;
  	$self->SUPER::change_file_prop($fbat, $pname, $pval, $self->{pool});
  }
  
  sub change_dir_prop {
  	my ($self, $pbat, $pname, $pval) = @_;
  	$self->SUPER::change_dir_prop($pbat, $pname, $pval, $self->{pool});
  }
  
  sub _chg_file_get_blob ($$$$) {
  	my ($self, $fbat, $m, $which) = @_;
  	my $fh = $::_repository->temp_acquire("git_blob_$which");
  	if ($m->{"mode_$which"} =~ /^120/) {
  		print $fh 'link ' or croak $!;
  		$self->change_file_prop($fbat,'svn:special','*');
  	} elsif ($m->{mode_a} =~ /^120/ && $m->{"mode_$which"} !~ /^120/) {
  		$self->change_file_prop($fbat,'svn:special',undef);
  	}
  	my $blob = $m->{"sha1_$which"};
  	return ($fh,) if ($blob =~ /^0{40}$/);
  	my $size = $::_repository->cat_blob($blob, $fh);
  	croak "Failed to read object $blob" if ($size < 0);
  	$fh->flush == 0 or croak $!;
  	seek $fh, 0, 0 or croak $!;
  
  	my $exp = ::md5sum($fh);
  	seek $fh, 0, 0 or croak $!;
  	return ($fh, $exp);
  }
  
  sub chg_file {
  	my ($self, $fbat, $m) = @_;
  	if ($m->{mode_b} =~ /755$/ && $m->{mode_a} !~ /755$/) {
  		$self->change_file_prop($fbat,'svn:executable','*');
  	} elsif ($m->{mode_b} !~ /755$/ && $m->{mode_a} =~ /755$/) {
  		$self->change_file_prop($fbat,'svn:executable',undef);
  	}
  	my ($fh_a, $exp_a) = _chg_file_get_blob $self, $fbat, $m, 'a';
  	my ($fh_b, $exp_b) = _chg_file_get_blob $self, $fbat, $m, 'b';
  	my $pool = SVN::Pool->new;
  	my $atd = $self->apply_textdelta($fbat, $exp_a, $pool);
  	if (-s $fh_a) {
  		my $txstream = SVN::TxDelta::new ($fh_a, $fh_b, $pool);
  		my $res = SVN::TxDelta::send_txstream($txstream, @$atd, $pool);
  		if (defined $res) {
  			die "Unexpected result from send_txstream: $res\n",
  			    "(SVN::Core::VERSION: $SVN::Core::VERSION)\n";
  		}
  	} else {
  		my $got = SVN::TxDelta::send_stream($fh_b, @$atd, $pool);
  		die "Checksum mismatch\nexpected: $exp_b\ngot: $got\n"
  		    if ($got ne $exp_b);
  	}
  	Git::temp_release($fh_b, 1);
  	Git::temp_release($fh_a, 1);
  	$pool->clear;
  }
  
  sub D {
  	my ($self, $m, $deletions) = @_;
  	my ($dir, $file) = split_path($m->{file_b});
  	my $pbat = $self->ensure_path($dir, $deletions);
  	print "\tD\t$m->{file_b}\n" unless $::_q;
  	$self->delete_entry($m->{file_b}, $pbat);
  }
  
  sub close_edit {
  	my ($self) = @_;
  	my ($p,$bat) = ($self->{pool}, $self->{bat});
  	foreach (sort { $b =~ tr#/#/# <=> $a =~ tr#/#/# } keys %$bat) {
  		next if $_ eq '';
  		$self->close_directory($bat->{$_}, $p);
  	}
  	$self->close_directory($bat->{''}, $p);
  	$self->SUPER::close_edit($p);
  	$p->clear;
  }
  
  sub abort_edit {
  	my ($self) = @_;
  	$self->SUPER::abort_edit($self->{pool});
  }
  
  sub DESTROY {
  	my $self = shift;
  	$self->SUPER::DESTROY(@_);
  	$self->{pool}->clear;
  }
  
  # this drives the editor
  sub apply_diff {
  	my ($self) = @_;
  	my $mods = $self->{mods};
  	my %o = ( D => 0, C => 1, R => 2, A => 3, M => 4, T => 5 );
  	my %deletions;
  
  	foreach my $m (@$mods) {
  		if ($m->{chg} eq "D") {
  			$deletions{$m->{file_b}} = 1;
  		}
  	}
  
  	foreach my $m (sort { $o{$a->{chg}} <=> $o{$b->{chg}} } @$mods) {
  		my $f = $m->{chg};
  		if (defined $o{$f}) {
  			$self->$f($m, \%deletions);
  		} else {
  			fatal("Invalid change type: $f");
  		}
  	}
  
  	if (defined($self->{mergeinfo})) {
  		$self->change_dir_prop($self->{bat}{''}, "svn:mergeinfo",
  			               $self->{mergeinfo});
  	}
  	$self->rmdirs if $_rmdir;
  	if (@$mods == 0 && !defined($self->{mergeinfo})) {
  		$self->abort_edit;
  	} else {
  		$self->close_edit;
  	}
  	return scalar @$mods;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Git::SVN::Editor - commit driver for "git svn set-tree" and dcommit
  
  =head1 SYNOPSIS
  
  	use Git::SVN::Editor;
  	use Git::SVN::Ra;
  
  	my $ra = Git::SVN::Ra->new($url);
  	my %opts = (
  		r => 19,
  		log => "log message",
  		ra => $ra,
  		config => SVN::Core::config_get_config($svn_config_dir),
  		tree_a => "$commit^",
  		tree_b => "$commit",
  		editor_cb => sub { print "Committed r$_[0]\n"; },
  		mergeinfo => "/branches/foo:1-10",
  		svn_path => "trunk"
  	);
  	Git::SVN::Editor->new(\%opts)->apply_diff or print "No changes\n";
  
  	my $re = Git::SVN::Editor::glob2pat("trunk/*");
  	if ($branchname =~ /$re/) {
  		print "matched!\n";
  	}
  
  =head1 DESCRIPTION
  
  This module is an implementation detail of the "git svn" command.
  Do not use it unless you are developing git-svn.
  
  This module adapts the C<SVN::Delta::Editor> object returned by
  C<SVN::Delta::get_commit_editor> and drives it to convey the
  difference between two git tree objects to a remote Subversion
  repository.
  
  The interface will change as git-svn evolves.
  
  =head1 DEPENDENCIES
  
  Subversion perl bindings,
  the core L<Carp> module,
  and git's L<Git> helper module.
  
  C<Git::SVN::Editor> has not been tested using callers other than
  B<git-svn> itself.
  
  =head1 SEE ALSO
  
  L<SVN::Delta>,
  L<Git::SVN::Fetcher>.
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  =head1 BUGS
  
  None.
GIT_SVN_EDITOR

$fatpacked{"Git/SVN/Fetcher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_FETCHER';
  package Git::SVN::Fetcher;
  use vars qw/@ISA $_ignore_regex $_include_regex $_preserve_empty_dirs
              $_placeholder_filename @deleted_gpath %added_placeholder
              $repo_id/;
  use strict;
  use warnings;
  use SVN::Delta;
  use Carp qw/croak/;
  use File::Basename qw/dirname/;
  use Git qw/command command_oneline command_noisy command_output_pipe
             command_input_pipe command_close_pipe
             command_bidi_pipe command_close_bidi_pipe
             get_record/;
  BEGIN {
  	@ISA = qw(SVN::Delta::Editor);
  }
  
  # file baton members: path, mode_a, mode_b, pool, fh, blob, base
  sub new {
  	my ($class, $git_svn, $switch_path) = @_;
  	my $self = SVN::Delta::Editor->new;
  	bless $self, $class;
  	if (exists $git_svn->{last_commit}) {
  		$self->{c} = $git_svn->{last_commit};
  		$self->{empty_symlinks} =
  		                  _mark_empty_symlinks($git_svn, $switch_path);
  	}
  
  	# some options are read globally, but can be overridden locally
  	# per [svn-remote "..."] section.  Command-line options will *NOT*
  	# override options set in an [svn-remote "..."] section
  	$repo_id = $git_svn->{repo_id};
  	my $k = "svn-remote.$repo_id.ignore-paths";
  	my $v = eval { command_oneline('config', '--get', $k) };
  	$self->{ignore_regex} = $v;
  
  	$k = "svn-remote.$repo_id.include-paths";
  	$v = eval { command_oneline('config', '--get', $k) };
  	$self->{include_regex} = $v;
  
  	$k = "svn-remote.$repo_id.preserve-empty-dirs";
  	$v = eval { command_oneline('config', '--get', '--bool', $k) };
  	if ($v && $v eq 'true') {
  		$_preserve_empty_dirs = 1;
  		$k = "svn-remote.$repo_id.placeholder-filename";
  		$v = eval { command_oneline('config', '--get', $k) };
  		$_placeholder_filename = $v;
  	}
  
  	# Load the list of placeholder files added during previous invocations.
  	$k = "svn-remote.$repo_id.added-placeholder";
  	$v = eval { command_oneline('config', '--get-all', $k) };
  	if ($_preserve_empty_dirs && $v) {
  		# command() prints errors to stderr, so we only call it if
  		# command_oneline() succeeded.
  		my @v = command('config', '--get-all', $k);
  		$added_placeholder{ dirname($_) } = $_ foreach @v;
  	}
  
  	$self->{empty} = {};
  	$self->{dir_prop} = {};
  	$self->{file_prop} = {};
  	$self->{absent_dir} = {};
  	$self->{absent_file} = {};
  	require Git::IndexInfo;
  	$self->{gii} = $git_svn->tmp_index_do(sub { Git::IndexInfo->new });
  	$self->{pathnameencoding} = Git::config('svn.pathnameencoding');
  	$self;
  }
  
  # this uses the Ra object, so it must be called before do_{switch,update},
  # not inside them (when the Git::SVN::Fetcher object is passed) to
  # do_{switch,update}
  sub _mark_empty_symlinks {
  	my ($git_svn, $switch_path) = @_;
  	my $bool = Git::config_bool('svn.brokenSymlinkWorkaround');
  	return {} if (!defined($bool)) || (defined($bool) && ! $bool);
  
  	my %ret;
  	my ($rev, $cmt) = $git_svn->last_rev_commit;
  	return {} unless ($rev && $cmt);
  
  	# allow the warning to be printed for each revision we fetch to
  	# ensure the user sees it.  The user can also disable the workaround
  	# on the repository even while git svn is running and the next
  	# revision fetched will skip this expensive function.
  	my $printed_warning;
  	chomp(my $empty_blob = `git hash-object -t blob --stdin < /dev/null`);
  	my ($ls, $ctx) = command_output_pipe(qw/ls-tree -r -z/, $cmt);
  	my $pfx = defined($switch_path) ? $switch_path : $git_svn->path;
  	$pfx .= '/' if length($pfx);
  	while (defined($_ = get_record($ls, "\0"))) {
  		s/\A100644 blob $empty_blob\t//o or next;
  		unless ($printed_warning) {
  			print STDERR "Scanning for empty symlinks, ",
  			             "this may take a while if you have ",
  				     "many empty files\n",
  				     "You may disable this with `",
  				     "git config svn.brokenSymlinkWorkaround ",
  				     "false'.\n",
  				     "This may be done in a different ",
  				     "terminal without restarting ",
  				     "git svn\n";
  			$printed_warning = 1;
  		}
  		my $path = $_;
  		my (undef, $props) =
  		               $git_svn->ra->get_file($pfx.$path, $rev, undef);
  		if ($props->{'svn:special'}) {
  			$ret{$path} = 1;
  		}
  	}
  	command_close_pipe($ls, $ctx);
  	\%ret;
  }
  
  # returns true if a given path is inside a ".git" directory
  sub in_dot_git {
  	$_[0] =~ m{(?:^|/)\.git(?:/|$)};
  }
  
  # return value: 0 -- don't ignore, 1 -- ignore
  # This will also check whether the path is explicitly included
  sub is_path_ignored {
  	my ($self, $path) = @_;
  	return 1 if in_dot_git($path);
  	return 1 if defined($self->{ignore_regex}) &&
  	            $path =~ m!$self->{ignore_regex}!;
  	return 0 if defined($self->{include_regex}) &&
  	            $path =~ m!$self->{include_regex}!;
  	return 0 if defined($_include_regex) &&
  	            $path =~ m!$_include_regex!;
  	return 1 if defined($self->{include_regex});
  	return 1 if defined($_include_regex);
  	return 0 unless defined($_ignore_regex);
  	return 1 if $path =~ m!$_ignore_regex!o;
  	return 0;
  }
  
  sub set_path_strip {
  	my ($self, $path) = @_;
  	$self->{path_strip} = qr/^\Q$path\E(\/|$)/ if length $path;
  }
  
  sub open_root {
  	{ path => '' };
  }
  
  sub open_directory {
  	my ($self, $path, $pb, $rev) = @_;
  	{ path => $path };
  }
  
  sub git_path {
  	my ($self, $path) = @_;
  	if (my $enc = $self->{pathnameencoding}) {
  		require Encode;
  		Encode::from_to($path, 'UTF-8', $enc);
  	}
  	if ($self->{path_strip}) {
  		$path =~ s!$self->{path_strip}!! or
  		  die "Failed to strip path '$path' ($self->{path_strip})\n";
  	}
  	$path;
  }
  
  sub delete_entry {
  	my ($self, $path, $rev, $pb) = @_;
  	return undef if $self->is_path_ignored($path);
  
  	my $gpath = $self->git_path($path);
  	return undef if ($gpath eq '');
  
  	# remove entire directories.
  	my ($tree) = (command('ls-tree', '-z', $self->{c}, "./$gpath")
  	                 =~ /\A040000 tree ([a-f\d]{40})\t\Q$gpath\E\0/);
  	if ($tree) {
  		my ($ls, $ctx) = command_output_pipe(qw/ls-tree
  		                                     -r --name-only -z/,
  				                     $tree);
  		while (defined($_ = get_record($ls, "\0"))) {
  			my $rmpath = "$gpath/$_";
  			$self->{gii}->remove($rmpath);
  			print "\tD\t$rmpath\n" unless $::_q;
  		}
  		print "\tD\t$gpath/\n" unless $::_q;
  		command_close_pipe($ls, $ctx);
  	} else {
  		$self->{gii}->remove($gpath);
  		print "\tD\t$gpath\n" unless $::_q;
  	}
  	# Don't add to @deleted_gpath if we're deleting a placeholder file.
  	push @deleted_gpath, $gpath unless $added_placeholder{dirname($path)};
  	$self->{empty}->{$path} = 0;
  	undef;
  }
  
  sub open_file {
  	my ($self, $path, $pb, $rev) = @_;
  	my ($mode, $blob);
  
  	goto out if $self->is_path_ignored($path);
  
  	my $gpath = $self->git_path($path);
  	($mode, $blob) = (command('ls-tree', '-z', $self->{c}, "./$gpath")
  	                     =~ /\A(\d{6}) blob ([a-f\d]{40})\t\Q$gpath\E\0/);
  	unless (defined $mode && defined $blob) {
  		die "$path was not found in commit $self->{c} (r$rev)\n";
  	}
  	if ($mode eq '100644' && $self->{empty_symlinks}->{$path}) {
  		$mode = '120000';
  	}
  out:
  	{ path => $path, mode_a => $mode, mode_b => $mode, blob => $blob,
  	  pool => SVN::Pool->new, action => 'M' };
  }
  
  sub add_file {
  	my ($self, $path, $pb, $cp_path, $cp_rev) = @_;
  	my $mode;
  
  	if (!$self->is_path_ignored($path)) {
  		my ($dir, $file) = ($path =~ m#^(.*?)/?([^/]+)$#);
  		delete $self->{empty}->{$dir};
  		$mode = '100644';
  
  		if ($added_placeholder{$dir}) {
  			# Remove our placeholder file, if we created one.
  			delete_entry($self, $added_placeholder{$dir})
  				unless $path eq $added_placeholder{$dir};
  			delete $added_placeholder{$dir}
  		}
  	}
  
  	{ path => $path, mode_a => $mode, mode_b => $mode,
  	  pool => SVN::Pool->new, action => 'A' };
  }
  
  sub add_directory {
  	my ($self, $path, $cp_path, $cp_rev) = @_;
  	goto out if $self->is_path_ignored($path);
  	my $gpath = $self->git_path($path);
  	if ($gpath eq '') {
  		my ($ls, $ctx) = command_output_pipe(qw/ls-tree
  		                                     -r --name-only -z/,
  				                     $self->{c});
  		while (defined($_ = get_record($ls, "\0"))) {
  			$self->{gii}->remove($_);
  			print "\tD\t$_\n" unless $::_q;
  			push @deleted_gpath, $gpath;
  		}
  		command_close_pipe($ls, $ctx);
  		$self->{empty}->{$path} = 0;
  	}
  	my ($dir, $file) = ($path =~ m#^(.*?)/?([^/]+)$#);
  	delete $self->{empty}->{$dir};
  	$self->{empty}->{$path} = 1;
  
  	if ($added_placeholder{$dir}) {
  		# Remove our placeholder file, if we created one.
  		delete_entry($self, $added_placeholder{$dir});
  		delete $added_placeholder{$dir}
  	}
  
  out:
  	{ path => $path };
  }
  
  sub change_dir_prop {
  	my ($self, $db, $prop, $value) = @_;
  	return undef if $self->is_path_ignored($db->{path});
  	$self->{dir_prop}->{$db->{path}} ||= {};
  	$self->{dir_prop}->{$db->{path}}->{$prop} = $value;
  	undef;
  }
  
  sub absent_directory {
  	my ($self, $path, $pb) = @_;
  	return undef if $self->is_path_ignored($path);
  	$self->{absent_dir}->{$pb->{path}} ||= [];
  	push @{$self->{absent_dir}->{$pb->{path}}}, $path;
  	undef;
  }
  
  sub absent_file {
  	my ($self, $path, $pb) = @_;
  	return undef if $self->is_path_ignored($path);
  	$self->{absent_file}->{$pb->{path}} ||= [];
  	push @{$self->{absent_file}->{$pb->{path}}}, $path;
  	undef;
  }
  
  sub change_file_prop {
  	my ($self, $fb, $prop, $value) = @_;
  	return undef if $self->is_path_ignored($fb->{path});
  	if ($prop eq 'svn:executable') {
  		if ($fb->{mode_b} != 120000) {
  			$fb->{mode_b} = defined $value ? 100755 : 100644;
  		}
  	} elsif ($prop eq 'svn:special') {
  		$fb->{mode_b} = defined $value ? 120000 : 100644;
  	} else {
  		$self->{file_prop}->{$fb->{path}} ||= {};
  		$self->{file_prop}->{$fb->{path}}->{$prop} = $value;
  	}
  	undef;
  }
  
  sub apply_textdelta {
  	my ($self, $fb, $exp) = @_;
  	return undef if $self->is_path_ignored($fb->{path});
  	my $suffix = 0;
  	++$suffix while $::_repository->temp_is_locked("svn_delta_${$}_$suffix");
  	my $fh = $::_repository->temp_acquire("svn_delta_${$}_$suffix");
  	# $fh gets auto-closed() by SVN::TxDelta::apply(),
  	# (but $base does not,) so dup() it for reading in close_file
  	open my $dup, '<&', $fh or croak $!;
  	my $base = $::_repository->temp_acquire("git_blob_${$}_$suffix");
  	# close_file may call temp_acquire on 'svn_hash', but because of the
  	# call chain, if the temp_acquire call from close_file ends up being the
  	# call that first creates the 'svn_hash' temp file, then the FileHandle
  	# that's created as a result will end up in an SVN::Pool that we clear
  	# in SVN::Ra::gs_fetch_loop_common.  Avoid that by making sure the
  	# 'svn_hash' FileHandle is already created before close_file is called.
  	my $tmp_fh = $::_repository->temp_acquire('svn_hash');
  	$::_repository->temp_release($tmp_fh, 1);
  
  	if ($fb->{blob}) {
  		my ($base_is_link, $size);
  
  		if ($fb->{mode_a} eq '120000' &&
  		    ! $self->{empty_symlinks}->{$fb->{path}}) {
  			print $base 'link ' or die "print $!\n";
  			$base_is_link = 1;
  		}
  	retry:
  		$size = $::_repository->cat_blob($fb->{blob}, $base);
  		die "Failed to read object $fb->{blob}" if ($size < 0);
  
  		if (defined $exp) {
  			seek $base, 0, 0 or croak $!;
  			my $got = ::md5sum($base);
  			if ($got ne $exp) {
  				my $err = "Checksum mismatch: ".
  				       "$fb->{path} $fb->{blob}\n" .
  				       "expected: $exp\n" .
  				       "     got: $got\n";
  				if ($base_is_link) {
  					warn $err,
  					     "Retrying... (possibly ",
  					     "a bad symlink from SVN)\n";
  					$::_repository->temp_reset($base);
  					$base_is_link = 0;
  					goto retry;
  				}
  				die $err;
  			}
  		}
  	}
  	seek $base, 0, 0 or croak $!;
  	$fb->{fh} = $fh;
  	$fb->{base} = $base;
  	[ SVN::TxDelta::apply($base, $dup, undef, $fb->{path}, $fb->{pool}) ];
  }
  
  sub close_file {
  	my ($self, $fb, $exp) = @_;
  	return undef if $self->is_path_ignored($fb->{path});
  
  	my $hash;
  	my $path = $self->git_path($fb->{path});
  	if (my $fh = $fb->{fh}) {
  		if (defined $exp) {
  			seek($fh, 0, 0) or croak $!;
  			my $got = ::md5sum($fh);
  			if ($got ne $exp) {
  				die "Checksum mismatch: $path\n",
  				    "expected: $exp\n    got: $got\n";
  			}
  		}
  		if ($fb->{mode_b} == 120000) {
  			sysseek($fh, 0, 0) or croak $!;
  			my $rd = sysread($fh, my $buf, 5);
  
  			if (!defined $rd) {
  				croak "sysread: $!\n";
  			} elsif ($rd == 0) {
  				warn "$path has mode 120000",
  				     " but it points to nothing\n",
  				     "converting to an empty file with mode",
  				     " 100644\n";
  				$fb->{mode_b} = '100644';
  			} elsif ($buf ne 'link ') {
  				warn "$path has mode 120000",
  				     " but is not a link\n";
  			} else {
  				my $tmp_fh = $::_repository->temp_acquire(
  					'svn_hash');
  				my $res;
  				while ($res = sysread($fh, my $str, 1024)) {
  					my $out = syswrite($tmp_fh, $str, $res);
  					defined($out) && $out == $res
  						or croak("write ",
  							Git::temp_path($tmp_fh),
  							": $!\n");
  				}
  				defined $res or croak $!;
  
  				($fh, $tmp_fh) = ($tmp_fh, $fh);
  				Git::temp_release($tmp_fh, 1);
  			}
  		}
  
  		$hash = $::_repository->hash_and_insert_object(
  				Git::temp_path($fh));
  		$hash =~ /^[a-f\d]{40}$/ or die "not a sha1: $hash\n";
  
  		Git::temp_release($fb->{base}, 1);
  		Git::temp_release($fh, 1);
  	} else {
  		$hash = $fb->{blob} or die "no blob information\n";
  	}
  	$fb->{pool}->clear;
  	$self->{gii}->update($fb->{mode_b}, $hash, $path) or croak $!;
  	print "\t$fb->{action}\t$path\n" if $fb->{action} && ! $::_q;
  	undef;
  }
  
  sub abort_edit {
  	my $self = shift;
  	$self->{nr} = $self->{gii}->{nr};
  	delete $self->{gii};
  	$self->SUPER::abort_edit(@_);
  }
  
  sub close_edit {
  	my $self = shift;
  
  	if ($_preserve_empty_dirs) {
  		my @empty_dirs;
  
  		# Any entry flagged as empty that also has an associated
  		# dir_prop represents a newly created empty directory.
  		foreach my $i (keys %{$self->{empty}}) {
  			push @empty_dirs, $i if exists $self->{dir_prop}->{$i};
  		}
  
  		# Search for directories that have become empty due subsequent
  		# file deletes.
  		push @empty_dirs, $self->find_empty_directories();
  
  		# Finally, add a placeholder file to each empty directory.
  		$self->add_placeholder_file($_) foreach (@empty_dirs);
  
  		$self->stash_placeholder_list();
  	}
  
  	$self->{git_commit_ok} = 1;
  	$self->{nr} = $self->{gii}->{nr};
  	delete $self->{gii};
  	$self->SUPER::close_edit(@_);
  }
  
  sub find_empty_directories {
  	my ($self) = @_;
  	my @empty_dirs;
  	my %dirs = map { dirname($_) => 1 } @deleted_gpath;
  
  	foreach my $dir (sort keys %dirs) {
  		next if $dir eq ".";
  
  		# If there have been any additions to this directory, there is
  		# no reason to check if it is empty.
  		my $skip_added = 0;
  		foreach my $t (qw/dir_prop file_prop/) {
  			foreach my $path (keys %{ $self->{$t} }) {
  				if (exists $self->{$t}->{dirname($path)}) {
  					$skip_added = 1;
  					last;
  				}
  			}
  			last if $skip_added;
  		}
  		next if $skip_added;
  
  		# Use `git ls-tree` to get the filenames of this directory
  		# that existed prior to this particular commit.
  		my $ls = command('ls-tree', '-z', '--name-only',
  				 $self->{c}, "$dir/");
  		my %files = map { $_ => 1 } split(/\0/, $ls);
  
  		# Remove the filenames that were deleted during this commit.
  		delete $files{$_} foreach (@deleted_gpath);
  
  		# Report the directory if there are no filenames left.
  		push @empty_dirs, $dir unless (scalar %files);
  	}
  	@empty_dirs;
  }
  
  sub add_placeholder_file {
  	my ($self, $dir) = @_;
  	my $path = "$dir/$_placeholder_filename";
  	my $gpath = $self->git_path($path);
  
  	my $fh = $::_repository->temp_acquire($gpath);
  	my $hash = $::_repository->hash_and_insert_object(Git::temp_path($fh));
  	Git::temp_release($fh, 1);
  	$self->{gii}->update('100644', $hash, $gpath) or croak $!;
  
  	# The directory should no longer be considered empty.
  	delete $self->{empty}->{$dir} if exists $self->{empty}->{$dir};
  
  	# Keep track of any placeholder files we create.
  	$added_placeholder{$dir} = $path;
  }
  
  sub stash_placeholder_list {
  	my ($self) = @_;
  	my $k = "svn-remote.$repo_id.added-placeholder";
  	my $v = eval { command_oneline('config', '--get-all', $k) };
  	command_noisy('config', '--unset-all', $k) if $v;
  	foreach (values %added_placeholder) {
  		command_noisy('config', '--add', $k, $_);
  	}
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Git::SVN::Fetcher - tree delta consumer for "git svn fetch"
  
  =head1 SYNOPSIS
  
      use SVN::Core;
      use SVN::Ra;
      use Git::SVN;
      use Git::SVN::Fetcher;
      use Git;
  
      my $gs = Git::SVN->find_by_url($url);
      my $ra = SVN::Ra->new(url => $url);
      my $editor = Git::SVN::Fetcher->new($gs);
      my $reporter = $ra->do_update($SVN::Core::INVALID_REVNUM, '',
                                    1, $editor);
      $reporter->set_path('', $old_rev, 0);
      $reporter->finish_report;
      my $tree = $gs->tmp_index_do(sub { command_oneline('write-tree') });
  
      foreach my $path (keys %{$editor->{dir_prop}) {
          my $props = $editor->{dir_prop}{$path};
          foreach my $prop (keys %$props) {
              print "property $prop at $path changed to $props->{$prop}\n";
          }
      }
      foreach my $path (keys %{$editor->{empty}) {
          my $action = $editor->{empty}{$path} ? 'added' : 'removed';
          print "empty directory $path $action\n";
      }
      foreach my $path (keys %{$editor->{file_prop}) { ... }
      foreach my $parent (keys %{$editor->{absent_dir}}) {
          my @children = @{$editor->{abstent_dir}{$parent}};
          print "cannot fetch directory $parent/$_: not authorized?\n"
              foreach @children;
      }
      foreach my $parent (keys %{$editor->{absent_file}) { ... }
  
  =head1 DESCRIPTION
  
  This is a subclass of C<SVN::Delta::Editor>, which means it implements
  callbacks to act as a consumer of Subversion tree deltas.  This
  particular implementation of those callbacks is meant to store
  information about the resulting content which B<git svn fetch> could
  use to populate new commits and new entries for F<unhandled.log>.
  More specifically:
  
  =over
  
  =item * Additions, removals, and modifications of files are propagated
  to git-svn's index file F<$GIT_DIR/svn/$refname/index> using
  B<git update-index>.
  
  =item * Changes in Subversion path properties are recorded in the
  C<dir_prop> and C<file_prop> fields (which are hashes).
  
  =item * Addition and removal of empty directories are indicated by
  entries with value 1 and 0 respectively in the C<empty> hash.
  
  =item * Paths that are present but cannot be conveyed (presumably due
  to permissions) are recorded in the C<absent_file> and
  C<absent_dirs> hashes.  For each key, the corresponding value is
  a list of paths under that directory that were present but
  could not be conveyed.
  
  =back
  
  The interface is unstable.  Do not use this module unless you are
  developing git-svn.
  
  =head1 DEPENDENCIES
  
  L<SVN::Delta> from the Subversion perl bindings,
  the core L<Carp> and L<File::Basename> modules,
  and git's L<Git> helper module.
  
  C<Git::SVN::Fetcher> has not been tested using callers other than
  B<git-svn> itself.
  
  =head1 SEE ALSO
  
  L<SVN::Delta>,
  L<Git::SVN::Editor>.
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  =head1 BUGS
  
  None.
GIT_SVN_FETCHER

$fatpacked{"Git/SVN/GlobSpec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_GLOBSPEC';
  package Git::SVN::GlobSpec;
  use strict;
  use warnings;
  
  sub new {
  	my ($class, $glob, $pattern_ok) = @_;
  	my $re = $glob;
  	$re =~ s!/+$!!g; # no need for trailing slashes
  	my (@left, @right, @patterns);
  	my $state = "left";
  	my $die_msg = "Only one set of wildcards " .
  				"(e.g. '*' or '*/*/*') is supported: $glob\n";
  	for my $part (split(m|/|, $glob)) {
  		if ($pattern_ok && $part =~ /[{}]/ &&
  			 $part !~ /^\{[^{}]+\}/) {
  			die "Invalid pattern in '$glob': $part\n";
  		}
  		my $nstars = $part =~ tr/*//;
  		if ($nstars > 1) {
  			die "Only one '*' is allowed in a pattern: '$part'\n";
  		}
  		if ($part =~ /(.*)\*(.*)/) {
  			die $die_msg if $state eq "right";
  			my ($l, $r) = ($1, $2);
  			$state = "pattern";
  			my $pat = quotemeta($l) . '[^/]*' . quotemeta($r);
  			push(@patterns, $pat);
  		} elsif ($pattern_ok && $part =~ /^\{(.*)\}$/) {
  			die $die_msg if $state eq "right";
  			$state = "pattern";
  			my $p = quotemeta($1);
  			$p =~ s/\\,/|/g;
  			push(@patterns, "(?:$p)");
  		} else {
  			if ($state eq "left") {
  				push(@left, $part);
  			} else {
  				push(@right, $part);
  				$state = "right";
  			}
  		}
  	}
  	my $depth = @patterns;
  	if ($depth == 0) {
  		die "One '*' is needed in glob: '$glob'\n";
  	}
  	my $left = join('/', @left);
  	my $right = join('/', @right);
  	$re = join('/', @patterns);
  	$re = join('\/',
  		   grep(length, quotemeta($left),
                                  "($re)(?=/|\$)",
                                  quotemeta($right)));
  	my $left_re = qr/^\/\Q$left\E(\/|$)/;
  	bless { left => $left, right => $right, left_regex => $left_re,
  	        regex => qr/$re/, glob => $glob, depth => $depth }, $class;
  }
  
  sub full_path {
  	my ($self, $path) = @_;
  	return (length $self->{left} ? "$self->{left}/" : '') .
  	       $path . (length $self->{right} ? "/$self->{right}" : '');
  }
  
  1;
GIT_SVN_GLOBSPEC

$fatpacked{"Git/SVN/Log.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_LOG';
  package Git::SVN::Log;
  use strict;
  use warnings;
  use Git::SVN::Utils qw(fatal);
  use Git qw(command
             command_oneline
             command_output_pipe
             command_close_pipe
             get_tz_offset);
  use POSIX qw/strftime/;
  use constant commit_log_separator => ('-' x 72) . "\n";
  use vars qw/$TZ $limit $color $pager $non_recursive $verbose $oneline
              %rusers $show_commit $incremental/;
  
  # Option set in git-svn
  our $_git_format;
  
  sub cmt_showable {
  	my ($c) = @_;
  	return 1 if defined $c->{r};
  
  	# big commit message got truncated by the 16k pretty buffer in rev-list
  	if ($c->{l} && $c->{l}->[-1] eq "...\n" &&
  				$c->{a_raw} =~ /\@([a-f\d\-]+)>$/) {
  		@{$c->{l}} = ();
  		my @log = command(qw/cat-file commit/, $c->{c});
  
  		# shift off the headers
  		shift @log while ($log[0] ne '');
  		shift @log;
  
  		# TODO: make $c->{l} not have a trailing newline in the future
  		@{$c->{l}} = map { "$_\n" } grep !/^git-svn-id: /, @log;
  
  		(undef, $c->{r}, undef) = ::extract_metadata(
  				(grep(/^git-svn-id: /, @log))[-1]);
  	}
  	return defined $c->{r};
  }
  
  sub log_use_color {
  	return $color || Git->repository->get_colorbool('color.diff');
  }
  
  sub git_svn_log_cmd {
  	my ($r_min, $r_max, @args) = @_;
  	my $head = 'HEAD';
  	my (@files, @log_opts);
  	foreach my $x (@args) {
  		if ($x eq '--' || @files) {
  			push @files, $x;
  		} else {
  			if (::verify_ref("$x^0")) {
  				$head = $x;
  			} else {
  				push @log_opts, $x;
  			}
  		}
  	}
  
  	my ($url, $rev, $uuid, $gs) = ::working_head_info($head);
  
  	require Git::SVN;
  	$gs ||= Git::SVN->_new;
  	my @cmd = (qw/log --abbrev-commit --pretty=raw --default/,
  	           $gs->refname);
  	push @cmd, '-r' unless $non_recursive;
  	push @cmd, qw/--raw --name-status/ if $verbose;
  	push @cmd, '--color' if log_use_color();
  	push @cmd, @log_opts;
  	if (defined $r_max && $r_max == $r_min) {
  		push @cmd, '--max-count=1';
  		if (my $c = $gs->rev_map_get($r_max)) {
  			push @cmd, $c;
  		}
  	} elsif (defined $r_max) {
  		if ($r_max < $r_min) {
  			($r_min, $r_max) = ($r_max, $r_min);
  		}
  		my (undef, $c_max) = $gs->find_rev_before($r_max, 1, $r_min);
  		my (undef, $c_min) = $gs->find_rev_after($r_min, 1, $r_max);
  		# If there are no commits in the range, both $c_max and $c_min
  		# will be undefined.  If there is at least 1 commit in the
  		# range, both will be defined.
  		return () if !defined $c_min || !defined $c_max;
  		if ($c_min eq $c_max) {
  			push @cmd, '--max-count=1', $c_min;
  		} else {
  			push @cmd, '--boundary', "$c_min..$c_max";
  		}
  	}
  	return (@cmd, @files);
  }
  
  # adapted from pager.c
  sub config_pager {
  	if (! -t *STDOUT) {
  		$ENV{GIT_PAGER_IN_USE} = 'false';
  		$pager = undef;
  		return;
  	}
  	chomp($pager = command_oneline(qw(var GIT_PAGER)));
  	if ($pager eq 'cat') {
  		$pager = undef;
  	}
  	$ENV{GIT_PAGER_IN_USE} = defined($pager);
  }
  
  sub run_pager {
  	return unless defined $pager;
  	pipe my ($rfd, $wfd) or return;
  	defined(my $pid = fork) or fatal "Can't fork: $!";
  	if (!$pid) {
  		open STDOUT, '>&', $wfd or
  		                     fatal "Can't redirect to stdout: $!";
  		return;
  	}
  	open STDIN, '<&', $rfd or fatal "Can't redirect stdin: $!";
  	$ENV{LESS} ||= 'FRX';
  	$ENV{LV} ||= '-c';
  	exec $pager or fatal "Can't run pager: $! ($pager)";
  }
  
  sub format_svn_date {
  	my $t = shift || time;
  	require Git::SVN;
  	my $gmoff = get_tz_offset($t);
  	return strftime("%Y-%m-%d %H:%M:%S $gmoff (%a, %d %b %Y)", localtime($t));
  }
  
  sub parse_git_date {
  	my ($t, $tz) = @_;
  	# Date::Parse isn't in the standard Perl distro :(
  	if ($tz =~ s/^\+//) {
  		$t += tz_to_s_offset($tz);
  	} elsif ($tz =~ s/^\-//) {
  		$t -= tz_to_s_offset($tz);
  	}
  	return $t;
  }
  
  sub set_local_timezone {
  	if (defined $TZ) {
  		$ENV{TZ} = $TZ;
  	} else {
  		delete $ENV{TZ};
  	}
  }
  
  sub tz_to_s_offset {
  	my ($tz) = @_;
  	$tz =~ s/(\d\d)$//;
  	return ($1 * 60) + ($tz * 3600);
  }
  
  sub get_author_info {
  	my ($dest, $author, $t, $tz) = @_;
  	$author =~ s/(?:^\s*|\s*$)//g;
  	$dest->{a_raw} = $author;
  	my $au;
  	if ($::_authors) {
  		$au = $rusers{$author} || undef;
  	}
  	if (!$au) {
  		($au) = ($author =~ /<([^>]+)\@[^>]+>$/);
  	}
  	$dest->{t} = $t;
  	$dest->{tz} = $tz;
  	$dest->{a} = $au;
  	$dest->{t_utc} = parse_git_date($t, $tz);
  }
  
  sub process_commit {
  	my ($c, $r_min, $r_max, $defer) = @_;
  	if (defined $r_min && defined $r_max) {
  		if ($r_min == $c->{r} && $r_min == $r_max) {
  			show_commit($c);
  			return 0;
  		}
  		return 1 if $r_min == $r_max;
  		if ($r_min < $r_max) {
  			# we need to reverse the print order
  			return 0 if (defined $limit && --$limit < 0);
  			push @$defer, $c;
  			return 1;
  		}
  		if ($r_min != $r_max) {
  			return 1 if ($r_min < $c->{r});
  			return 1 if ($r_max > $c->{r});
  		}
  	}
  	return 0 if (defined $limit && --$limit < 0);
  	show_commit($c);
  	return 1;
  }
  
  my $l_fmt;
  sub show_commit {
  	my $c = shift;
  	if ($oneline) {
  		my $x = "\n";
  		if (my $l = $c->{l}) {
  			while ($l->[0] =~ /^\s*$/) { shift @$l }
  			$x = $l->[0];
  		}
  		$l_fmt ||= 'A' . length($c->{r});
  		print 'r',pack($l_fmt, $c->{r}),' | ';
  		print "$c->{c} | " if $show_commit;
  		print $x;
  	} else {
  		show_commit_normal($c);
  	}
  }
  
  sub show_commit_changed_paths {
  	my ($c) = @_;
  	return unless $c->{changed};
  	print "Changed paths:\n", @{$c->{changed}};
  }
  
  sub show_commit_normal {
  	my ($c) = @_;
  	print commit_log_separator, "r$c->{r} | ";
  	print "$c->{c} | " if $show_commit;
  	print "$c->{a} | ", format_svn_date($c->{t_utc}), ' | ';
  	my $nr_line = 0;
  
  	if (my $l = $c->{l}) {
  		while ($l->[$#$l] eq "\n" && $#$l > 0
  		                          && $l->[($#$l - 1)] eq "\n") {
  			pop @$l;
  		}
  		$nr_line = scalar @$l;
  		if (!$nr_line) {
  			print "1 line\n\n\n";
  		} else {
  			if ($nr_line == 1) {
  				$nr_line = '1 line';
  			} else {
  				$nr_line .= ' lines';
  			}
  			print $nr_line, "\n";
  			show_commit_changed_paths($c);
  			print "\n";
  			print $_ foreach @$l;
  		}
  	} else {
  		print "1 line\n";
  		show_commit_changed_paths($c);
  		print "\n";
  
  	}
  	foreach my $x (qw/raw stat diff/) {
  		if ($c->{$x}) {
  			print "\n";
  			print $_ foreach @{$c->{$x}}
  		}
  	}
  }
  
  sub cmd_show_log {
  	my (@args) = @_;
  	my ($r_min, $r_max);
  	my $r_last = -1; # prevent dupes
  	set_local_timezone();
  	if (defined $::_revision) {
  		if ($::_revision =~ /^(\d+):(\d+)$/) {
  			($r_min, $r_max) = ($1, $2);
  		} elsif ($::_revision =~ /^\d+$/) {
  			$r_min = $r_max = $::_revision;
  		} else {
  			fatal "-r$::_revision is not supported, use ",
  				"standard 'git log' arguments instead";
  		}
  	}
  
  	config_pager();
  	@args = git_svn_log_cmd($r_min, $r_max, @args);
  	if (!@args) {
  		print commit_log_separator unless $incremental || $oneline;
  		return;
  	}
  	my $log = command_output_pipe(@args);
  	run_pager();
  	my (@k, $c, $d, $stat);
  	my $esc_color = qr/(?:\033\[(?:(?:\d+;)*\d*)?m)*/;
  	while (<$log>) {
  		if (/^${esc_color}commit (?:- )?($::sha1_short)/o) {
  			my $cmt = $1;
  			if ($c && cmt_showable($c) && $c->{r} != $r_last) {
  				$r_last = $c->{r};
  				process_commit($c, $r_min, $r_max, \@k) or
  								goto out;
  			}
  			$d = undef;
  			$c = { c => $cmt };
  		} elsif (/^${esc_color}author (.+) (\d+) ([\-\+]?\d+)$/o) {
  			get_author_info($c, $1, $2, $3);
  		} elsif (/^${esc_color}(?:tree|parent|committer) /o) {
  			# ignore
  		} elsif (/^${esc_color}:\d{6} \d{6} $::sha1_short/o) {
  			push @{$c->{raw}}, $_;
  		} elsif (/^${esc_color}[ACRMDT]\t/) {
  			# we could add $SVN->{svn_path} here, but that requires
  			# remote access at the moment (repo_path_split)...
  			s#^(${esc_color})([ACRMDT])\t#$1   $2 #o;
  			push @{$c->{changed}}, $_;
  		} elsif (/^${esc_color}diff /o) {
  			$d = 1;
  			push @{$c->{diff}}, $_;
  		} elsif ($d) {
  			push @{$c->{diff}}, $_;
  		} elsif (/^\ .+\ \|\s*\d+\ $esc_color[\+\-]*
  		          $esc_color*[\+\-]*$esc_color$/x) {
  			$stat = 1;
  			push @{$c->{stat}}, $_;
  		} elsif ($stat && /^ \d+ files changed, \d+ insertions/) {
  			push @{$c->{stat}}, $_;
  			$stat = undef;
  		} elsif (/^${esc_color}    (git-svn-id:.+)$/o) {
  			($c->{url}, $c->{r}, undef) = ::extract_metadata($1);
  		} elsif (s/^${esc_color}    //o) {
  			push @{$c->{l}}, $_;
  		}
  	}
  	if ($c && defined $c->{r} && $c->{r} != $r_last) {
  		$r_last = $c->{r};
  		process_commit($c, $r_min, $r_max, \@k);
  	}
  	if (@k) {
  		($r_min, $r_max) = ($r_max, $r_min);
  		process_commit($_, $r_min, $r_max) foreach reverse @k;
  	}
  out:
  	close $log;
  	print commit_log_separator unless $incremental || $oneline;
  }
  
  sub cmd_blame {
  	my $path = pop;
  
  	config_pager();
  	run_pager();
  
  	my ($fh, $ctx, $rev);
  
  	if ($_git_format) {
  		($fh, $ctx) = command_output_pipe('blame', @_, $path);
  		while (my $line = <$fh>) {
  			if ($line =~ /^\^?([[:xdigit:]]+)\s/) {
  				# Uncommitted edits show up as a rev ID of
  				# all zeros, which we can't look up with
  				# cmt_metadata
  				if ($1 !~ /^0+$/) {
  					(undef, $rev, undef) =
  						::cmt_metadata($1);
  					$rev = '0' if (!$rev);
  				} else {
  					$rev = '0';
  				}
  				$rev = sprintf('%-10s', $rev);
  				$line =~ s/^\^?[[:xdigit:]]+(\s)/$rev$1/;
  			}
  			print $line;
  		}
  	} else {
  		($fh, $ctx) = command_output_pipe('blame', '-p', @_, 'HEAD',
  						  '--', $path);
  		my ($sha1);
  		my %authors;
  		my @buffer;
  		my %dsha; #distinct sha keys
  
  		while (my $line = <$fh>) {
  			push @buffer, $line;
  			if ($line =~ /^([[:xdigit:]]{40})\s\d+\s\d+/) {
  				$dsha{$1} = 1;
  			}
  		}
  
  		my $s2r = ::cmt_sha2rev_batch([keys %dsha]);
  
  		foreach my $line (@buffer) {
  			if ($line =~ /^([[:xdigit:]]{40})\s\d+\s\d+/) {
  				$rev = $s2r->{$1};
  				$rev = '0' if (!$rev)
  			}
  			elsif ($line =~ /^author (.*)/) {
  				$authors{$rev} = $1;
  				$authors{$rev} =~ s/\s/_/g;
  			}
  			elsif ($line =~ /^\t(.*)$/) {
  				printf("%6s %10s %s\n", $rev, $authors{$rev}, $1);
  			}
  		}
  	}
  	command_close_pipe($fh, $ctx);
  }
  
  1;
GIT_SVN_LOG

$fatpacked{"Git/SVN/Memoize/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_MEMOIZE_YAML';
  package Git::SVN::Memoize::YAML;
  use warnings;
  use strict;
  use YAML::Any ();
  
  # based on Memoize::Storable.
  
  sub TIEHASH {
  	my $package = shift;
  	my $filename = shift;
  	my $truehash = (-e $filename) ? YAML::Any::LoadFile($filename) : {};
  	my $self = {FILENAME => $filename, H => $truehash};
  	bless $self => $package;
  }
  
  sub STORE {
  	my $self = shift;
  	$self->{H}{$_[0]} = $_[1];
  }
  
  sub FETCH {
  	my $self = shift;
  	$self->{H}{$_[0]};
  }
  
  sub EXISTS {
  	my $self = shift;
  	exists $self->{H}{$_[0]};
  }
  
  sub DESTROY {
  	my $self = shift;
  	YAML::Any::DumpFile($self->{FILENAME}, $self->{H});
  }
  
  sub SCALAR {
  	my $self = shift;
  	scalar(%{$self->{H}});
  }
  
  sub FIRSTKEY {
  	'Fake hash from Git::SVN::Memoize::YAML';
  }
  
  sub NEXTKEY {
  	undef;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Git::SVN::Memoize::YAML - store Memoized data in YAML format
  
  =head1 SYNOPSIS
  
      use Memoize;
      use Git::SVN::Memoize::YAML;
  
      tie my %cache => 'Git::SVN::Memoize::YAML', $filename;
      memoize('slow_function', SCALAR_CACHE => [HASH => \%cache]);
      slow_function(arguments);
  
  =head1 DESCRIPTION
  
  This module provides a class that can be used to tie a hash to a
  YAML file.  The file is read when the hash is initialized and
  rewritten when the hash is destroyed.
  
  The intent is to allow L<Memoize> to back its cache with a file in
  YAML format, just like L<Memoize::Storable> allows L<Memoize> to
  back its cache with a file in Storable format.  Unlike the Storable
  format, the YAML format is platform-independent and fairly stable.
  
  Carps on error.
  
  =head1 DIAGNOSTICS
  
  See L<YAML::Any>.
  
  =head1 DEPENDENCIES
  
  L<YAML::Any> from CPAN.
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  =head1 BUGS
  
  The entire cache is read into a Perl hash when loading the file,
  so this is not very scalable.
GIT_SVN_MEMOIZE_YAML

$fatpacked{"Git/SVN/Migration.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_MIGRATION';
  package Git::SVN::Migration;
  # these version numbers do NOT correspond to actual version numbers
  # of git or git-svn.  They are just relative.
  #
  # v0 layout: .git/$id/info/url, refs/heads/$id-HEAD
  #
  # v1 layout: .git/$id/info/url, refs/remotes/$id
  #
  # v2 layout: .git/svn/$id/info/url, refs/remotes/$id
  #
  # v3 layout: .git/svn/$id, refs/remotes/$id
  #            - info/url may remain for backwards compatibility
  #            - this is what we migrate up to this layout automatically,
  #            - this will be used by git svn init on single branches
  # v3.1 layout (auto migrated):
  #            - .rev_db => .rev_db.$UUID, .rev_db will remain as a symlink
  #              for backwards compatibility
  #
  # v4 layout: .git/svn/$repo_id/$id, refs/remotes/$repo_id/$id
  #            - this is only created for newly multi-init-ed
  #              repositories.  Similar in spirit to the
  #              --use-separate-remotes option in git-clone (now default)
  #            - we do not automatically migrate to this (following
  #              the example set by core git)
  #
  # v5 layout: .rev_db.$UUID => .rev_map.$UUID
  #            - newer, more-efficient format that uses 24-bytes per record
  #              with no filler space.
  #            - use xxd -c24 < .rev_map.$UUID to view and debug
  #            - This is a one-way migration, repositories updated to the
  #              new format will not be able to use old git-svn without
  #              rebuilding the .rev_db.  Rebuilding the rev_db is not
  #              possible if noMetadata or useSvmProps are set; but should
  #              be no problem for users that use the (sensible) defaults.
  use strict;
  use warnings;
  use Carp qw/croak/;
  use File::Path qw/mkpath/;
  use File::Basename qw/dirname basename/;
  
  our $_minimize;
  use Git qw(
  	command
  	command_noisy
  	command_output_pipe
  	command_close_pipe
  	command_oneline
  );
  use Git::SVN;
  
  sub migrate_from_v0 {
  	my $git_dir = $ENV{GIT_DIR};
  	return undef unless -d $git_dir;
  	my ($fh, $ctx) = command_output_pipe(qw/rev-parse --symbolic --all/);
  	my $migrated = 0;
  	while (<$fh>) {
  		chomp;
  		my ($id, $orig_ref) = ($_, $_);
  		next unless $id =~ s#^refs/heads/(.+)-HEAD$#$1#;
  		my $info_url = command_oneline(qw(rev-parse --git-path),
  						"$id/info/url");
  		next unless -f $info_url;
  		my $new_ref = "refs/remotes/$id";
  		if (::verify_ref("$new_ref^0")) {
  			print STDERR "W: $orig_ref is probably an old ",
  			             "branch used by an ancient version of ",
  				     "git-svn.\n",
  				     "However, $new_ref also exists.\n",
  				     "We will not be able ",
  				     "to use this branch until this ",
  				     "ambiguity is resolved.\n";
  			next;
  		}
  		print STDERR "Migrating from v0 layout...\n" if !$migrated;
  		print STDERR "Renaming ref: $orig_ref => $new_ref\n";
  		command_noisy('update-ref', $new_ref, $orig_ref);
  		command_noisy('update-ref', '-d', $orig_ref, $orig_ref);
  		$migrated++;
  	}
  	command_close_pipe($fh, $ctx);
  	print STDERR "Done migrating from v0 layout...\n" if $migrated;
  	$migrated;
  }
  
  sub migrate_from_v1 {
  	my $git_dir = $ENV{GIT_DIR};
  	my $migrated = 0;
  	return $migrated unless -d $git_dir;
  	my $svn_dir = Git::SVN::svn_dir();
  
  	# just in case somebody used 'svn' as their $id at some point...
  	return $migrated if -d $svn_dir && ! -f "$svn_dir/info/url";
  
  	print STDERR "Migrating from a git-svn v1 layout...\n";
  	mkpath([$svn_dir]);
  	print STDERR "Data from a previous version of git-svn exists, but\n\t",
  	             "$svn_dir\n\t(required for this version ",
  	             "($::VERSION) of git-svn) does not exist.\n";
  	my ($fh, $ctx) = command_output_pipe(qw/rev-parse --symbolic --all/);
  	while (<$fh>) {
  		my $x = $_;
  		next unless $x =~ s#^refs/remotes/##;
  		chomp $x;
  		my $info_url = command_oneline(qw(rev-parse --git-path),
  						"$x/info/url");
  		next unless -f $info_url;
  		my $u = eval { ::file_to_s($info_url) };
  		next unless $u;
  		my $dn = dirname("$svn_dir/$x");
  		mkpath([$dn]) unless -d $dn;
  		if ($x eq 'svn') { # they used 'svn' as GIT_SVN_ID:
  			mkpath(["$svn_dir/svn"]);
  			print STDERR " - $git_dir/$x/info => ",
  			                "$svn_dir/$x/info\n";
  			rename "$git_dir/$x/info", "$svn_dir/$x/info" or
  			       croak "$!: $x";
  			# don't worry too much about these, they probably
  			# don't exist with repos this old (save for index,
  			# and we can easily regenerate that)
  			foreach my $f (qw/unhandled.log index .rev_db/) {
  				rename "$git_dir/$x/$f", "$svn_dir/$x/$f";
  			}
  		} else {
  			print STDERR " - $git_dir/$x => $svn_dir/$x\n";
  			rename "$git_dir/$x", "$svn_dir/$x" or croak "$!: $x";
  		}
  		$migrated++;
  	}
  	command_close_pipe($fh, $ctx);
  	print STDERR "Done migrating from a git-svn v1 layout\n";
  	$migrated;
  }
  
  sub read_old_urls {
  	my ($l_map, $pfx, $path) = @_;
  	my @dir;
  	foreach (<$path/*>) {
  		if (-r "$_/info/url") {
  			$pfx .= '/' if $pfx && $pfx !~ m!/$!;
  			my $ref_id = $pfx . basename $_;
  			my $url = ::file_to_s("$_/info/url");
  			$l_map->{$ref_id} = $url;
  		} elsif (-d $_) {
  			push @dir, $_;
  		}
  	}
  	my $svn_dir = Git::SVN::svn_dir();
  	foreach (@dir) {
  		my $x = $_;
  		$x =~ s!^\Q$svn_dir\E/!!o;
  		read_old_urls($l_map, $x, $_);
  	}
  }
  
  sub migrate_from_v2 {
  	my @cfg = command(qw/config -l/);
  	return if grep /^svn-remote\..+\.url=/, @cfg;
  	my %l_map;
  	read_old_urls(\%l_map, '', Git::SVN::svn_dir());
  	my $migrated = 0;
  
  	require Git::SVN;
  	foreach my $ref_id (sort keys %l_map) {
  		eval { Git::SVN->init($l_map{$ref_id}, '', undef, $ref_id) };
  		if ($@) {
  			Git::SVN->init($l_map{$ref_id}, '', $ref_id, $ref_id);
  		}
  		$migrated++;
  	}
  	$migrated;
  }
  
  sub minimize_connections {
  	require Git::SVN;
  	require Git::SVN::Ra;
  
  	my $r = Git::SVN::read_all_remotes();
  	my $new_urls = {};
  	my $root_repos = {};
  	foreach my $repo_id (keys %$r) {
  		my $url = $r->{$repo_id}->{url} or next;
  		my $fetch = $r->{$repo_id}->{fetch} or next;
  		my $ra = Git::SVN::Ra->new($url);
  
  		# skip existing cases where we already connect to the root
  		if (($ra->url eq $ra->{repos_root}) ||
  		    ($ra->{repos_root} eq $repo_id)) {
  			$root_repos->{$ra->url} = $repo_id;
  			next;
  		}
  
  		my $root_ra = Git::SVN::Ra->new($ra->{repos_root});
  		my $root_path = $ra->url;
  		$root_path =~ s#^\Q$ra->{repos_root}\E(/|$)##;
  		foreach my $path (keys %$fetch) {
  			my $ref_id = $fetch->{$path};
  			my $gs = Git::SVN->new($ref_id, $repo_id, $path);
  
  			# make sure we can read when connecting to
  			# a higher level of a repository
  			my ($last_rev, undef) = $gs->last_rev_commit;
  			if (!defined $last_rev) {
  				$last_rev = eval {
  					$root_ra->get_latest_revnum;
  				};
  				next if $@;
  			}
  			my $new = $root_path;
  			$new .= length $path ? "/$path" : '';
  			eval {
  				$root_ra->get_log([$new], $last_rev, $last_rev,
  			                          0, 0, 1, sub { });
  			};
  			next if $@;
  			$new_urls->{$ra->{repos_root}}->{$new} =
  			        { ref_id => $ref_id,
  				  old_repo_id => $repo_id,
  				  old_path => $path };
  		}
  	}
  
  	my @emptied;
  	foreach my $url (keys %$new_urls) {
  		# see if we can re-use an existing [svn-remote "repo_id"]
  		# instead of creating a(n ugly) new section:
  		my $repo_id = $root_repos->{$url} || $url;
  
  		my $fetch = $new_urls->{$url};
  		foreach my $path (keys %$fetch) {
  			my $x = $fetch->{$path};
  			Git::SVN->init($url, $path, $repo_id, $x->{ref_id});
  			my $pfx = "svn-remote.$x->{old_repo_id}";
  
  			my $old_fetch = quotemeta("$x->{old_path}:".
  			                          "$x->{ref_id}");
  			command_noisy(qw/config --unset/,
  			              "$pfx.fetch", '^'. $old_fetch . '$');
  			delete $r->{$x->{old_repo_id}}->
  			       {fetch}->{$x->{old_path}};
  			if (!keys %{$r->{$x->{old_repo_id}}->{fetch}}) {
  				command_noisy(qw/config --unset/,
  				              "$pfx.url");
  				push @emptied, $x->{old_repo_id}
  			}
  		}
  	}
  	if (@emptied) {
  		my $file = $ENV{GIT_CONFIG} ||
  			command_oneline(qw(rev-parse --git-path config));
  		print STDERR <<EOF;
  The following [svn-remote] sections in your config file ($file) are empty
  and can be safely removed:
  EOF
  		print STDERR "[svn-remote \"$_\"]\n" foreach @emptied;
  	}
  }
  
  sub migration_check {
  	migrate_from_v0();
  	migrate_from_v1();
  	migrate_from_v2();
  	minimize_connections() if $_minimize;
  }
  
  1;
GIT_SVN_MIGRATION

$fatpacked{"Git/SVN/Prompt.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_PROMPT';
  package Git::SVN::Prompt;
  use strict;
  use warnings;
  require SVN::Core;
  use vars qw/$_no_auth_cache $_username/;
  
  sub simple {
  	my ($cred, $realm, $default_username, $may_save, $pool) = @_;
  	$may_save = undef if $_no_auth_cache;
  	$default_username = $_username if defined $_username;
  	if (defined $default_username && length $default_username) {
  		if (defined $realm && length $realm) {
  			print STDERR "Authentication realm: $realm\n";
  			STDERR->flush;
  		}
  		$cred->username($default_username);
  	} else {
  		username($cred, $realm, $may_save, $pool);
  	}
  	$cred->password(_read_password("Password for '" .
  	                               $cred->username . "': ", $realm));
  	$cred->may_save($may_save);
  	$SVN::_Core::SVN_NO_ERROR;
  }
  
  sub ssl_server_trust {
  	my ($cred, $realm, $failures, $cert_info, $may_save, $pool) = @_;
  	$may_save = undef if $_no_auth_cache;
  	print STDERR "Error validating server certificate for '$realm':\n";
  	{
  		no warnings 'once';
  		# All variables SVN::Auth::SSL::* are used only once,
  		# so we're shutting up Perl warnings about this.
  		if ($failures & $SVN::Auth::SSL::UNKNOWNCA) {
  			print STDERR " - The certificate is not issued ",
  			    "by a trusted authority. Use the\n",
  			    "   fingerprint to validate ",
  			    "the certificate manually!\n";
  		}
  		if ($failures & $SVN::Auth::SSL::CNMISMATCH) {
  			print STDERR " - The certificate hostname ",
  			    "does not match.\n";
  		}
  		if ($failures & $SVN::Auth::SSL::NOTYETVALID) {
  			print STDERR " - The certificate is not yet valid.\n";
  		}
  		if ($failures & $SVN::Auth::SSL::EXPIRED) {
  			print STDERR " - The certificate has expired.\n";
  		}
  		if ($failures & $SVN::Auth::SSL::OTHER) {
  			print STDERR " - The certificate has ",
  			    "an unknown error.\n";
  		}
  	} # no warnings 'once'
  	printf STDERR
  	        "Certificate information:\n".
  	        " - Hostname: %s\n".
  	        " - Valid: from %s until %s\n".
  	        " - Issuer: %s\n".
  	        " - Fingerprint: %s\n",
  	        map $cert_info->$_, qw(hostname valid_from valid_until
  	                               issuer_dname fingerprint);
  	my $choice;
  prompt:
  	my $options = $may_save ?
  	      "(R)eject, accept (t)emporarily or accept (p)ermanently? " :
  	      "(R)eject or accept (t)emporarily? ";
  	STDERR->flush;
  	$choice = lc(substr(Git::prompt("Certificate problem.\n" . $options) || 'R', 0, 1));
  	if ($choice eq 't') {
  		$cred->may_save(undef);
  	} elsif ($choice eq 'r') {
  		return -1;
  	} elsif ($may_save && $choice eq 'p') {
  		$cred->may_save($may_save);
  	} else {
  		goto prompt;
  	}
  	$cred->accepted_failures($failures);
  	$SVN::_Core::SVN_NO_ERROR;
  }
  
  sub ssl_client_cert {
  	my ($cred, $realm, $may_save, $pool) = @_;
  	$may_save = undef if $_no_auth_cache;
  	print STDERR "Client certificate filename: ";
  	STDERR->flush;
  	chomp(my $filename = <STDIN>);
  	$cred->cert_file($filename);
  	$cred->may_save($may_save);
  	$SVN::_Core::SVN_NO_ERROR;
  }
  
  sub ssl_client_cert_pw {
  	my ($cred, $realm, $may_save, $pool) = @_;
  	$may_save = undef if $_no_auth_cache;
  	$cred->password(_read_password("Password: ", $realm));
  	$cred->may_save($may_save);
  	$SVN::_Core::SVN_NO_ERROR;
  }
  
  sub username {
  	my ($cred, $realm, $may_save, $pool) = @_;
  	$may_save = undef if $_no_auth_cache;
  	if (defined $realm && length $realm) {
  		print STDERR "Authentication realm: $realm\n";
  	}
  	my $username;
  	if (defined $_username) {
  		$username = $_username;
  	} else {
  		$username = Git::prompt("Username: ");
  	}
  	$cred->username($username);
  	$cred->may_save($may_save);
  	$SVN::_Core::SVN_NO_ERROR;
  }
  
  sub _read_password {
  	my ($prompt, $realm) = @_;
  	my $password = Git::prompt($prompt, 1);
  	$password;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Git::SVN::Prompt - authentication callbacks for git-svn
  
  =head1 SYNOPSIS
  
      use Git::SVN::Prompt qw(simple ssl_client_cert ssl_client_cert_pw
                              ssl_server_trust username);
      use SVN::Client ();
  
      my $cached_simple = SVN::Client::get_simple_provider();
      my $git_simple = SVN::Client::get_simple_prompt_provider(\&simple, 2);
      my $cached_ssl = SVN::Client::get_ssl_server_trust_file_provider();
      my $git_ssl = SVN::Client::get_ssl_server_trust_prompt_provider(
          \&ssl_server_trust);
      my $cached_cert = SVN::Client::get_ssl_client_cert_file_provider();
      my $git_cert = SVN::Client::get_ssl_client_cert_prompt_provider(
          \&ssl_client_cert, 2);
      my $cached_cert_pw = SVN::Client::get_ssl_client_cert_pw_file_provider();
      my $git_cert_pw = SVN::Client::get_ssl_client_cert_pw_prompt_provider(
          \&ssl_client_cert_pw, 2);
      my $cached_username = SVN::Client::get_username_provider();
      my $git_username = SVN::Client::get_username_prompt_provider(
          \&username, 2);
  
      my $ctx = new SVN::Client(
          auth => [
              $cached_simple, $git_simple,
              $cached_ssl, $git_ssl,
              $cached_cert, $git_cert,
              $cached_cert_pw, $git_cert_pw,
              $cached_username, $git_username
          ]);
  
  =head1 DESCRIPTION
  
  This module is an implementation detail of the "git svn" command.
  It implements git-svn's authentication policy.  Do not use it unless
  you are developing git-svn.
  
  The interface will change as git-svn evolves.
  
  =head1 DEPENDENCIES
  
  L<SVN::Core>.
  
  =head1 SEE ALSO
  
  L<SVN::Client>.
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  =head1 BUGS
  
  None.
GIT_SVN_PROMPT

$fatpacked{"Git/SVN/Ra.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_RA';
  package Git::SVN::Ra;
  use vars qw/@ISA $config_dir $_ignore_refs_regex $_log_window_size/;
  use strict;
  use warnings;
  use Memoize;
  use Git::SVN::Utils qw(
  	canonicalize_url
  	canonicalize_path
  	add_path_to_url
  );
  
  use SVN::Ra;
  BEGIN {
  	@ISA = qw(SVN::Ra);
  }
  
  my ($ra_invalid, $can_do_switch, %ignored_err, $RA);
  
  BEGIN {
  	# enforce temporary pool usage for some simple functions
  	no strict 'refs';
  	for my $f (qw/rev_proplist get_latest_revnum get_uuid get_repos_root
  	              get_file/) {
  		my $SUPER = "SUPER::$f";
  		*$f = sub {
  			my $self = shift;
  			my $pool = SVN::Pool->new;
  			my @ret = $self->$SUPER(@_,$pool);
  			$pool->clear;
  			wantarray ? @ret : $ret[0];
  		};
  	}
  }
  
  # serf has a bug that leads to a coredump upon termination if the
  # remote access object is left around (not fixed yet in serf 1.3.1).
  # Explicitly free it to work around the issue.
  END {
  	$RA = undef;
  	$ra_invalid = 1;
  }
  
  sub _auth_providers () {
  	require SVN::Client;
  	my @rv = (
  	  SVN::Client::get_simple_provider(),
  	  SVN::Client::get_ssl_server_trust_file_provider(),
  	  SVN::Client::get_simple_prompt_provider(
  	    \&Git::SVN::Prompt::simple, 2),
  	  SVN::Client::get_ssl_client_cert_file_provider(),
  	  SVN::Client::get_ssl_client_cert_prompt_provider(
  	    \&Git::SVN::Prompt::ssl_client_cert, 2),
  	  SVN::Client::get_ssl_client_cert_pw_file_provider(),
  	  SVN::Client::get_ssl_client_cert_pw_prompt_provider(
  	    \&Git::SVN::Prompt::ssl_client_cert_pw, 2),
  	  SVN::Client::get_username_provider(),
  	  SVN::Client::get_ssl_server_trust_prompt_provider(
  	    \&Git::SVN::Prompt::ssl_server_trust),
  	  SVN::Client::get_username_prompt_provider(
  	    \&Git::SVN::Prompt::username, 2)
  	);
  
  	# earlier 1.6.x versions would segfault, and <= 1.5.x didn't have
  	# this function
  	if (::compare_svn_version('1.6.15') >= 0) {
  		my $config = SVN::Core::config_get_config($config_dir);
  		my ($p, @a);
  		# config_get_config returns all config files from
  		# ~/.subversion, auth_get_platform_specific_client_providers
  		# just wants the config "file".
  		@a = ($config->{'config'}, undef);
  		$p = SVN::Core::auth_get_platform_specific_client_providers(@a);
  		# Insert the return value from
  		# auth_get_platform_specific_providers
  		unshift @rv, @$p;
  	}
  	\@rv;
  }
  
  sub prepare_config_once {
  	SVN::_Core::svn_config_ensure($config_dir, undef);
  	my ($baton, $callbacks) = SVN::Core::auth_open_helper(_auth_providers);
  	my $config = SVN::Core::config_get_config($config_dir);
  	my $conf_t = $config->{'config'};
  
  	no warnings 'once';
  	# The usage of $SVN::_Core::SVN_CONFIG_* variables
  	# produces warnings that variables are used only once.
  	# I had not found the better way to shut them up, so
  	# the warnings of type 'once' are disabled in this block.
  	if (SVN::_Core::svn_config_get_bool($conf_t,
  	    $SVN::_Core::SVN_CONFIG_SECTION_AUTH,
  	    $SVN::_Core::SVN_CONFIG_OPTION_STORE_PASSWORDS,
  	    1) == 0) {
  		my $val = '1';
  		if (::compare_svn_version('1.9.0') < 0) { # pre-SVN r1553823
  			my $dont_store_passwords = 1;
  			$val = bless \$dont_store_passwords, "_p_void";
  		}
  		SVN::_Core::svn_auth_set_parameter($baton,
  		    $SVN::_Core::SVN_AUTH_PARAM_DONT_STORE_PASSWORDS,
  		    $val);
  	}
  	if (SVN::_Core::svn_config_get_bool($conf_t,
  	    $SVN::_Core::SVN_CONFIG_SECTION_AUTH,
  	    $SVN::_Core::SVN_CONFIG_OPTION_STORE_AUTH_CREDS,
  	    1) == 0) {
  		$Git::SVN::Prompt::_no_auth_cache = 1;
  	}
  
  	return ($config, $baton, $callbacks);
  } # no warnings 'once'
  
  INIT {
  	Memoize::memoize '_auth_providers';
  	Memoize::memoize 'prepare_config_once';
  }
  
  sub new {
  	my ($class, $url) = @_;
  	$url = canonicalize_url($url);
  	return $RA if ($RA && $RA->url eq $url);
  
  	::_req_svn();
  
  	$RA = undef;
  	my ($config, $baton, $callbacks) = prepare_config_once();
  	my $self = SVN::Ra->new(url => $url, auth => $baton,
  	                      config => $config,
  			      pool => SVN::Pool->new,
  	                      auth_provider_callbacks => $callbacks);
  	$RA = bless $self, $class;
  
  	# Make sure its canonicalized
  	$self->url($url);
  	$self->{svn_path} = $url;
  	$self->{repos_root} = $self->get_repos_root;
  	$self->{svn_path} =~ s#^\Q$self->{repos_root}\E(/|$)##;
  	$self->{cache} = { check_path => { r => 0, data => {} },
  	                   get_dir => { r => 0, data => {} } };
  
  	return $RA;
  }
  
  sub url {
  	my $self = shift;
  
  	if (@_) {
  		my $url = shift;
  		$self->{url} = canonicalize_url($url);
  		return;
  	}
  
  	return $self->{url};
  }
  
  sub check_path {
  	my ($self, $path, $r) = @_;
  	my $cache = $self->{cache}->{check_path};
  	if ($r == $cache->{r} && exists $cache->{data}->{$path}) {
  		return $cache->{data}->{$path};
  	}
  	my $pool = SVN::Pool->new;
  	my $t = $self->SUPER::check_path($path, $r, $pool);
  	$pool->clear;
  	if ($r != $cache->{r}) {
  		%{$cache->{data}} = ();
  		$cache->{r} = $r;
  	}
  	$cache->{data}->{$path} = $t;
  }
  
  sub get_dir {
  	my ($self, $dir, $r) = @_;
  	my $cache = $self->{cache}->{get_dir};
  	if ($r == $cache->{r}) {
  		if (my $x = $cache->{data}->{$dir}) {
  			return wantarray ? @$x : $x->[0];
  		}
  	}
  	my $pool = SVN::Pool->new;
  	my ($d, undef, $props);
  
  	if (::compare_svn_version('1.4.0') >= 0) {
  		# n.b. in addition to being potentially more efficient,
  		# this works around what appears to be a bug in some
  		# SVN 1.8 versions
  		my $kind = 1; # SVN_DIRENT_KIND
  		($d, undef, $props) = $self->get_dir2($dir, $r, $kind, $pool);
  	} else {
  		($d, undef, $props) = $self->SUPER::get_dir($dir, $r, $pool);
  	}
  	my %dirents = map { $_ => { kind => $d->{$_}->kind } } keys %$d;
  	$pool->clear;
  	if ($r != $cache->{r}) {
  		%{$cache->{data}} = ();
  		$cache->{r} = $r;
  	}
  	$cache->{data}->{$dir} = [ \%dirents, $r, $props ];
  	wantarray ? (\%dirents, $r, $props) : \%dirents;
  }
  
  # get_log(paths, start, end, limit,
  #         discover_changed_paths, strict_node_history, receiver)
  sub get_log {
  	my ($self, @args) = @_;
  	my $pool = SVN::Pool->new;
  
  	# svn_log_changed_path_t objects passed to get_log are likely to be
  	# overwritten even if only the refs are copied to an external variable,
  	# so we should dup the structures in their entirety.  Using an
  	# externally passed pool (instead of our temporary and quickly cleared
  	# pool in Git::SVN::Ra) does not help matters at all...
  	my $receiver = pop @args;
  	my $prefix = "/".$self->{svn_path};
  	$prefix =~ s#/+($)##;
  	my $prefix_regex = qr#^\Q$prefix\E#;
  	push(@args, sub {
  		my ($paths) = $_[0];
  		return &$receiver(@_) unless $paths;
  		$_[0] = ();
  		foreach my $p (keys %$paths) {
  			my $i = $paths->{$p};
  			# Make path relative to our url, not repos_root
  			$p =~ s/$prefix_regex//;
  			my %s = map { $_ => $i->$_; }
  				qw/copyfrom_path copyfrom_rev action/;
  			if ($s{'copyfrom_path'}) {
  				$s{'copyfrom_path'} =~ s/$prefix_regex//;
  				$s{'copyfrom_path'} = canonicalize_path($s{'copyfrom_path'});
  			}
  			$_[0]{$p} = \%s;
  		}
  		&$receiver(@_);
  	});
  
  
  	# the limit parameter was not supported in SVN 1.1.x, so we
  	# drop it.  Therefore, the receiver callback passed to it
  	# is made aware of this limitation by being wrapped if
  	# the limit passed to is being wrapped.
  	if (::compare_svn_version('1.2.0') <= 0) {
  		my $limit = splice(@args, 3, 1);
  		if ($limit > 0) {
  			my $receiver = pop @args;
  			push(@args, sub { &$receiver(@_) if (--$limit >= 0) });
  		}
  	}
  	my $ret = $self->SUPER::get_log(@args, $pool);
  	$pool->clear;
  	$ret;
  }
  
  # uncommon, only for ancient SVN (<= 1.4.2)
  sub trees_match {
  	require IO::File;
  	require SVN::Client;
  	my ($self, $url1, $rev1, $url2, $rev2) = @_;
  	my $ctx = SVN::Client->new(auth => _auth_providers);
  	my $out = IO::File->new_tmpfile;
  
  	# older SVN (1.1.x) doesn't take $pool as the last parameter for
  	# $ctx->diff(), so we'll create a default one
  	my $pool = SVN::Pool->new_default_sub;
  
  	$ra_invalid = 1; # this will open a new SVN::Ra connection to $url1
  	$ctx->diff([], $url1, $rev1, $url2, $rev2, 1, 1, 0, $out, $out);
  	$out->flush;
  	my $ret = (($out->stat)[7] == 0);
  	close $out or croak $!;
  
  	$ret;
  }
  
  sub get_commit_editor {
  	my ($self, $log, $cb, $pool) = @_;
  
  	my @lock = (::compare_svn_version('1.2.0') >= 0) ? (undef, 0) : ();
  	$self->SUPER::get_commit_editor($log, $cb, @lock, $pool);
  }
  
  sub gs_do_update {
  	my ($self, $rev_a, $rev_b, $gs, $editor) = @_;
  	my $new = ($rev_a == $rev_b);
  	my $path = $gs->path;
  
  	if ($new && -e $gs->{index}) {
  		unlink $gs->{index} or die
  		  "Couldn't unlink index: $gs->{index}: $!\n";
  	}
  	my $pool = SVN::Pool->new;
  	$editor->set_path_strip($path);
  	my (@pc) = split m#/#, $path;
  	my $reporter = $self->do_update($rev_b, (@pc ? shift @pc : ''),
  	                                1, $editor, $pool);
  	my @lock = (::compare_svn_version('1.2.0') >= 0) ? (undef) : ();
  
  	# Since we can't rely on svn_ra_reparent being available, we'll
  	# just have to do some magic with set_path to make it so
  	# we only want a partial path.
  	my $sp = '';
  	my $final = join('/', @pc);
  	while (@pc) {
  		$reporter->set_path($sp, $rev_b, 0, @lock, $pool);
  		$sp .= '/' if length $sp;
  		$sp .= shift @pc;
  	}
  	die "BUG: '$sp' != '$final'\n" if ($sp ne $final);
  
  	$reporter->set_path($sp, $rev_a, $new, @lock, $pool);
  
  	$reporter->finish_report($pool);
  	$pool->clear;
  	$editor->{git_commit_ok};
  }
  
  # this requires SVN 1.4.3 or later (do_switch didn't work before 1.4.3, and
  # svn_ra_reparent didn't work before 1.4)
  sub gs_do_switch {
  	my ($self, $rev_a, $rev_b, $gs, $url_b, $editor) = @_;
  	my $path = $gs->path;
  	my $pool = SVN::Pool->new;
  
  	my $old_url = $self->url;
  	my $full_url = add_path_to_url( $self->url, $path );
  	my ($ra, $reparented);
  
  	if ($old_url =~ m#^svn(\+\w+)?://# ||
  	    ($full_url =~ m#^https?://# &&
  	     canonicalize_url($full_url) ne $full_url)) {
  		$_[0] = undef;
  		$self = undef;
  		$RA = undef;
  		$ra = Git::SVN::Ra->new($full_url);
  		$ra_invalid = 1;
  	} elsif ($old_url ne $full_url) {
  		SVN::_Ra::svn_ra_reparent(
  			$self->{session},
  			canonicalize_url($full_url),
  			$pool
  		);
  		$self->url($full_url);
  		$reparented = 1;
  	}
  
  	$ra ||= $self;
  	$url_b = canonicalize_url($url_b);
  	my $reporter = $ra->do_switch($rev_b, '', 1, $url_b, $editor, $pool);
  	my @lock = (::compare_svn_version('1.2.0') >= 0) ? (undef) : ();
  	$reporter->set_path('', $rev_a, 0, @lock, $pool);
  	$reporter->finish_report($pool);
  
  	if ($reparented) {
  		SVN::_Ra::svn_ra_reparent($self->{session}, $old_url, $pool);
  		$self->url($old_url);
  	}
  
  	$pool->clear;
  	$editor->{git_commit_ok};
  }
  
  sub longest_common_path {
  	my ($gsv, $globs) = @_;
  	my %common;
  	my $common_max = scalar @$gsv;
  
  	foreach my $gs (@$gsv) {
  		my @tmp = split m#/#, $gs->path;
  		my $p = '';
  		foreach (@tmp) {
  			$p .= length($p) ? "/$_" : $_;
  			$common{$p} ||= 0;
  			$common{$p}++;
  		}
  	}
  	$globs ||= [];
  	$common_max += scalar @$globs;
  	foreach my $glob (@$globs) {
  		my @tmp = split m#/#, $glob->{path}->{left};
  		my $p = '';
  		foreach (@tmp) {
  			$p .= length($p) ? "/$_" : $_;
  			$common{$p} ||= 0;
  			$common{$p}++;
  		}
  	}
  
  	my $longest_path = '';
  	foreach (sort {length $b <=> length $a} keys %common) {
  		if ($common{$_} == $common_max) {
  			$longest_path = $_;
  			last;
  		}
  	}
  	$longest_path;
  }
  
  sub gs_fetch_loop_common {
  	my ($self, $base, $head, $gsv, $globs) = @_;
  	return if ($base > $head);
  	# Make sure the cat_blob open2 FileHandle is created before calling
  	# SVN::Pool::new_default so that it does not incorrectly end up in the pool.
  	$::_repository->_open_cat_blob_if_needed;
  	my $gpool = SVN::Pool->new_default;
  	my $ra_url = $self->url;
  	my $reload_ra = sub {
  		$_[0] = undef;
  		$self = undef;
  		$RA = undef;
  		$gpool->clear;
  		$self = Git::SVN::Ra->new($ra_url);
  		$ra_invalid = undef;
  	};
  	my $inc = $_log_window_size;
  	my ($min, $max) = ($base, $head < $base + $inc ? $head : $base + $inc);
  	my $longest_path = longest_common_path($gsv, $globs);
  	my $find_trailing_edge;
  	while (1) {
  		my %revs;
  		my $err;
  		my $err_handler = $SVN::Error::handler;
  		$SVN::Error::handler = sub {
  			($err) = @_;
  			skip_unknown_revs($err);
  		};
  		sub _cb {
  			my ($paths, $r, $author, $date, $log) = @_;
  			[ $paths,
  			  { author => $author, date => $date, log => $log } ];
  		}
  		$self->get_log([$longest_path], $min, $max, 0, 1, 1,
  		               sub { $revs{$_[1]} = _cb(@_) });
  		if ($err) {
  			print "Checked through r$max\r";
  		} else {
  			$find_trailing_edge = 1;
  		}
  		if ($err and $find_trailing_edge) {
  			print STDERR "Path '$longest_path' ",
  				     "was probably deleted:\n",
  				     $err->expanded_message,
  				     "\nWill attempt to follow ",
  				     "revisions r$min .. r$max ",
  				     "committed before the deletion\n";
  			my $hi = $max;
  			while (--$hi >= $min) {
  				my $ok;
  				$self->get_log([$longest_path], $min, $hi,
  				               0, 1, 1, sub {
  				               $ok = $_[1];
  				               $revs{$_[1]} = _cb(@_) });
  				if ($ok) {
  					print STDERR "r$min .. r$ok OK\n";
  					last;
  				}
  			}
  			$find_trailing_edge = 0;
  		}
  		$SVN::Error::handler = $err_handler;
  
  		my %exists = map { $_->path => $_ } @$gsv;
  		foreach my $r (sort {$a <=> $b} keys %revs) {
  			my ($paths, $logged) = @{delete $revs{$r}};
  
  			foreach my $gs ($self->match_globs(\%exists, $paths,
  			                                   $globs, $r)) {
  				if ($gs->rev_map_max >= $r) {
  					next;
  				}
  				next unless $gs->match_paths($paths, $r);
  				$gs->{logged_rev_props} = $logged;
  				if (my $last_commit = $gs->last_commit) {
  					$gs->assert_index_clean($last_commit);
  				}
  				my $log_entry = $gs->do_fetch($paths, $r);
  				if ($log_entry) {
  					$gs->do_git_commit($log_entry);
  				}
  				$Git::SVN::INDEX_FILES{$gs->{index}} = 1;
  			}
  			foreach my $g (@$globs) {
  				my $k = "svn-remote.$g->{remote}." .
  				        "$g->{t}-maxRev";
  				Git::SVN::tmp_config($k, $r);
  			}
  			$reload_ra->() if $ra_invalid;
  		}
  		# pre-fill the .rev_db since it'll eventually get filled in
  		# with '0' x40 if something new gets committed
  		foreach my $gs (@$gsv) {
  			next if $gs->rev_map_max >= $max;
  			next if defined $gs->rev_map_get($max);
  			$gs->rev_map_set($max, 0 x40);
  		}
  		foreach my $g (@$globs) {
  			my $k = "svn-remote.$g->{remote}.$g->{t}-maxRev";
  			Git::SVN::tmp_config($k, $max);
  		}
  		last if $max >= $head;
  		$min = $max + 1;
  		$max += $inc;
  		$max = $head if ($max > $head);
  
  		$reload_ra->();
  	}
  	Git::SVN::gc();
  }
  
  sub get_dir_globbed {
  	my ($self, $left, $depth, $r) = @_;
  
  	my @x = eval { $self->get_dir($left, $r) };
  	return unless scalar @x == 3;
  	my $dirents = $x[0];
  	my @finalents;
  	foreach my $de (keys %$dirents) {
  		next if $dirents->{$de}->{kind} != $SVN::Node::dir;
  		if ($depth > 1) {
  			my @args = ("$left/$de", $depth - 1, $r);
  			foreach my $dir ($self->get_dir_globbed(@args)) {
  				push @finalents, "$de/$dir";
  			}
  		} else {
  			push @finalents, $de;
  		}
  	}
  	@finalents;
  }
  
  # return value: 0 -- don't ignore, 1 -- ignore
  sub is_ref_ignored {
  	my ($g, $p) = @_;
  	my $refname = $g->{ref}->full_path($p);
  	return 1 if defined($g->{ignore_refs_regex}) &&
  	            $refname =~ m!$g->{ignore_refs_regex}!;
  	return 0 unless defined($_ignore_refs_regex);
  	return 1 if $refname =~ m!$_ignore_refs_regex!o;
  	return 0;
  }
  
  sub match_globs {
  	my ($self, $exists, $paths, $globs, $r) = @_;
  
  	sub get_dir_check {
  		my ($self, $exists, $g, $r) = @_;
  
  		my @dirs = $self->get_dir_globbed($g->{path}->{left},
  		                                  $g->{path}->{depth},
  		                                  $r);
  
  		foreach my $de (@dirs) {
  			my $p = $g->{path}->full_path($de);
  			next if $exists->{$p};
  			next if (length $g->{path}->{right} &&
  				 ($self->check_path($p, $r) !=
  				  $SVN::Node::dir));
  			next unless $p =~ /$g->{path}->{regex}/;
  			$exists->{$p} = Git::SVN->init($self->url, $p, undef,
  					 $g->{ref}->full_path($de), 1);
  		}
  	}
  	foreach my $g (@$globs) {
  		if (my $path = $paths->{"/$g->{path}->{left}"}) {
  			if ($path->{action} =~ /^[AR]$/) {
  				get_dir_check($self, $exists, $g, $r);
  			}
  		}
  		foreach (keys %$paths) {
  			if (/$g->{path}->{left_regex}/ &&
  			    !/$g->{path}->{regex}/) {
  				next if $paths->{$_}->{action} !~ /^[AR]$/;
  				get_dir_check($self, $exists, $g, $r);
  			}
  			next unless /$g->{path}->{regex}/;
  			my $p = $1;
  			my $pathname = $g->{path}->full_path($p);
  			next if is_ref_ignored($g, $p);
  			next if $exists->{$pathname};
  			next if ($self->check_path($pathname, $r) !=
  			         $SVN::Node::dir);
  			$exists->{$pathname} = Git::SVN->init(
  			                      $self->url, $pathname, undef,
  			                      $g->{ref}->full_path($p), 1);
  		}
  		my $c = '';
  		foreach (split m#/#, $g->{path}->{left}) {
  			$c .= "/$_";
  			next unless ($paths->{$c} &&
  			             ($paths->{$c}->{action} =~ /^[AR]$/));
  			get_dir_check($self, $exists, $g, $r);
  		}
  	}
  	values %$exists;
  }
  
  sub minimize_url {
  	my ($self) = @_;
  	return $self->url if ($self->url eq $self->{repos_root});
  	my $url = $self->{repos_root};
  	my @components = split(m!/!, $self->{svn_path});
  	my $c = '';
  	do {
  		$url = add_path_to_url($url, $c);
  		eval {
  			my $ra = (ref $self)->new($url);
  			my $latest = $ra->get_latest_revnum;
  			$ra->get_log("", $latest, 0, 1, 0, 1, sub {});
  		};
  	} while ($@ && defined($c = shift @components));
  
  	return canonicalize_url($url);
  }
  
  sub can_do_switch {
  	my $self = shift;
  	unless (defined $can_do_switch) {
  		my $pool = SVN::Pool->new;
  		my $rep = eval {
  			$self->do_switch(1, '', 0, $self->url,
  			                 SVN::Delta::Editor->new, $pool);
  		};
  		if ($@) {
  			$can_do_switch = 0;
  		} else {
  			$rep->abort_report($pool);
  			$can_do_switch = 1;
  		}
  		$pool->clear;
  	}
  	$can_do_switch;
  }
  
  sub skip_unknown_revs {
  	my ($err) = @_;
  	my $errno = $err->apr_err();
  	# Maybe the branch we're tracking didn't
  	# exist when the repo started, so it's
  	# not an error if it doesn't, just continue
  	#
  	# Wonderfully consistent library, eh?
  	# 160013 - svn:// and file://
  	# 175002 - http(s)://
  	# 175007 - http(s):// (this repo required authorization, too...)
  	#   More codes may be discovered later...
  	if ($errno == 175007 || $errno == 175002 || $errno == 160013) {
  		my $err_key = $err->expanded_message;
  		# revision numbers change every time, filter them out
  		$err_key =~ s/\d+/\0/g;
  		$err_key = "$errno\0$err_key";
  		unless ($ignored_err{$err_key}) {
  			warn "W: Ignoring error from SVN, path probably ",
  			     "does not exist: ($errno): ",
  			     $err->expanded_message,"\n";
  			warn "W: Do not be alarmed at the above message ",
  			     "git-svn is just searching aggressively for ",
  			     "old history.\n",
  			     "This may take a while on large repositories\n";
  			$ignored_err{$err_key} = 1;
  		}
  		return;
  	}
  	die "Error from SVN, ($errno): ", $err->expanded_message,"\n";
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Git::SVN::Ra - Subversion remote access functions for git-svn
  
  =head1 SYNOPSIS
  
      use Git::SVN::Ra;
  
      my $ra = Git::SVN::Ra->new($branchurl);
      my ($dirents, $fetched_revnum, $props) =
          $ra->get_dir('.', $SVN::Core::INVALID_REVNUM);
  
  =head1 DESCRIPTION
  
  This is a wrapper around the L<SVN::Ra> module for use by B<git-svn>.
  It fills in some default parameters (such as the authentication
  scheme), smooths over incompatibilities between libsvn versions, adds
  caching, and implements some functions specific to B<git-svn>.
  
  Do not use it unless you are developing git-svn.  The interface will
  change as git-svn evolves.
  
  =head1 DEPENDENCIES
  
  Subversion perl bindings,
  L<Git::SVN>.
  
  C<Git::SVN::Ra> has not been tested using callers other than
  B<git-svn> itself.
  
  =head1 SEE ALSO
  
  L<SVN::Ra>.
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  =head1 BUGS
  
  None.
GIT_SVN_RA

$fatpacked{"Git/SVN/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_UTILS';
  package Git::SVN::Utils;
  
  use strict;
  use warnings;
  
  use SVN::Core;
  
  use base qw(Exporter);
  
  our @EXPORT_OK = qw(
  	fatal
  	can_compress
  	canonicalize_path
  	canonicalize_url
  	join_paths
  	add_path_to_url
  );
  
  
  =head1 NAME
  
  Git::SVN::Utils - utility functions used across Git::SVN
  
  =head1 SYNOPSIS
  
      use Git::SVN::Utils qw(functions to import);
  
  =head1 DESCRIPTION
  
  This module contains functions which are useful across many different
  parts of Git::SVN.  Mostly it's a place to put utility functions
  rather than duplicate the code or have classes grabbing at other
  classes.
  
  =head1 FUNCTIONS
  
  All functions can be imported only on request.
  
  =head3 fatal
  
      fatal(@message);
  
  Display a message and exit with a fatal error code.
  
  =cut
  
  # Note: not certain why this is in use instead of die.  Probably because
  # the exit code of die is 255?  Doesn't appear to be used consistently.
  sub fatal (@) { print STDERR "@_\n"; exit 1 }
  
  
  =head3 can_compress
  
      my $can_compress = can_compress;
  
  Returns true if Compress::Zlib is available, false otherwise.
  
  =cut
  
  my $can_compress;
  sub can_compress {
  	return $can_compress if defined $can_compress;
  
  	return $can_compress = eval { require Compress::Zlib; };
  }
  
  
  =head3 canonicalize_path
  
      my $canoncalized_path = canonicalize_path($path);
  
  Converts $path into a canonical form which is safe to pass to the SVN
  API as a file path.
  
  =cut
  
  # Turn foo/../bar into bar
  sub _collapse_dotdot {
  	my $path = shift;
  
  	1 while $path =~ s{/[^/]+/+\.\.}{};
  	1 while $path =~ s{[^/]+/+\.\./}{};
  	1 while $path =~ s{[^/]+/+\.\.}{};
  
  	return $path;
  }
  
  
  sub canonicalize_path {
  	my $path = shift;
  	my $rv;
  
  	# The 1.7 way to do it
  	if ( defined &SVN::_Core::svn_dirent_canonicalize ) {
  		$path = _collapse_dotdot($path);
  		$rv = SVN::_Core::svn_dirent_canonicalize($path);
  	}
  	# The 1.6 way to do it
  	# This can return undef on subversion-perl-1.4.2-2.el5 (CentOS 5.2)
  	elsif ( defined &SVN::_Core::svn_path_canonicalize ) {
  		$path = _collapse_dotdot($path);
  		$rv = SVN::_Core::svn_path_canonicalize($path);
  	}
  
  	return $rv if defined $rv;
  
  	# No SVN API canonicalization is available, or the SVN API
  	# didn't return a successful result, do it ourselves
  	return _canonicalize_path_ourselves($path);
  }
  
  
  sub _canonicalize_path_ourselves {
  	my ($path) = @_;
  	my $dot_slash_added = 0;
  	if (substr($path, 0, 1) ne "/") {
  		$path = "./" . $path;
  		$dot_slash_added = 1;
  	}
  	$path =~ s#/+#/#g;
  	$path =~ s#/\.(?:/|$)#/#g;
  	$path = _collapse_dotdot($path);
  	$path =~ s#/$##g;
  	$path =~ s#^\./## if $dot_slash_added;
  	$path =~ s#^\.$##;
  	return $path;
  }
  
  
  =head3 canonicalize_url
  
      my $canonicalized_url = canonicalize_url($url);
  
  Converts $url into a canonical form which is safe to pass to the SVN
  API as a URL.
  
  =cut
  
  sub canonicalize_url {
  	my $url = shift;
  
  	# The 1.7 way to do it
  	if ( defined &SVN::_Core::svn_uri_canonicalize ) {
  		return SVN::_Core::svn_uri_canonicalize($url);
  	}
  	# There wasn't a 1.6 way to do it, so we do it ourself.
  	else {
  		return _canonicalize_url_ourselves($url);
  	}
  }
  
  
  sub _canonicalize_url_path {
  	my ($uri_path) = @_;
  
  	my @parts;
  	foreach my $part (split m{/+}, $uri_path) {
  		$part =~ s/([^!\$%&'()*+,.\/\w:=\@_`~-]|%(?![a-fA-F0-9]{2}))/sprintf("%%%02X",ord($1))/eg;
  		push @parts, $part;
  	}
  
  	return join('/', @parts);
  }
  
  sub _canonicalize_url_ourselves {
  	my ($url) = @_;
  	if ($url =~ m#^([^:]+)://([^/]*)(.*)$#) {
  		my ($scheme, $domain, $uri) = ($1, $2, _canonicalize_url_path(canonicalize_path($3)));
  		$url = "$scheme://$domain$uri";
  	}
  	$url;
  }
  
  
  =head3 join_paths
  
      my $new_path = join_paths(@paths);
  
  Appends @paths together into a single path.  Any empty paths are ignored.
  
  =cut
  
  sub join_paths {
  	my @paths = @_;
  
  	@paths = grep { defined $_ && length $_ } @paths;
  
  	return '' unless @paths;
  	return $paths[0] if @paths == 1;
  
  	my $new_path = shift @paths;
  	$new_path =~ s{/+$}{};
  
  	my $last_path = pop @paths;
  	$last_path =~ s{^/+}{};
  
  	for my $path (@paths) {
  		$path =~ s{^/+}{};
  		$path =~ s{/+$}{};
  		$new_path .= "/$path";
  	}
  
  	return $new_path .= "/$last_path";
  }
  
  
  =head3 add_path_to_url
  
      my $new_url = add_path_to_url($url, $path);
  
  Appends $path onto the $url.  If $path is empty, $url is returned unchanged.
  
  =cut
  
  sub add_path_to_url {
  	my($url, $path) = @_;
  
  	return $url if !defined $path or !length $path;
  
  	# Strip trailing and leading slashes so we don't
  	# wind up with http://x.com///path
  	$url  =~ s{/+$}{};
  	$path =~ s{^/+}{};
  
  	# If a path has a % in it, URI escape it so it's not
  	# mistaken for a URI escape later.
  	$path =~ s{%}{%25}g;
  
  	return join '/', $url, $path;
  }
  
  1;
GIT_SVN_UTILS

$fatpacked{"private-Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PRIVATE-ERROR';
  # Error.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@ti.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Based on my original Error.pm, and Exceptions.pm by Peter Seibel
  # <peter@weblogic.com> and adapted by Jesse Glick <jglick@sig.bsh.com>.
  #
  # but modified ***significantly***
  
  package Error;
  
  use strict;
  use vars qw($VERSION);
  use 5.004;
  
  $VERSION = "0.15009";
  
  use overload (
  	'""'	   =>	'stringify',
  	'0+'	   =>	'value',
  	'bool'     =>	sub { return 1; },
  	'fallback' =>	1
  );
  
  $Error::Depth = 0;	# Depth to pass to caller()
  $Error::Debug = 0;	# Generate verbose stack traces
  @Error::STACK = ();	# Clause stack for try
  $Error::THROWN = undef;	# last error thrown, a workaround until die $ref works
  
  my $LAST;		# Last error created
  my %ERROR;		# Last error associated with package
  
  sub throw_Error_Simple
  {
      my $args = shift;
      return Error::Simple->new($args->{'text'});
  }
  
  $Error::ObjectifyCallback = \&throw_Error_Simple;
  
  
  # Exported subs are defined in Error::subs
  
  sub import {
      shift;
      local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
      Error::subs->import(@_);
  }
  
  # I really want to use last for the name of this method, but it is a keyword
  # which prevent the syntax  last Error
  
  sub prior {
      shift; # ignore
  
      return $LAST unless @_;
  
      my $pkg = shift;
      return exists $ERROR{$pkg} ? $ERROR{$pkg} : undef
  	unless ref($pkg);
  
      my $obj = $pkg;
      my $err = undef;
      if($obj->isa('HASH')) {
  	$err = $obj->{'__Error__'}
  	    if exists $obj->{'__Error__'};
      }
      elsif($obj->isa('GLOB')) {
  	$err = ${*$obj}{'__Error__'}
  	    if exists ${*$obj}{'__Error__'};
      }
  
      $err;
  }
  
  sub flush {
      shift; #ignore
  
      unless (@_) {
         $LAST = undef;
         return;
      }
  
      my $pkg = shift;
      return unless ref($pkg);
  
      undef $ERROR{$pkg} if defined $ERROR{$pkg};
  }
  
  # Return as much information as possible about where the error
  # happened. The -stacktrace element only exists if $Error::DEBUG
  # was set when the error was created
  
  sub stacktrace {
      my $self = shift;
  
      return $self->{'-stacktrace'}
  	if exists $self->{'-stacktrace'};
  
      my $text = exists $self->{'-text'} ? $self->{'-text'} : "Died";
  
      $text .= sprintf(" at %s line %d.\n", $self->file, $self->line)
  	unless($text =~ /\n$/s);
  
      $text;
  }
  
  # Allow error propagation, ie
  #
  # $ber->encode(...) or
  #    return Error->prior($ber)->associate($ldap);
  
  sub associate {
      my $err = shift;
      my $obj = shift;
  
      return unless ref($obj);
  
      if($obj->isa('HASH')) {
  	$obj->{'__Error__'} = $err;
      }
      elsif($obj->isa('GLOB')) {
  	${*$obj}{'__Error__'} = $err;
      }
      $obj = ref($obj);
      $ERROR{ ref($obj) } = $err;
  
      return;
  }
  
  sub new {
      my $self = shift;
      my($pkg,$file,$line) = caller($Error::Depth);
  
      my $err = bless {
  	'-package' => $pkg,
  	'-file'    => $file,
  	'-line'    => $line,
  	@_
      }, $self;
  
      $err->associate($err->{'-object'})
  	if(exists $err->{'-object'});
  
      # To always create a stacktrace would be very inefficient, so
      # we only do it if $Error::Debug is set
  
      if($Error::Debug) {
  	require Carp;
  	local $Carp::CarpLevel = $Error::Depth;
  	my $text = defined($err->{'-text'}) ? $err->{'-text'} : "Error";
  	my $trace = Carp::longmess($text);
  	# Remove try calls from the trace
  	$trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
  	$trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::run_clauses[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
  	$err->{'-stacktrace'} = $trace
      }
  
      $@ = $LAST = $ERROR{$pkg} = $err;
  }
  
  # Throw an error. this contains some very gory code.
  
  sub throw {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      # if we are not rethrow-ing then create the object to throw
      $self = $self->new(@_) unless ref($self);
  
      die $Error::THROWN = $self;
  }
  
  # syntactic sugar for
  #
  #    die with Error( ... );
  
  sub with {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      $self->new(@_);
  }
  
  # syntactic sugar for
  #
  #    record Error( ... ) and return;
  
  sub record {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      $self->new(@_);
  }
  
  # catch clause for
  #
  # try { ... } catch CLASS with { ... }
  
  sub catch {
      my $pkg = shift;
      my $code = shift;
      my $clauses = shift || {};
      my $catch = $clauses->{'catch'} ||= [];
  
      unshift @$catch,  $pkg, $code;
  
      $clauses;
  }
  
  # Object query methods
  
  sub object {
      my $self = shift;
      exists $self->{'-object'} ? $self->{'-object'} : undef;
  }
  
  sub file {
      my $self = shift;
      exists $self->{'-file'} ? $self->{'-file'} : undef;
  }
  
  sub line {
      my $self = shift;
      exists $self->{'-line'} ? $self->{'-line'} : undef;
  }
  
  sub text {
      my $self = shift;
      exists $self->{'-text'} ? $self->{'-text'} : undef;
  }
  
  # overload methods
  
  sub stringify {
      my $self = shift;
      defined $self->{'-text'} ? $self->{'-text'} : "Died";
  }
  
  sub value {
      my $self = shift;
      exists $self->{'-value'} ? $self->{'-value'} : undef;
  }
  
  package Error::Simple;
  
  @Error::Simple::ISA = qw(Error);
  
  sub new {
      my $self  = shift;
      my $text  = "" . shift;
      my $value = shift;
      my(@args) = ();
  
      local $Error::Depth = $Error::Depth + 1;
  
      @args = ( -file => $1, -line => $2)
  	if($text =~ s/\s+at\s+(\S+)\s+line\s+(\d+)(?:,\s*<[^>]*>\s+line\s+\d+)?\.?\n?$//s);
      push(@args, '-value', 0 + $value)
  	if defined($value);
  
      $self->SUPER::new(-text => $text, @args);
  }
  
  sub stringify {
      my $self = shift;
      my $text = $self->SUPER::stringify;
      $text .= sprintf(" at %s line %d.\n", $self->file, $self->line)
  	unless($text =~ /\n$/s);
      $text;
  }
  
  ##########################################################################
  ##########################################################################
  
  # Inspired by code from Jesse Glick <jglick@sig.bsh.com> and
  # Peter Seibel <peter@weblogic.com>
  
  package Error::subs;
  
  use Exporter ();
  use vars qw(@EXPORT_OK @ISA %EXPORT_TAGS);
  
  @EXPORT_OK   = qw(try with finally except otherwise);
  %EXPORT_TAGS = (try => \@EXPORT_OK);
  
  @ISA = qw(Exporter);
  
  
  sub blessed {
  	my $item = shift;
  	local $@; # don't kill an outer $@
  	ref $item and eval { $item->can('can') };
  }
  
  
  sub run_clauses ($$$\@) {
      my($clauses,$err,$wantarray,$result) = @_;
      my $code = undef;
  
      $err = $Error::ObjectifyCallback->({'text' =>$err}) unless ref($err);
  
      CATCH: {
  
  	# catch
  	my $catch;
  	if(defined($catch = $clauses->{'catch'})) {
  	    my $i = 0;
  
  	    CATCHLOOP:
  	    for( ; $i < @$catch ; $i += 2) {
  		my $pkg = $catch->[$i];
  		unless(defined $pkg) {
  		    #except
  		    splice(@$catch,$i,2,$catch->[$i+1]->());
  		    $i -= 2;
  		    next CATCHLOOP;
  		}
  		elsif(blessed($err) && $err->isa($pkg)) {
  		    $code = $catch->[$i+1];
  		    while(1) {
  			my $more = 0;
  			local($Error::THROWN);
  			my $ok = eval {
  			    if($wantarray) {
  				@{$result} = $code->($err,\$more);
  			    }
  			    elsif(defined($wantarray)) {
  			        @{$result} = ();
  				$result->[0] = $code->($err,\$more);
  			    }
  			    else {
  				$code->($err,\$more);
  			    }
  			    1;
  			};
  			if( $ok ) {
  			    next CATCHLOOP if $more;
  			    undef $err;
  			}
  			else {
  			    $err = defined($Error::THROWN)
  				    ? $Error::THROWN : $@;
                  $err = $Error::ObjectifyCallback->({'text' =>$err})
                      unless ref($err);
  			}
  			last CATCH;
  		    };
  		}
  	    }
  	}
  
  	# otherwise
  	my $owise;
  	if(defined($owise = $clauses->{'otherwise'})) {
  	    my $code = $clauses->{'otherwise'};
  	    my $more = 0;
  	    my $ok = eval {
  		if($wantarray) {
  		    @{$result} = $code->($err,\$more);
  		}
  		elsif(defined($wantarray)) {
  		    @{$result} = ();
  		    $result->[0] = $code->($err,\$more);
  		}
  		else {
  		    $code->($err,\$more);
  		}
  		1;
  	    };
  	    if( $ok ) {
  		undef $err;
  	    }
  	    else {
  		$err = defined($Error::THROWN)
  			? $Error::THROWN : $@;
  
          $err = $Error::ObjectifyCallback->({'text' =>$err})
              unless ref($err);
  	    }
  	}
      }
      $err;
  }
  
  sub try (&;$) {
      my $try = shift;
      my $clauses = @_ ? shift : {};
      my $ok = 0;
      my $err = undef;
      my @result = ();
  
      unshift @Error::STACK, $clauses;
  
      my $wantarray = wantarray();
  
      do {
  	local $Error::THROWN = undef;
      local $@ = undef;
  
  	$ok = eval {
  	    if($wantarray) {
  		@result = $try->();
  	    }
  	    elsif(defined $wantarray) {
  		$result[0] = $try->();
  	    }
  	    else {
  		$try->();
  	    }
  	    1;
  	};
  
  	$err = defined($Error::THROWN) ? $Error::THROWN : $@
  	    unless $ok;
      };
  
      shift @Error::STACK;
  
      $err = run_clauses($clauses,$err,wantarray,@result)
  	unless($ok);
  
      $clauses->{'finally'}->()
  	if(defined($clauses->{'finally'}));
  
      if (defined($err))
      {
          if (blessed($err) && $err->can('throw'))
          {
              throw $err;
          }
          else
          {
              die $err;
          }
      }
  
      wantarray ? @result : $result[0];
  }
  
  # Each clause adds a sub to the list of clauses. The finally clause is
  # always the last, and the otherwise clause is always added just before
  # the finally clause.
  #
  # All clauses, except the finally clause, add a sub which takes one argument
  # this argument will be the error being thrown. The sub will return a code ref
  # if that clause can handle that error, otherwise undef is returned.
  #
  # The otherwise clause adds a sub which unconditionally returns the users
  # code reference, this is why it is forced to be last.
  #
  # The catch clause is defined in Error.pm, as the syntax causes it to
  # be called as a method
  
  sub with (&;$) {
      @_
  }
  
  sub finally (&) {
      my $code = shift;
      my $clauses = { 'finally' => $code };
      $clauses;
  }
  
  # The except clause is a block which returns a hashref or a list of
  # key-value pairs, where the keys are the classes and the values are subs.
  
  sub except (&;$) {
      my $code = shift;
      my $clauses = shift || {};
      my $catch = $clauses->{'catch'} ||= [];
  
      my $sub = sub {
  	my $ref;
  	my(@array) = $code->($_[0]);
  	if(@array == 1 && ref($array[0])) {
  	    $ref = $array[0];
  	    $ref = [ %$ref ]
  		if(UNIVERSAL::isa($ref,'HASH'));
  	}
  	else {
  	    $ref = \@array;
  	}
  	@$ref
      };
  
      unshift @{$catch}, undef, $sub;
  
      $clauses;
  }
  
  sub otherwise (&;$) {
      my $code = shift;
      my $clauses = shift || {};
  
      if(exists $clauses->{'otherwise'}) {
  	require Carp;
  	Carp::croak("Multiple otherwise clauses");
      }
  
      $clauses->{'otherwise'} = $code;
  
      $clauses;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Error - Error/exception handling in an OO-ish way
  
  =head1 SYNOPSIS
  
      use Error qw(:try);
  
      throw Error::Simple( "A simple error");
  
      sub xyz {
          ...
  	record Error::Simple("A simple error")
  	    and return;
      }
  
      unlink($file) or throw Error::Simple("$file: $!",$!);
  
      try {
  	do_some_stuff();
  	die "error!" if $condition;
  	throw Error::Simple -text => "Oops!" if $other_condition;
      }
      catch Error::IO with {
  	my $E = shift;
  	print STDERR "File ", $E->{'-file'}, " had a problem\n";
      }
      except {
  	my $E = shift;
  	my $general_handler=sub {send_message $E->{-description}};
  	return {
  	    UserException1 => $general_handler,
  	    UserException2 => $general_handler
  	};
      }
      otherwise {
  	print STDERR "Well I don't know what to say\n";
      }
      finally {
  	close_the_garage_door_already(); # Should be reliable
      }; # Don't forget the trailing ; or you might be surprised
  
  =head1 DESCRIPTION
  
  The C<Error> package provides two interfaces. Firstly C<Error> provides
  a procedural interface to exception handling. Secondly C<Error> is a
  base class for errors/exceptions that can either be thrown, for
  subsequent catch, or can simply be recorded.
  
  Errors in the class C<Error> should not be thrown directly, but the
  user should throw errors from a sub-class of C<Error>.
  
  =head1 PROCEDURAL INTERFACE
  
  C<Error> exports subroutines to perform exception handling. These will
  be exported if the C<:try> tag is used in the C<use> line.
  
  =over 4
  
  =item try BLOCK CLAUSES
  
  C<try> is the main subroutine called by the user. All other subroutines
  exported are clauses to the try subroutine.
  
  The BLOCK will be evaluated and, if no error is throw, try will return
  the result of the block.
  
  C<CLAUSES> are the subroutines below, which describe what to do in the
  event of an error being thrown within BLOCK.
  
  =item catch CLASS with BLOCK
  
  This clauses will cause all errors that satisfy C<$err-E<gt>isa(CLASS)>
  to be caught and handled by evaluating C<BLOCK>.
  
  C<BLOCK> will be passed two arguments. The first will be the error
  being thrown. The second is a reference to a scalar variable. If this
  variable is set by the catch block then, on return from the catch
  block, try will continue processing as if the catch block was never
  found.
  
  To propagate the error the catch block may call C<$err-E<gt>throw>
  
  If the scalar reference by the second argument is not set, and the
  error is not thrown. Then the current try block will return with the
  result from the catch block.
  
  =item except BLOCK
  
  When C<try> is looking for a handler, if an except clause is found
  C<BLOCK> is evaluated. The return value from this block should be a
  HASHREF or a list of key-value pairs, where the keys are class names
  and the values are CODE references for the handler of errors of that
  type.
  
  =item otherwise BLOCK
  
  Catch any error by executing the code in C<BLOCK>
  
  When evaluated C<BLOCK> will be passed one argument, which will be the
  error being processed.
  
  Only one otherwise block may be specified per try block
  
  =item finally BLOCK
  
  Execute the code in C<BLOCK> either after the code in the try block has
  successfully completed, or if the try block throws an error then
  C<BLOCK> will be executed after the handler has completed.
  
  If the handler throws an error then the error will be caught, the
  finally block will be executed and the error will be re-thrown.
  
  Only one finally block may be specified per try block
  
  =back
  
  =head1 CLASS INTERFACE
  
  =head2 CONSTRUCTORS
  
  The C<Error> object is implemented as a HASH. This HASH is initialized
  with the arguments that are passed to its constructor. The elements
  that are used by, or are retrievable by the C<Error> class are listed
  below, other classes may add to these.
  
  	-file
  	-line
  	-text
  	-value
  	-object
  
  If C<-file> or C<-line> are not specified in the constructor arguments
  then these will be initialized with the file name and line number where
  the constructor was called from.
  
  If the error is associated with an object then the object should be
  passed as the C<-object> argument. This will allow the C<Error> package
  to associate the error with the object.
  
  The C<Error> package remembers the last error created, and also the
  last error associated with a package. This could either be the last
  error created by a sub in that package, or the last error which passed
  an object blessed into that package as the C<-object> argument.
  
  =over 4
  
  =item throw ( [ ARGS ] )
  
  Create a new C<Error> object and throw an error, which will be caught
  by a surrounding C<try> block, if there is one. Otherwise it will cause
  the program to exit.
  
  C<throw> may also be called on an existing error to re-throw it.
  
  =item with ( [ ARGS ] )
  
  Create a new C<Error> object and returns it. This is defined for
  syntactic sugar, eg
  
      die with Some::Error ( ... );
  
  =item record ( [ ARGS ] )
  
  Create a new C<Error> object and returns it. This is defined for
  syntactic sugar, eg
  
      record Some::Error ( ... )
  	and return;
  
  =back
  
  =head2 STATIC METHODS
  
  =over 4
  
  =item prior ( [ PACKAGE ] )
  
  Return the last error created, or the last error associated with
  C<PACKAGE>
  
  =item flush ( [ PACKAGE ] )
  
  Flush the last error created, or the last error associated with
  C<PACKAGE>.It is necessary to clear the error stack before exiting the
  package or uncaught errors generated using C<record> will be reported.
  
       $Error->flush;
  
  =cut
  
  =back
  
  =head2 OBJECT METHODS
  
  =over 4
  
  =item stacktrace
  
  If the variable C<$Error::Debug> was non-zero when the error was
  created, then C<stacktrace> returns a string created by calling
  C<Carp::longmess>. If the variable was zero the C<stacktrace> returns
  the text of the error appended with the filename and line number of
  where the error was created, providing the text does not end with a
  newline.
  
  =item object
  
  The object this error was associated with
  
  =item file
  
  The file where the constructor of this error was called from
  
  =item line
  
  The line where the constructor of this error was called from
  
  =item text
  
  The text of the error
  
  =back
  
  =head2 OVERLOAD METHODS
  
  =over 4
  
  =item stringify
  
  A method that converts the object into a string. This method may simply
  return the same as the C<text> method, or it may append more
  information. For example the file name and line number.
  
  By default this method returns the C<-text> argument that was passed to
  the constructor, or the string C<"Died"> if none was given.
  
  =item value
  
  A method that will return a value that can be associated with the
  error. For example if an error was created due to the failure of a
  system call, then this may return the numeric value of C<$!> at the
  time.
  
  By default this method returns the C<-value> argument that was passed
  to the constructor.
  
  =back
  
  =head1 PRE-DEFINED ERROR CLASSES
  
  =over 4
  
  =item Error::Simple
  
  This class can be used to hold simple error strings and values. Its
  constructor takes two arguments. The first is a text value, the second
  is a numeric value. These values are what will be returned by the
  overload methods.
  
  If the text value ends with C<at file line 1> as $@ strings do, then
  this information will be used to set the C<-file> and C<-line> arguments
  of the error object.
  
  This class is used internally if an eval'd block die's with an error
  that is a plain string. (Unless C<$Error::ObjectifyCallback> is modified)
  
  =back
  
  =head1 $Error::ObjectifyCallback
  
  This variable holds a reference to a subroutine that converts errors that
  are plain strings to objects. It is used by Error.pm to convert textual
  errors to objects, and can be overridden by the user.
  
  It accepts a single argument which is a hash reference to named parameters.
  Currently the only named parameter passed is C<'text'> which is the text
  of the error, but others may be available in the future.
  
  For example the following code will cause Error.pm to throw objects of the
  class MyError::Bar by default:
  
      sub throw_MyError_Bar
      {
          my $args = shift;
          my $err = MyError::Bar->new();
          $err->{'MyBarText'} = $args->{'text'};
          return $err;
      }
  
      {
          local $Error::ObjectifyCallback = \&throw_MyError_Bar;
  
          # Error handling here.
      }
  
  =head1 KNOWN BUGS
  
  None, but that does not mean there are not any.
  
  =head1 AUTHORS
  
  Graham Barr <gbarr@pobox.com>
  
  The code that inspired me to write this was originally written by
  Peter Seibel <peter@weblogic.com> and adapted by Jesse Glick
  <jglick@sig.bsh.com>.
  
  =head1 MAINTAINER
  
  Shlomi Fish <shlomif@iglu.org.il>
  
  =head1 PAST MAINTAINERS
  
  Arun Kumar U <u_arunkumar@yahoo.com>
  
  =cut
PRIVATE-ERROR

$fatpacked{"x86_64-linux-gnu-thread-multi/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle uniq uniqnum uniqstr
    head tail pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.50";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first
  
        max maxstr min minstr product sum sum0
  
        pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniq uniqnum uniqstr
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  Note also that multiple IEEE C<NaN> values are treated as duplicates of
  each other, regardless of any differences in their payloads, and despite
  the fact that C<< 0+'NaN' == 0+'NaN' >> yields false.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head2 head
  
      my @values = head $size, @list;
  
  Returns the first C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the last C<$size> elements from C<@list>.
  
      @result = head 2, qw( foo bar baz );
      # foo, bar
  
      @result = head -2, qw( foo bar baz );
      # foo
  
  =head2 tail
  
      my @values = tail $size, @list;
  
  Returns the last C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the first C<$size> elements from C<@list>.
  
      @result = tail 2, qw( foo bar baz );
      # bar, baz
  
      @result = tail -2, qw( foo bar baz );
      # baz
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_LIST_UTIL

$fatpacked{"x86_64-linux-gnu-thread-multi/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.50";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_LIST_UTIL_XS

$fatpacked{"x86_64-linux-gnu-thread-multi/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.50";
  $VERSION   = eval $VERSION;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be a dual-valued variable, it is
  actually implemented as a magical variable inside the interpreter:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use L</isweak> or L</weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_SCALAR_UTIL

$fatpacked{"x86_64-linux-gnu-thread-multi/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.50";
  $VERSION   = eval $VERSION;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If a name has been set using L</set_subname>, this name will
  be returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.*?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_SUB_UTIL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use App::GitFind;
our $VERSION = $App::GitFind::VERSION;  # for Getopt::Long auto_version
exit App::GitFind->new(\@ARGV)->run;
__END__

# === Documentation === {{{1

=head1 NAME

git-find - Find files anywhere in a Git repository

=head1 SYNOPSIS

Quick summary of what the module does.

Perhaps a little code snippet.

    git find something_or_other

=head1 AUTHOR

Christopher White, C<< <cxw at cpan.org> >>

=head1 BUGS

Please report any bugs or feature requests through the GitHub interface at
L<https://github.com/cxw42/git-find/issues>.  I will be notified, and then
you'll automatically be notified of progress on your bug as I make changes.

=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc App::GitFind

You can also look for information at:

=over 4

=item * GitHub (report bugs here)

L<https://github.com/cxw42/git-find>

=item * MetaCPAN

L<https://metacpan.org/release/App-GitFind>

=back

=head1 LICENSE AND COPYRIGHT

Copyright 2019 Christopher White.

This program is distributed under the MIT (X11) License:
L<http://www.opensource.org/licenses/mit-license.php>

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

=cut

# }}}1
# vi: set fdm=marker fdl=0: #
